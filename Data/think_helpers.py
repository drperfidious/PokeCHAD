# Auto-generated by patch_think_runtime_mapping.py
from __future__ import annotations
from typing import Any, Dict, List, Optional, Sequence, Tuple

def parse_condition(cond: str) -> Dict[str, Optional[float]]:
    """
    Parse Showdown 'condition' strings like:
      "263/263" -> {"hp": 263, "max": 263, "percent": 100.0}
      "62/263"  -> {"hp": 62,  "max": 263, "percent": 23.57}
      "0 fnt"   -> {"hp": 0,   "max": None, "percent": 0.0}
    """
    if not cond:
        return {"hp": None, "max": None, "percent": None}
    s = cond.strip().lower()
    if "fnt" in s:
        return {"hp": 0, "max": None, "percent": 0.0}
    try:
        cur, mx = s.split("/", 1)
        curf = float(cur)
        mxf = float(mx)
        pct = (curf / mxf * 100.0) if mxf > 0 else None
        return {"hp": curf, "max": mxf, "percent": pct}
    except Exception:
        return {"hp": None, "max": None, "percent": None}

def normalize_accuracy(acc: Any) -> Optional[float]:
    """
    Showdown data uses:
      - number (e.g., 100, 80)
      - True (means 'always hits' for many self/status moves)
      - None/False for no accuracy (edge cases)
    We convert True -> 100.0 so downstream math behaves.
    """
    if acc is True:
        return 100.0
    if acc in (None, False):
        return None
    try:
        return float(acc)
    except Exception:
        return None

_SPREAD_TARGETS = {"alladjacent", "alladjacentfoes"}

def is_spread_move(target: Optional[str]) -> bool:
    return (target or "").replace(" ", "").lower() in _SPREAD_TARGETS

def resolve_move_type(
    move_id: str,
    static_type: Optional[str],
    attacker_types: Optional[Sequence[str]] = None,
    tera_type: Optional[str] = None,
    terastallized: bool = False,
    weather: Optional[str] = None,
) -> Optional[str]:
    """
    Handle dynamic typing for common cases. Falls back to static_type when unknown.
    """
    mid = (move_id or "").lower()
    if mid == "revelationdance":
        if attacker_types and len(attacker_types) > 0:
            return (attacker_types[0] or "NORMAL").upper()
    if mid == "terablast" and terastallized and tera_type:
        return tera_type.upper()
    if mid == "weatherball":
        if weather:
            w = weather.lower()
            if w in ("rain", "primordialsea"): return "WATER"
            if w in ("sun", "sunnyday", "desolateland"): return "FIRE"
            if w == "sandstorm": return "ROCK"
            if w in ("hail", "snow"): return "ICE"
        return "NORMAL"
    # Others like Judgment/Multi-Attack/Techno Blast need held item/plate/drive context.
    return (static_type or None if static_type else None)

def resolve_terablast_category(
    move_id: str,
    base_category: Optional[str],
    terastallized: bool,
    atk: Optional[float],
    spa: Optional[float],
) -> Optional[str]:
    if (move_id or "").lower() != "terablast":
        return base_category
    if terastallized and atk is not None and spa is not None:
        return "Physical" if atk > spa else "Special"
    return base_category

def enrich_moves_from_request(
    request_moves: List[Dict[str, Any]],
    dex_lookup_fn,
    attacker_ctx: Dict[str, Any],
    weather: Optional[str] = None,
) -> List[Dict[str, Any]]:
    """
    Given request['active'][0]['moves'] and a lookup function like:
        lambda mid: moves_info.get(mid)
    build enriched move dicts with resolved type/category/accuracy, and live PP.
    """
    out = []
    atk_types = attacker_ctx.get("types")  # Optional[List[str]], if you have it
    tera_type = attacker_ctx.get("teraType")
    terastallized = bool(attacker_ctx.get("terastallized"))
    atk_stat = attacker_ctx.get("atk")
    spa_stat = attacker_ctx.get("spa")

    for m in request_moves or []:
        mid = (m.get("id") or m.get("move") or "").replace(" ", "").lower()
        try:
            dex = dex_lookup_fn(mid)  # should return MoveInfo-like or dict with fields
            # Try attributes first (dataclass), else dict
            static_type = getattr(dex, "type", None) if hasattr(dex, "__dict__") else dex.get("type")
            base_cat = getattr(dex, "category", None) if hasattr(dex, "__dict__") else dex.get("category")
            acc_raw = getattr(dex, "accuracy", None) if hasattr(dex, "__dict__") else dex.get("accuracy")
            target = m.get("target") or (getattr(dex, "target", None) if hasattr(dex, "__dict__") else dex.get("target"))

            acc = normalize_accuracy(acc_raw)
            rtype = resolve_move_type(
                move_id=mid, static_type=static_type, attacker_types=atk_types,
                tera_type=tera_type, terastallized=terastallized, weather=weather,
            )
            rcat = resolve_terablast_category(mid, base_cat, terastallized, atk_stat, spa_stat)

            out.append({
                "id": mid,
                "name": m.get("move") or getattr(dex, "name", None) or mid,
                "type": rtype or static_type,
                "category": rcat or base_cat,
                "accuracy": acc,                   # numeric or None
                "target": target,
                "is_spread": is_spread_move(target),
                "pp": m.get("pp"),                 # LIVE PP
                "maxpp": m.get("maxpp"),           # LIVE max PP
                "base_pp": getattr(dex, "pp", None) if hasattr(dex, "__dict__") else dex.get("pp"),
                "base_power": getattr(dex, "base_power", None) if hasattr(dex, "__dict__") else (dex.get("basePower") or dex.get("base_power")),
                "raw_dex": getattr(dex, "raw", None) if hasattr(dex, "__dict__") else dex,
            })
        except Exception:
            out.append({
                "id": mid,
                "name": m.get("move") or mid,
                "type": None,
                "category": None,
                "accuracy": None,
                "target": m.get("target"),
                "is_spread": is_spread_move(m.get("target")),
                "pp": m.get("pp"),
                "maxpp": m.get("maxpp"),
                "base_pp": None,
                "base_power": None,
                "raw_dex": None,
            })
    return out
