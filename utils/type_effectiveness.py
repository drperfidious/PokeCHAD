# Auto-generated by fix_type_effectiveness.py
from __future__ import annotations
import logging
from pathlib import Path
from typing import Dict, Tuple, List, Optional
from .showdown_loader import ShowdownData
import os

log = logging.getLogger("typecalc")

# Hard-coded correct Gen 6+ chart (used only if no JSON provided)
# eff[atk][def] = multiplier
# fmt: off
_TYPES = ["Normal","Fire","Water","Electric","Grass","Ice","Fighting","Poison","Ground","Flying","Psychic","Bug","Rock","Ghost","Dragon","Dark","Steel","Fairy"]
def _matrix() -> Dict[str, Dict[str, float]]:
    n = 1.0; h = 0.5; s = 2.0; z = 0.0
    eff = {t: {u: n for u in _TYPES} for t in _TYPES}
    # Normal
    eff["Normal"]["Rock"]=h; eff["Normal"]["Ghost"]=z; eff["Normal"]["Steel"]=h
    # Fire
    for u in ["Fire","Water","Rock","Dragon"]: eff["Fire"][u]=h
    for u in ["Grass","Ice","Bug","Steel"]: eff["Fire"][u]=s
    # Water
    for u in ["Fire","Ground","Rock"]: eff["Water"][u]=s
    for u in ["Water","Grass","Dragon"]: eff["Water"][u]=h
    # Electric
    for u in ["Water","Flying"]: eff["Electric"][u]=s
    for u in ["Electric","Grass","Dragon"]: eff["Electric"][u]=h
    eff["Electric"]["Ground"]=z
    # Grass
    for u in ["Water","Ground","Rock"]: eff["Grass"][u]=s
    for u in ["Fire","Grass","Poison","Flying","Bug","Dragon","Steel"]: eff["Grass"][u]=h
    # Ice
    for u in ["Grass","Ground","Flying","Dragon"]: eff["Ice"][u]=s
    for u in ["Fire","Water","Ice","Steel"]: eff["Ice"][u]=h
    # Fighting
    for u in ["Normal","Ice","Rock","Dark","Steel"]: eff["Fighting"][u]=s
    for u in ["Poison","Flying","Psychic","Bug","Fairy"]: eff["Fighting"][u]=h
    eff["Fighting"]["Ghost"]=z
    # Poison
    eff["Poison"]["Grass"]=s
    for u in ["Poison","Ground","Rock","Ghost"]: eff["Poison"][u]=h
    eff["Poison"]["Steel"]=z
    eff["Poison"]["Fairy"]=s
    # Ground
    for u in ["Fire","Electric","Poison","Rock","Steel"]: eff["Ground"][u]=s
    for u in ["Grass","Bug"]: eff["Ground"][u]=h
    eff["Ground"]["Flying"]=z
    # Flying
    for u in ["Grass","Fighting","Bug"]: eff["Flying"][u]=s
    for u in ["Electric","Rock","Steel"]: eff["Flying"][u]=h
    # Psychic
    for u in ["Fighting","Poison"]: eff["Psychic"][u]=s
    for u in ["Psychic","Steel"]: eff["Psychic"][u]=h
    eff["Psychic"]["Dark"]=z
    # Bug
    for u in ["Grass","Psychic","Dark"]: eff["Bug"][u]=s
    for u in ["Fire","Fighting","Poison","Flying","Ghost","Steel","Fairy"]: eff["Bug"][u]=h
    # Rock
    for u in ["Fire","Ice","Flying","Bug"]: eff["Rock"][u]=s
    for u in ["Fighting","Ground","Steel"]: eff["Rock"][u]=h
    # Ghost
    eff["Ghost"]["Ghost"]=s; eff["Ghost"]["Psychic"]=s
    eff["Ghost"]["Dark"]=h; eff["Ghost"]["Normal"]=z
    # Dragon
    eff["Dragon"]["Dragon"]=s; eff["Dragon"]["Steel"]=h; eff["Dragon"]["Fairy"]=z
    # Dark
    eff["Dark"]["Psychic"]=s; eff["Dark"]["Ghost"]=s
    for u in ["Fighting","Dark","Fairy"]: eff["Dark"][u]=h
    # Steel
    for u in ["Rock","Ice","Fairy"]: eff["Steel"][u]=s
    for u in ["Fire","Water","Electric","Steel"]: eff["Steel"][u]=h
    # Fairy
    for u in ["Fighting","Dragon","Dark"]: eff["Fairy"][u]=s
    for u in ["Fire","Poison","Steel"]: eff["Fairy"][u]=h
    return eff
# fmt: on

def _title(s: str) -> str:
    return s[:1].upper() + s[1:].lower() if s else s

class TypeCalc:
    def __init__(self, data: ShowdownData | None):
        self.data = data
        self._fallback = _matrix()
        # Add type_chart property for RealBattleEngine compatibility
        self.type_chart = self._fallback

    def move_type(self, move_id: str, is_terastallized: bool = False, attacker_tera_type: Optional[str] = None) -> Optional[str]:
        mid = move_id.lower()
        mv = self.data.get_move(mid) if self.data else {}
        t = mv.get("type")
        # Tera Blast rule: Normal if not terastallized. When Tera is active, it becomes the Tera type.
        if mid == "terablast":
            if is_terastallized and attacker_tera_type:
                return _title(attacker_tera_type)
            return "Normal"
        return _title(t) if t else None

    def species_types(self, species_id: str) -> List[str]:
        sid = species_id.lower()
        ts = self.data.get_types_for_species(sid) if self.data else []
        if ts:
            return [_title(x) for x in ts]
        # Unknown species in data -> assume typeless neutral (will behave as 1.0 vs everything)
        return []

    def type_multiplier(self, atk_type: str, def_types: List[str]) -> Tuple[float, List[str]]:
        if not atk_type:
            return 1.0, ["no-attack-type"]
        reasons = []
        total = 1.0
        src = self.data.typechart if (self.data and self.data.typechart) else self._fallback
        atk_title = _title(atk_type)
        if atk_title not in src:
            return 1.0, [f"missing-atk-type:{atk_title}"]
        for dt in def_types or []:
            dtt = _title(dt)
            mult = src[atk_title].get(dtt)
            if mult is None:
                # If JSON not present, fall back to hard-coded
                mult = self._fallback.get(atk_title, {}).get(dtt, 1.0)
                reasons.append(f"fallback:{atk_title}->{dtt}={mult}")
            else:
                reasons.append(f"{atk_title}->{dtt}={mult}")
            total *= mult
        return total, reasons

    def effectiveness(self, move_id: str, attacker_species: Optional[str], defender_species: Optional[str],
                       is_terastallized: bool = False, attacker_tera_type: Optional[str] = None) -> Tuple[float, List[str]]:
        mtype = self.move_type(move_id, is_terastallized, attacker_tera_type)
        dtypes = self.species_types(defender_species) if defender_species else []
        mult, reasons = self.type_multiplier(mtype, dtypes)
        log.debug("eff: move=%s(%s) atk=%s def=%s types=%s -> %.3f | %s",
                  move_id, mtype, attacker_species, defender_species, dtypes, mult, "; ".join(reasons))
        return mult, reasons

# Singleton-ish so UI can just import and use
_instance: Optional[TypeCalc] = None

def _auto_data_dir() -> Path:
    root = Path(__file__).resolve().parent.parent  # project root (utils/..)
    candidates = [
        root / 'tools' / 'Data' / 'showdown',
        root / 'showdown',
        root / 'tools' / 'showdown',
        root / 'Resources' / 'showdown',
    ]
    env = os.getenv('POKECHAD_SHOWDOWN_DIR')
    if env:
        p = Path(env)
        if (p / 'moves.json').exists() or (p / 'pokedex.json').exists():
            return p
    for c in candidates:
        if (c / 'moves.json').exists() or (c / 'pokedex.json').exists():
            return c
    return candidates[0]

def init_typecalc(data_dir: Path | str) -> TypeCalc:
    global _instance
    try:
        sd = ShowdownData(Path(data_dir))
    except Exception as e:
        log.warning("ShowdownData init failed: %s. Falling back to built-in chart only.", e)
        sd = None
    _instance = TypeCalc(sd)
    log.info("TypeCalc initialized. Data present: moves=%s pokedex=%s typechart=%s",
             bool(sd and sd.moves), bool(sd and sd.pokedex), bool(sd and sd.typechart))
    return _instance

def get() -> TypeCalc:
    global _instance
    if _instance is None:
        _instance = init_typecalc(_auto_data_dir())
    return _instance

def install_logging_hook():
    # Called from tk_main_menu.py (or anywhere) to ensure file logging exists
    import logging, os
    from pathlib import Path
    logs = Path(os.getenv("POKECHAD_LOG_DIR", "logs"))
    logs.mkdir(parents=True, exist_ok=True)
    fh = logging.FileHandler(logs / "typecalc_debug.log", encoding="utf-8")
    fmt = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    fh.setFormatter(fmt)
    root = logging.getLogger("typecalc")
    if not any(isinstance(h, logging.FileHandler) for h in root.handlers):
        root.addHandler(fh)
    root.setLevel(logging.DEBUG)
    return root
