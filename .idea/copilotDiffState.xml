<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Models/GPT_Model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Models/GPT_Model.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;GPT-based AI model for Pokemon battle decisions&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import os&#10;import json&#10;from typing import Dict, List, Optional, Any&#10;import asyncio&#10;&#10;# Third-party imports&#10;# import openai&#10;# import torch&#10;# from transformers import GPTModel, GPTTokenizer&#10;# import numpy as np&#10;&#10;# Local imports&#10;# from Data.battle_helper import BattleHelper&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;# from Data.poke_env_pokemon_info import PokemonInfo&#10;&#10;class GPTModel:&#10;    &quot;&quot;&quot;GPT-based model for Pokemon battle AI&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Models/stockfish_model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Models/stockfish_model.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;import json&#10;import os&#10;&#10;&#10;&#10;&#10;&#10;from dataclasses import dataclass&#10;&#10;&#10;from typing import Any, Dict, List, Optional, Callable&#10;&#10;&#10;&#10;&#10;&#10;# Import mechanics from the Data package&#10;&#10;&#10;from Data.battle_runtime import (&#10;&#10;&#10;    get_state,&#10;&#10;&#10;    predict_order_for_ids,&#10;&#10;&#10;    estimate_damage,&#10;&#10;&#10;    would_fail,&#10;&#10;&#10;    apply_switch_in_effects,&#10;&#10;&#10;)&#10;&#10;&#10;from Data.poke_env_battle_environment import snapshot as snapshot_battle&#10;&#10;&#10;from Data.poke_env_moves_info import MovesInfo&#10;&#10;# --- learned weights (optional) --------------------------------------------&#10;def _load_weights(path: str = os.path.join(&quot;Models&quot;, &quot;weights.json&quot;)) -&gt; dict:&#10;    try:&#10;        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            w = json.load(f)&#10;        # safe defaults&#10;        return {&#10;            &quot;go_first_bonus&quot;: float(w.get(&quot;go_first_bonus&quot;, 0.4)),&#10;            &quot;opp_dmg_penalty&quot;: float(w.get(&quot;opp_dmg_penalty&quot;, 1.0)),&#10;            &quot;survival_bonus&quot;: float(w.get(&quot;survival_bonus&quot;, 0.0)),&#10;        }&#10;    except Exception:&#10;        return {&quot;go_first_bonus&quot;: 0.4, &quot;opp_dmg_penalty&quot;: 1.0, &quot;survival_bonus&quot;: 0.0}&#10;&#10;&#10;&#10;&#10;&#10;&#10;# ---------------- helpers (local only) -----------------&#10;&#10;&#10;def _acc_to_prob(acc) -&gt; float:&#10;&#10;&#10;    # poke-env accuracy can be True (100), int 0..100, float 0..1&#10;&#10;&#10;    if acc is True:&#10;&#10;&#10;        return 1.0&#10;&#10;&#10;    if acc is None:&#10;&#10;&#10;        return 1.0&#10;&#10;&#10;    try:&#10;&#10;&#10;        x = float(acc)&#10;&#10;&#10;        return x / 100.0 if x &gt; 1.0 else max(0.0, min(1.0, x))&#10;&#10;&#10;    except Exception:&#10;&#10;&#10;        return 1.0&#10;&#10;&#10;&#10;&#10;&#10;def _type_mult(att_type: str, defender_types, chart: Dict[str, Dict[str, float]]) -&gt; float:&#10;    &quot;&quot;&quot;Calculate type effectiveness multiplier correctly handling case sensitivity.&quot;&quot;&quot;&#10;    if not chart or not att_type or not defender_types:&#10;        return 1.0&#10;&#10;    # Normalize type names to match chart keys (usually UPPERCASE)&#10;    chart_keys = set(chart.keys())&#10;    att_type_norm = None&#10;&#10;    # Find the correct case for the attack type in the chart&#10;    for key in chart_keys:&#10;        if key.upper() == att_type.upper():&#10;            att_type_norm = key&#10;            break&#10;&#10;    if not att_type_norm:&#10;        return 1.0&#10;&#10;    mult = 1.0&#10;    for def_type in defender_types:&#10;        if not def_type:&#10;            continue&#10;&#10;        # Find the correct case for the defense type&#10;        def_type_norm = None&#10;        for target_key in chart[att_type_norm]:&#10;            if target_key.upper() == def_type.upper():&#10;                def_type_norm = target_key&#10;                break&#10;&#10;        if def_type_norm:&#10;            effectiveness = chart[att_type_norm][def_type_norm]&#10;            mult *= effectiveness&#10;&#10;    return mult&#10;&#10;&#10;&#10;&#10;&#10;# ---------------- Public data container -----------------&#10;&#10;&#10;@dataclass&#10;&#10;&#10;class ChosenAction:&#10;&#10;&#10;    kind: str  # 'move' | 'switch'&#10;&#10;&#10;    move_id: Optional[str] = None&#10;&#10;&#10;    switch_species: Optional[str] = None&#10;&#10;&#10;    debug: Dict[str, Any] | None = None&#10;&#10;&#10;&#10;&#10;&#10;# ----------------- Core engine --------------------------&#10;&#10;&#10;class StockfishModel:&#10;&#10;&#10;    def __init__(self, battle_format: str = 'gen9ou'):&#10;&#10;&#10;        self.battle_format = battle_format&#10;&#10;&#10;        self._W = _load_weights()&#10;        # configurable 'depth' knob the UI may tweak; we don't tree-search but keep it as a param&#10;&#10;&#10;        self._depth = 3&#10;&#10;&#10;&#10;&#10;&#10;    def set_depth(self, d: int):&#10;&#10;&#10;        self._depth = int(d)&#10;&#10;&#10;&#10;&#10;&#10;    def choose_action(self, battle: Any) -&gt; ChosenAction:&#10;&#10;&#10;        &quot;&quot;&quot;Return ChosenAction and rich debug info for the UI.&quot;&quot;&quot;&#10;&#10;&#10;        state = get_state(battle)&#10;&#10;&#10;        mi = MovesInfo(state.format or 9)&#10;        type_chart = mi.get_type_chart()&#10;        print(f&quot;DEBUG: MovesInfo format: {state.format or 9}&quot;)&#10;        print(f&quot;DEBUG: Type chart size: {len(type_chart) if type_chart else 0}&quot;)&#10;        if type_chart:&#10;            print(f&quot;DEBUG: Sample types: {list(type_chart.keys())[:5]}&quot;)&#10;        print(f&quot;DEBUG: MovesInfo initialized with format: {state.format or 9}&quot;)&#10;        print(f&quot;DEBUG: Type chart loaded: {bool(mi.get_type_chart())}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;        # Determine active slots for both sides&#10;&#10;&#10;        def _active_key(side: Dict[str, Any]) -&gt; Optional[str]:&#10;&#10;&#10;            for k, p in side.items():&#10;&#10;&#10;                if getattr(p, 'is_active', False):&#10;&#10;&#10;                    return k&#10;&#10;&#10;            for k, p in side.items():&#10;&#10;&#10;                if (getattr(p, 'status', None) or '').lower() == 'fnt':&#10;&#10;&#10;                    continue&#10;&#10;&#10;                chp = getattr(p, 'current_hp', None)&#10;&#10;&#10;                if chp is None:&#10;&#10;&#10;                    return k&#10;&#10;&#10;                if chp &gt; 0:&#10;&#10;&#10;                    return k&#10;&#10;&#10;            return None&#10;&#10;&#10;&#10;&#10;&#10;        my_key = _active_key(state.team.ours) if getattr(state, 'team', None) else None&#10;&#10;&#10;        opp_key = _active_key(state.team.opponent) if getattr(state, 'team', None) else None&#10;&#10;&#10;&#10;&#10;&#10;        legal_moves = list(getattr(battle, 'available_moves', []) or [])&#10;&#10;&#10;        legal_switches = list(getattr(battle, 'available_switches', []) or [])&#10;&#10;&#10;        force_switch = bool(getattr(battle, 'force_switch', False)) or (not legal_moves and bool(legal_switches))&#10;&#10;&#10;&#10;&#10;&#10;        # Reveal opponent move ids if we know them; give a safe default&#10;&#10;&#10;        opp_moves_known = []&#10;&#10;&#10;        try:&#10;&#10;&#10;            if opp_key:&#10;&#10;&#10;                opp_ps = state.team.opponent[opp_key]&#10;&#10;&#10;                opp_moves_known = [m.id for m in (opp_ps.moves or []) if getattr(m, &quot;id&quot;, None)]&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;        default_opp_move = opp_moves_known[0] if opp_moves_known else &quot;tackle&quot;&#10;&#10;&#10;&#10;&#10;&#10;        # ---- Evaluate MOVES ---------------------------------------------------&#10;&#10;&#10;        moves_eval: List[Dict[str, Any]] = []&#10;&#10;&#10;        if not force_switch and my_key and opp_key:&#10;&#10;&#10;            opp_ps = state.team.opponent[opp_key]&#10;&#10;&#10;            opp_max = int(getattr(opp_ps, 'max_hp', 0) or opp_ps.stats.raw.get('hp', 1) or 1)&#10;&#10;&#10;            for mv in legal_moves:&#10;&#10;&#10;                mid = getattr(mv, 'id', None) or getattr(mv, 'move_id', None)&#10;&#10;&#10;                name = getattr(mv, 'name', str(mid))&#10;&#10;&#10;                if not mid:&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                # Filter out immediate failure (eg. sleep talk while awake)&#10;&#10;&#10;                fail, why = False, None&#10;&#10;&#10;                try:&#10;&#10;&#10;                    fail, why = would_fail(str(mid), my_key, opp_key, state, mi)&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    pass&#10;&#10;&#10;                if fail:&#10;&#10;&#10;                    moves_eval.append({&#10;&#10;&#10;                        'id': str(mid), 'name': name, 'score': 0.0, 'expected': 0.0,&#10;&#10;&#10;                        'acc_mult': 0.0, 'effectiveness': 0.0, 'why_blocked': str(why or 'would fail')&#10;&#10;&#10;                    })&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                try:&#10;&#10;&#10;                    dmg = estimate_damage(state, my_key, opp_key, str(mid), mi)&#10;&#10;&#10;                    rolls = list(dmg.get('rolls', []) or [])&#10;&#10;&#10;                    avg = sum(rolls) / len(rolls) if rolls else 0.0&#10;&#10;&#10;                    eff = float(dmg.get('effectiveness', 1.0) or 1.0)&#10;                    # Use recalculated effectiveness from _type_mult if available&#10;                    move_raw = mi.raw(str(mid))&#10;                    if move_raw:&#10;                        move_type = move_raw.get(&quot;type&quot;, &quot;&quot;)&#10;                        def_types = getattr(state.team.opponent[opp_key], &quot;types&quot;, [])&#10;                        if move_type and def_types and type_chart:&#10;                            eff = _type_mult(move_type, def_types, type_chart)&#10;&#10;                    # Debug type effectiveness&#10;                    move_raw = mi.raw(str(mid))&#10;                    if move_raw:&#10;                        move_type = move_raw.get(&quot;type&quot;, &quot;unknown&quot;)&#10;                        def_types = getattr(state.team.opponent[opp_key], &quot;types&quot;, [])&#10;                        print(f&quot;DEBUG: Move {mid} ({move_type}) vs {def_types} = {eff}x effectiveness&quot;)&#10;&#10;                        # Recalculate effectiveness if we have type info&#10;                        if move_type != &quot;unknown&quot; and def_types and type_chart:&#10;                            recalc_eff = _type_mult(move_type, def_types, type_chart)&#10;                            if abs(recalc_eff - eff) &gt; 0.01:&#10;                                                                eff = recalc_eff&#10;                    print(f&quot;DEBUG: Move {mid} effectiveness: {eff}, damage rolls: {rolls}&quot;)&#10;                    # Show move type information&#10;                    move_raw = mi.raw(str(mid))&#10;                    move_type = move_raw.get(&quot;type&quot;, &quot;unknown&quot;) if move_raw else &quot;unknown&quot;&#10;                    print(f&quot;DEBUG: Move {mid} type: {move_type}&quot;)&#10;                    # Show defender types&#10;                    opp_types = getattr(state.team.opponent[opp_key], &quot;types&quot;, [])&#10;                    print(f&quot;DEBUG: Defender {opp_key} types: {opp_types}&quot;)&#10;&#10;                    acc_p = _acc_to_prob(getattr(mv, 'accuracy', 1.0))&#10;&#10;&#10;                    # chance to move first (priority/speed); use default opp move if unknown&#10;&#10;&#10;                    first_prob, _ = predict_order_for_ids(state, my_key, str(mid), opp_key, default_opp_move, mi)&#10;&#10;&#10;                    expected = (avg / float(opp_max)) * acc_p&#10;&#10;&#10;                    # mild emphasis on moving first, but don't double-count type (already in rolls)&#10;&#10;&#10;                    score = expected * (0.6 + 0.4 * float(first_prob))&#10;&#10;&#10;                    moves_eval.append({&#10;&#10;&#10;                        'id': str(mid), 'name': name,&#10;&#10;&#10;                        'score': float(score),&#10;&#10;&#10;                        'expected': float(expected),&#10;&#10;&#10;                        'acc_mult': float(acc_p),&#10;&#10;&#10;                        'effectiveness': float(eff),&#10;&#10;&#10;                    })&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    moves_eval.append({'id': str(mid), 'name': name, 'score': 0.0, 'expected': 0.0, 'note': f'err: {e}'})&#10;&#10;&#10;            moves_eval.sort(key=lambda x: x.get('score', 0.0), reverse=True)&#10;&#10;&#10;&#10;&#10;&#10;        # ---- Evaluate SWITCHES -----------------------------------------------&#10;&#10;&#10;        switches_eval: List[Dict[str, Any]] = []&#10;&#10;&#10;        if legal_switches and opp_key:&#10;&#10;&#10;            chart = mi.get_type_chart()&#10;&#10;&#10;            # Current active (for risk comparison if we stay)&#10;&#10;&#10;            stay_incoming = 0.0&#10;&#10;&#10;            try:&#10;&#10;&#10;                # worst revealed incoming against current active&#10;&#10;&#10;                if my_key and opp_moves_known:&#10;&#10;&#10;                    my_ps = state.team.ours[my_key]&#10;&#10;&#10;                    my_max = float(my_ps.max_hp or my_ps.stats.raw.get(&quot;hp&quot;, 1) or 1)&#10;&#10;&#10;                    worst = 0.0&#10;&#10;&#10;                    for om in opp_moves_known:&#10;&#10;&#10;                        d = estimate_damage(state, opp_key, my_key, str(om), mi)&#10;&#10;&#10;                        rr = d.get('rolls', []) or []&#10;&#10;&#10;                        if rr:&#10;&#10;&#10;                            worst = max(worst, sum(rr)/len(rr))&#10;&#10;&#10;                    stay_incoming = worst / my_max&#10;&#10;&#10;            except Exception:&#10;&#10;&#10;                pass&#10;&#10;&#10;&#10;&#10;&#10;            # Bench options&#10;&#10;&#10;            my_species_active = None&#10;&#10;&#10;            try:&#10;&#10;&#10;                if my_key:&#10;&#10;&#10;                    my_species_active = str(getattr(state.team.ours[my_key], &quot;species&quot;, &quot;&quot;) or &quot;&quot;).lower()&#10;&#10;&#10;            except Exception:&#10;&#10;&#10;                pass&#10;&#10;&#10;&#10;&#10;&#10;            for p in legal_switches:&#10;&#10;&#10;                species = str(getattr(p, 'species', '') or '')&#10;                print(f&quot;DEBUG: Evaluating switch to {species}&quot;)&#10;&#10;                if species.lower() == (my_species_active or &quot;&quot;):&#10;&#10;&#10;                    # Never try to switch to the active mon&#10;&#10;&#10;                    print(f&quot;DEBUG: Skipping {species} - already active&quot;)&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                # Find this species' key in our TeamState (best-effort, prefer non-active)&#10;&#10;&#10;                tmp_state = get_state(battle)&#10;&#10;&#10;                cand_key = None&#10;&#10;&#10;                for k, ps in tmp_state.team.ours.items():&#10;&#10;&#10;                    if str(getattr(ps, 'species', '')).lower() == species.lower() and not getattr(ps, &quot;is_active&quot;, False):&#10;&#10;&#10;                        cand_key = k&#10;&#10;&#10;                        break&#10;&#10;&#10;                if cand_key is None:&#10;&#10;&#10;                    # fallback: first matching by species&#10;&#10;&#10;                    for k, ps in tmp_state.team.ours.items():&#10;&#10;&#10;                        if str(getattr(ps, 'species', '')).lower() == species.lower():&#10;&#10;&#10;                            cand_key = k&#10;&#10;&#10;                            break&#10;&#10;&#10;                if cand_key is None:&#10;&#10;&#10;                    # give up gracefully&#10;&#10;&#10;                    print(f&quot;DEBUG: No key found for {species}&quot;)&#10;&#10;&#10;                    switches_eval.append({'species': species, 'score': 0.0, 'hp_fraction': float(getattr(p, 'current_hp_fraction', 1.0) or 1.0), 'note': 'no-key'})&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                print(f&quot;DEBUG: Found key {cand_key} for {species}&quot;)&#10;&#10;&#10;                # Hazard + Sticky Web effects on switch-in (no mutation)&#10;&#10;&#10;                haz = apply_switch_in_effects(tmp_state, cand_key, &quot;ally&quot;, mi, mutate=False)&#10;&#10;&#10;                haz_frac = float(haz.get(&quot;fraction_lost&quot;) or 0.0)&#10;&#10;&#10;                print(f&quot;DEBUG: Hazard damage for {species}: {haz_frac:.3f}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                # Expected incoming this turn if we switch (opponent attacks the switch-in)&#10;&#10;&#10;                cand_ps = tmp_state.team.ours[cand_key]&#10;&#10;&#10;                cand_max = float(cand_ps.max_hp or cand_ps.stats.raw.get(&quot;hp&quot;, 1) or 1)&#10;&#10;&#10;                incoming = 0.0&#10;&#10;&#10;                try:&#10;&#10;&#10;                    worst = 0.0&#10;&#10;&#10;                    test_moves = opp_moves_known or [default_opp_move]&#10;&#10;&#10;                    print(f&quot;DEBUG: Testing incoming damage with moves: {test_moves}&quot;)&#10;&#10;&#10;                    for om in test_moves:&#10;&#10;&#10;                        d = estimate_damage(tmp_state, opp_key, cand_key, str(om), mi)&#10;&#10;&#10;                        rr = d.get('rolls', []) or []&#10;&#10;&#10;                        if rr:&#10;&#10;&#10;                            avg_dmg = sum(rr)/len(rr)&#10;&#10;&#10;                            print(f&quot;DEBUG: Move {om} would deal {avg_dmg:.1f} to {species}&quot;)&#10;&#10;&#10;                            worst = max(worst, avg_dmg)&#10;&#10;&#10;                    incoming = worst / cand_max&#10;&#10;&#10;                    print(f&quot;DEBUG: Worst incoming for {species}: {worst:.1f}/{cand_max:.1f} = {incoming:.3f}&quot;)&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    print(f&quot;DEBUG: Error calculating incoming for {species}: {e}&quot;)&#10;&#10;&#10;                    pass&#10;&#10;&#10;&#10;&#10;&#10;                # Typing bonus: reward resist/immunity to revealed move types&#10;&#10;&#10;                immune = 0&#10;&#10;&#10;                resist = 0&#10;&#10;&#10;                try:&#10;&#10;&#10;                    print(f&quot;DEBUG: Checking type resistances for {species} with types {cand_ps.types}&quot;)&#10;&#10;&#10;                    print(f&quot;DEBUG: Known opponent moves: {opp_moves_known}&quot;)&#10;&#10;&#10;&#10;&#10;                    # Check against known opponent moves&#10;&#10;&#10;                    for om in opp_moves_known:&#10;&#10;&#10;                        # we need the move type; pull from moves DB&#10;&#10;&#10;                        raw = mi.raw(om)&#10;&#10;&#10;                        if raw:&#10;&#10;&#10;                            t = raw.get(&quot;type&quot;)&#10;&#10;&#10;                            mult = _type_mult(t, cand_ps.types, chart)&#10;&#10;&#10;                            print(f&quot;DEBUG: Move {om} ({t}) vs {species} = {mult}x&quot;)&#10;&#10;&#10;                            if mult == 0.0:&#10;&#10;&#10;                                immune += 1&#10;&#10;&#10;                            elif mult &lt;= 0.5:&#10;&#10;&#10;                                resist += 1&#10;&#10;&#10;                        else:&#10;&#10;&#10;                            print(f&quot;DEBUG: No raw data for move {om}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                    # If no known moves, check against common move types for type bonus estimation&#10;&#10;&#10;                    if not opp_moves_known:&#10;&#10;&#10;                        print(f&quot;DEBUG: No known opponent moves, checking against common move types&quot;)&#10;&#10;&#10;                        common_move_types = [&#10;&#10;&#10;                            'normal', 'fire', 'water', 'electric', 'grass', 'ice',&#10;&#10;&#10;                            'fighting', 'poison', 'ground', 'flying', 'psychic',&#10;&#10;&#10;                            'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy'&#10;&#10;&#10;                        ]&#10;&#10;&#10;&#10;&#10;&#10;                        for move_type in common_move_types:&#10;&#10;&#10;                            mult = _type_mult(move_type, cand_ps.types, chart)&#10;&#10;&#10;                            if mult == 0.0:&#10;&#10;&#10;                                immune += 1&#10;&#10;&#10;                            elif mult &lt;= 0.5:&#10;&#10;&#10;                                resist += 1&#10;&#10;&#10;&#10;&#10;                        print(f&quot;DEBUG: Against all types - immune: {immune}, resist: {resist}&quot;)&#10;&#10;&#10;&#10;                        # Scale down since we're checking against all types&#10;&#10;&#10;                        # Give partial credit for type advantages&#10;&#10;&#10;                        type_bonus = (0.5 * immune + 0.3 * resist) * 0.1  # Scale factor for fallback&#10;&#10;&#10;                    else:&#10;&#10;&#10;                        # Use full bonus for known moves&#10;&#10;&#10;                        type_bonus = 0.5 * immune + 0.3 * resist&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    print(f&quot;DEBUG: Error calculating type bonus for {species}: {e}&quot;)&#10;&#10;&#10;                    pass&#10;&#10;&#10;                print(f&quot;DEBUG: Type bonus for {species}: immune={immune}, resist={resist}, bonus={type_bonus:.3f}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                # Outgoing potential next turn from the candidate (if we know its moves)&#10;&#10;&#10;                out_frac = 0.0&#10;&#10;&#10;                try:&#10;&#10;&#10;                    best = 0.0&#10;&#10;&#10;                    opp_ps = tmp_state.team.opponent[opp_key]&#10;&#10;&#10;                    opp_max = float(opp_ps.max_hp or opp_ps.stats.raw.get(&quot;hp&quot;, 1) or 1)&#10;&#10;&#10;                    # First try to get moves from the team state&#10;&#10;&#10;                    cand_moves = cand_ps.moves or []&#10;&#10;&#10;                    print(f&quot;DEBUG: {species} has {len(cand_moves)} moves from team state&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                    # If no moves in team state, try to get them from the original poke-env object&#10;&#10;&#10;                    if not cand_moves:&#10;&#10;&#10;                        print(f&quot;DEBUG: {species} trying to get moves from poke-env battle object&quot;)&#10;&#10;&#10;                        try:&#10;&#10;&#10;                            # Find the corresponding poke-env Pokemon object&#10;&#10;&#10;                            poke_env_pokemon = None&#10;&#10;&#10;                            for switch_option in legal_switches:&#10;&#10;&#10;                                if str(getattr(switch_option, 'species', '')).lower() == species.lower():&#10;&#10;&#10;                                    poke_env_pokemon = switch_option&#10;&#10;&#10;                                    break&#10;&#10;&#10;                            if poke_env_pokemon:&#10;&#10;&#10;                                # Try to get moves from the poke-env object&#10;&#10;&#10;                                penv_moves = getattr(poke_env_pokemon, 'moves', None) or []&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} found {len(penv_moves)} moves in poke-env object&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                                # Convert poke-env moves to our format for damage calculation&#10;&#10;&#10;                                for penv_move in penv_moves:&#10;&#10;&#10;                                    mid = getattr(penv_move, 'id', None) or getattr(penv_move, 'move_id', None)&#10;&#10;&#10;                                    if mid:&#10;&#10;&#10;                                        print(f&quot;DEBUG: {species} found move {mid} from poke-env object&quot;)&#10;&#10;&#10;                                        try:&#10;&#10;&#10;                                            d2 = estimate_damage(tmp_state, cand_key, opp_key, str(mid), mi)&#10;&#10;&#10;                                            print(f&quot;DEBUG: {species} move {mid} damage result: {d2}&quot;)&#10;&#10;&#10;                                            rr2 = d2.get('rolls', []) or []&#10;&#10;&#10;                                            if rr2:&#10;&#10;&#10;                                                avg_out = sum(rr2)/len(rr2)&#10;&#10;&#10;                                                print(f&quot;DEBUG: {species} move {mid} would deal {avg_out:.1f}&quot;)&#10;&#10;&#10;                                                best = max(best, avg_out)&#10;&#10;&#10;                                            else:&#10;&#10;&#10;                                                print(f&quot;DEBUG: {species} move {mid} returned no damage rolls&quot;)&#10;&#10;&#10;                                        except Exception as move_err:&#10;&#10;&#10;                                            print(f&quot;DEBUG: {species} error calculating damage for move {mid}: {move_err}&quot;)&#10;&#10;&#10;                            else:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} no corresponding poke-env object found&quot;)&#10;&#10;&#10;                        except Exception as penv_err:&#10;&#10;&#10;                            print(f&quot;DEBUG: {species} error accessing poke-env moves: {penv_err}&quot;)&#10;&#10;&#10;                    else:&#10;&#10;&#10;                        # Use team state moves (original logic)&#10;&#10;&#10;                        for i, mslot in enumerate(cand_moves):&#10;&#10;&#10;                            print(f&quot;DEBUG: {species} move slot {i}: {mslot}&quot;)&#10;&#10;&#10;                            mid = getattr(mslot, &quot;id&quot;, None)&#10;&#10;&#10;                            if not mid:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} move slot {i} has no id, trying other attributes&quot;)&#10;&#10;&#10;                                # Try alternative attribute names&#10;&#10;&#10;                                for attr in ['move', 'name', 'move_id']:&#10;&#10;&#10;                                    alt_id = getattr(mslot, attr, None)&#10;&#10;&#10;                                    if alt_id:&#10;&#10;&#10;                                        mid = alt_id&#10;&#10;&#10;                                        print(f&quot;DEBUG: {species} found move id '{mid}' via attribute '{attr}'&quot;)&#10;&#10;&#10;                                        break&#10;&#10;&#10;                            if not mid:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} skipping move slot {i} - no valid id found&quot;)&#10;&#10;&#10;                                continue&#10;&#10;&#10;                            print(f&quot;DEBUG: {species} calculating damage for move {mid}&quot;)&#10;&#10;&#10;                            try:&#10;&#10;&#10;                                d2 = estimate_damage(tmp_state, cand_key, opp_key, str(mid), mi)&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} move {mid} damage result: {d2}&quot;)&#10;&#10;&#10;                                rr2 = d2.get('rolls', []) or []&#10;&#10;&#10;                                if rr2:&#10;&#10;&#10;                                    avg_out = sum(rr2)/len(rr2)&#10;&#10;&#10;                                    print(f&quot;DEBUG: {species} move {mid} would deal {avg_out:.1f}&quot;)&#10;&#10;&#10;                                    best = max(best, avg_out)&#10;&#10;&#10;                                else:&#10;&#10;&#10;                                    print(f&quot;DEBUG: {species} move {mid} returned no damage rolls&quot;)&#10;&#10;&#10;                            except Exception as move_err:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} error calculating damage for move {mid}: {move_err}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                    # If still no moves found, try some fallback strategies&#10;&#10;&#10;                    if best == 0.0:&#10;&#10;&#10;                        print(f&quot;DEBUG: {species} no moves found via normal methods, trying fallbacks&quot;)&#10;&#10;&#10;                        # Try using a generic move based on the Pokemon's typing or common moves&#10;&#10;&#10;                        fallback_moves = []&#10;&#10;&#10;&#10;&#10;&#10;                        # Add type-based STAB moves&#10;&#10;&#10;                        pokemon_types = cand_ps.types or ()&#10;&#10;&#10;                        if 'fire' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['flamethrower', 'fireblast', 'overheat'])&#10;&#10;&#10;                        if 'water' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['surf', 'hydropump', 'watergun'])&#10;&#10;&#10;                        if 'electric' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['thunderbolt', 'thunder', 'discharge'])&#10;&#10;&#10;                        if 'grass' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['energyball', 'gigadrain', 'leafstorm'])&#10;&#10;&#10;                        if 'psychic' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['psychic', 'psyshock', 'futuresight'])&#10;&#10;&#10;                        if 'fighting' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['closecombat', 'superpower', 'focusblast'])&#10;&#10;&#10;                        if 'dragon' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['dragonpulse', 'dracometeor', 'outrage'])&#10;&#10;&#10;&#10;&#10;&#10;                        # Add common physical/special moves&#10;&#10;&#10;                        fallback_moves.extend(['return', 'bodyslam', 'doubleedge', 'facade'])&#10;&#10;&#10;&#10;&#10;&#10;                        for fallback_move in fallback_moves[:3]:  # Try top 3 fallbacks&#10;&#10;&#10;                            try:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} trying fallback move {fallback_move}&quot;)&#10;&#10;&#10;                                d2 = estimate_damage(tmp_state, cand_key, opp_key, fallback_move, mi)&#10;&#10;&#10;                                rr2 = d2.get('rolls', []) or []&#10;&#10;&#10;                                if rr2:&#10;&#10;&#10;                                    avg_out = sum(rr2)/len(rr2)&#10;&#10;&#10;                                    print(f&quot;DEBUG: {species} fallback move {fallback_move} would deal {avg_out:.1f}&quot;)&#10;&#10;&#10;                                    best = max(best, avg_out)&#10;&#10;&#10;                                    break  # Use first working fallback&#10;&#10;&#10;                            except Exception:&#10;&#10;&#10;                                continue&#10;&#10;&#10;&#10;&#10;&#10;                    if best &gt; 0:&#10;&#10;&#10;                        out_frac = best / opp_max&#10;&#10;&#10;                        print(f&quot;DEBUG: Best outgoing for {species}: {best:.1f}/{opp_max:.1f} = {out_frac:.3f}&quot;)&#10;&#10;&#10;                    else:&#10;&#10;&#10;                        print(f&quot;DEBUG: No outgoing damage calculated for {species} - best damage was {best}&quot;)&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    print(f&quot;DEBUG: Error calculating outgoing for {species}: {e}&quot;)&#10;&#10;&#10;                    import traceback&#10;&#10;&#10;                    print(f&quot;DEBUG: Full traceback: {traceback.format_exc()}&quot;)&#10;&#10;&#10;                    pass&#10;&#10;&#10;&#10;&#10;&#10;                hp_frac = float(getattr(p, 'current_hp_fraction', 1.0) or 1.0)&#10;&#10;&#10;                print(f&quot;DEBUG: {species} HP fraction: {hp_frac:.3f}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                # Risk-aware switch score: prefer lower incoming + hazards, higher future output, and better typing&#10;&#10;&#10;                base_score = (out_frac * 1.2) - (incoming * 1.1) - (haz_frac * 0.5)&#10;&#10;&#10;                score = max(0.0, base_score) + type_bonus&#10;&#10;&#10;                print(f&quot;DEBUG: {species} score calculation:&quot;)&#10;&#10;&#10;                print(f&quot;  Base: ({out_frac:.3f} * 1.2) - ({incoming:.3f} * 1.1) - ({haz_frac:.3f} * 0.5) = {base_score:.3f}&quot;)&#10;&#10;&#10;                print(f&quot;  Final: max(0.0, {base_score:.3f}) + {type_bonus:.3f} = {score:.3f}&quot;)&#10;&#10;&#10;                switches_eval.append({&#10;&#10;&#10;                    'species': species,&#10;&#10;&#10;                    'score': float(score),&#10;&#10;&#10;                    'hp_fraction': hp_frac,&#10;&#10;&#10;                    'incoming_on_switch': float(incoming),&#10;&#10;&#10;                    'hazards_frac': float(haz_frac),&#10;&#10;&#10;                    'type_bonus': float(type_bonus),&#10;&#10;&#10;                    'stay_incoming': float(stay_incoming),&#10;&#10;&#10;                    'outgoing_frac': float(out_frac),  # Add this for debugging&#10;&#10;&#10;                    'base_score': float(base_score),    # Add this for debugging&#10;&#10;&#10;                })&#10;&#10;&#10;&#10;&#10;&#10;            switches_eval.sort(key=lambda x: x.get('score', 0.0), reverse=True)&#10;&#10;&#10;&#10;&#10;&#10;        # ---- Decide -----------------------------------------------------------&#10;&#10;&#10;        snap = snapshot_battle(battle)&#10;&#10;&#10;        best_move = moves_eval[0] if moves_eval else None&#10;&#10;&#10;        best_switch = switches_eval[0] if switches_eval else None&#10;&#10;&#10;&#10;&#10;&#10;        # If we are forced to switch, do it&#10;&#10;&#10;        if force_switch and best_switch:&#10;&#10;&#10;            return ChosenAction(kind='switch', switch_species=best_switch['species'],&#10;&#10;&#10;                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,&#10;&#10;&#10;                                       'picked': {'kind': 'switch', **best_switch}})&#10;&#10;&#10;&#10;&#10;&#10;        # Otherwise compare EVs&#10;&#10;&#10;        if best_move and (not best_switch or best_move['score'] &gt;= best_switch['score']):&#10;&#10;&#10;            return ChosenAction(kind='move', move_id=str(best_move['id']),&#10;&#10;&#10;                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,&#10;&#10;&#10;                                       'picked': {'kind': 'move', **best_move}})&#10;&#10;&#10;        if best_switch:&#10;&#10;&#10;            return ChosenAction(kind='switch', switch_species=best_switch['species'],&#10;&#10;&#10;                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,&#10;&#10;&#10;                                       'picked': {'kind': 'switch', **best_switch}})&#10;&#10;&#10;&#10;&#10;&#10;        # Fallbacks&#10;&#10;&#10;        if legal_moves:&#10;&#10;&#10;            return ChosenAction(kind='move', move_id=str(getattr(legal_moves[0], 'id', '')),&#10;&#10;&#10;                                debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;        if legal_switches:&#10;&#10;&#10;            # never pick active species&#10;&#10;&#10;            for p in legal_switches:&#10;&#10;&#10;                sp = str(getattr(p, 'species', '') or '')&#10;&#10;&#10;                if my_key:&#10;&#10;&#10;                    cursp = str(getattr(state.team.ours[my_key], 'species', '') or '')&#10;&#10;&#10;                else:&#10;&#10;&#10;                    cursp = ''&#10;&#10;&#10;                if sp.lower() != cursp.lower():&#10;&#10;&#10;                    return ChosenAction(kind='switch', switch_species=sp, debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;            # if all else fails, pick first bench&#10;&#10;&#10;            return ChosenAction(kind='switch', switch_species=str(getattr(legal_switches[0], 'species', '')),&#10;&#10;&#10;                                debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;        return ChosenAction(kind='move', move_id='struggle', debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;&#10;&#10;&#10;# -------------- Poke-env Player wrapper -----------------------------------&#10;&#10;&#10;try:&#10;&#10;&#10;    from poke_env.player.player import Player  # type: ignore&#10;&#10;&#10;except Exception:&#10;&#10;&#10;    Player = object  # fallback for type checking&#10;&#10;&#10;&#10;&#10;&#10;class StockfishPokeEnvPlayer(Player):  # type: ignore[misc]&#10;&#10;&#10;    def __init__(self, *args, **kwargs):&#10;&#10;&#10;        # Hook for UI&#10;&#10;&#10;        self.on_think_hook = kwargs.pop('on_think', None)&#10;&#10;&#10;        engine_depth = kwargs.pop('engine_depth', None)&#10;&#10;&#10;        self.engine = kwargs.pop('engine', None) or StockfishModel(kwargs.get('battle_format', 'gen9ou'))&#10;&#10;&#10;        try:&#10;&#10;&#10;            self.engine.set_depth(int(engine_depth))&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;        super().__init__(*args, **kwargs)&#10;&#10;&#10;        # Convenience alias for older UI code&#10;&#10;&#10;        try:&#10;&#10;&#10;            self._psclient = self.ps_client&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;    # --------------- Buttons ---------------&#10;&#10;&#10;    async def forfeit_all(self):&#10;&#10;&#10;        # Forfeit all ongoing battles using the official client API.&#10;&#10;&#10;        try:&#10;&#10;&#10;            battles = dict(getattr(self, 'battles', {}) or {})&#10;&#10;&#10;            client = getattr(self, 'ps_client', None)&#10;&#10;&#10;            if not client:&#10;&#10;&#10;                return&#10;&#10;&#10;            for _id, b in battles.items():&#10;&#10;&#10;                try:&#10;&#10;&#10;                    tag = getattr(b, 'battle_tag', getattr(b, 'room_id', None)) or _id&#10;&#10;&#10;                    await client.send_message('/forfeit', room=str(tag))&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    continue&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;    async def timer_all(self, on: bool):&#10;&#10;&#10;        try:&#10;&#10;&#10;            battles = dict(getattr(self, 'battles', {}) or {})&#10;&#10;&#10;            client = getattr(self, 'ps_client', None)&#10;&#10;&#10;            if not client:&#10;&#10;&#10;                return&#10;&#10;&#10;            msg = '/timer on' if on else '/timer off'&#10;&#10;&#10;            for _id, b in battles.items():&#10;&#10;&#10;                try:&#10;&#10;&#10;                    tag = getattr(b, 'battle_tag', getattr(b, 'room_id', None)) or _id&#10;&#10;&#10;                    await client.send_message(msg, room=str(tag))&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    continue&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;    # --------------- Core decision ---------------&#10;&#10;&#10;    def choose_move(self, battle):&#10;&#10;&#10;        decision = self.engine.choose_action(battle)&#10;&#10;&#10;        try:&#10;&#10;&#10;            if self.on_think_hook and isinstance(decision.debug, dict):&#10;&#10;&#10;                # provide the snapshot and current battle object&#10;&#10;&#10;                dd = dict(decision.debug)&#10;&#10;&#10;                dd.setdefault('snapshot', snapshot_battle(battle))&#10;&#10;&#10;                try:&#10;&#10;&#10;                    import json, logging&#10;&#10;&#10;                    logging.getLogger('Think').info(&#10;&#10;&#10;                        'UI_THINK turn=%s payload=%s',&#10;&#10;&#10;                        getattr(battle, 'turn', None),&#10;&#10;&#10;                        json.dumps(dd, default=str)&#10;&#10;&#10;                    )&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    pass&#10;&#10;&#10;                self.on_think_hook(battle, dd)&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;        # Convert ChosenAction to poke-env order&#10;&#10;&#10;        try:&#10;&#10;&#10;            if decision.kind == 'move' and decision.move_id:&#10;&#10;&#10;                for m in (getattr(battle, 'available_moves', []) or []):&#10;&#10;&#10;                    if str(getattr(m, 'id', '')) == str(decision.move_id):&#10;&#10;&#10;                        return self.create_order(m)&#10;&#10;&#10;                # fallback: first legal move&#10;&#10;&#10;                return self.create_order((getattr(battle, 'available_moves', []) or [None])[0]) or self.choose_random_move(battle)&#10;&#10;&#10;            elif decision.kind == 'switch' and decision.switch_species:&#10;&#10;&#10;                # never select active mon&#10;&#10;&#10;                try:&#10;&#10;&#10;                    cur = getattr(battle, &quot;active_pokemon&quot;, None)&#10;&#10;&#10;                    cursp = (getattr(cur, &quot;species&quot;, None) or &quot;&quot;).lower()&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    cursp = &quot;&quot;&#10;&#10;&#10;                for p in (getattr(battle, 'available_switches', []) or []):&#10;&#10;&#10;                    sp = (str(getattr(p, 'species', '')).lower())&#10;&#10;&#10;                    if sp == cursp:&#10;&#10;&#10;                        continue&#10;&#10;&#10;                    if sp == str(decision.switch_species).lower():&#10;&#10;&#10;                        return self.create_order(p)&#10;&#10;&#10;                # if not found by species, pick first bench (guard)&#10;&#10;&#10;                for p in (getattr(battle, 'available_switches', []) or []):&#10;&#10;&#10;                    if (str(getattr(p, 'species', '')).lower()) != cursp:&#10;&#10;&#10;                        return self.create_order(p)&#10;&#10;&#10;                return self.choose_random_move(battle)&#10;&#10;&#10;            return self.choose_random_move(battle)&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            return self.choose_random_move(battle)&#10;" />
              <option name="updatedContent" value="from __future__ import annotations&#10;import json&#10;import os&#10;&#10;&#10;&#10;&#10;&#10;from dataclasses import dataclass&#10;&#10;&#10;from typing import Any, Dict, List, Optional, Callable&#10;&#10;&#10;&#10;&#10;&#10;# Import mechanics from the Data package&#10;&#10;&#10;from Data.battle_runtime import (&#10;&#10;&#10;    get_state,&#10;&#10;&#10;    predict_order_for_ids,&#10;&#10;&#10;    estimate_damage,&#10;&#10;&#10;    would_fail,&#10;&#10;&#10;    apply_switch_in_effects,&#10;&#10;&#10;)&#10;&#10;&#10;from Data.poke_env_battle_environment import snapshot as snapshot_battle&#10;&#10;&#10;from Data.poke_env_moves_info import MovesInfo&#10;&#10;# --- learned weights (optional) --------------------------------------------&#10;def _load_weights(path: str = os.path.join(&quot;Models&quot;, &quot;weights.json&quot;)) -&gt; dict:&#10;    try:&#10;        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            w = json.load(f)&#10;        # safe defaults&#10;        return {&#10;            &quot;go_first_bonus&quot;: float(w.get(&quot;go_first_bonus&quot;, 0.4)),&#10;            &quot;opp_dmg_penalty&quot;: float(w.get(&quot;opp_dmg_penalty&quot;, 1.0)),&#10;            &quot;survival_bonus&quot;: float(w.get(&quot;survival_bonus&quot;, 0.0)),&#10;        }&#10;    except Exception:&#10;        return {&quot;go_first_bonus&quot;: 0.4, &quot;opp_dmg_penalty&quot;: 1.0, &quot;survival_bonus&quot;: 0.0}&#10;&#10;&#10;&#10;&#10;&#10;&#10;# ---------------- helpers (local only) -----------------&#10;&#10;&#10;def _acc_to_prob(acc) -&gt; float:&#10;&#10;&#10;    # poke-env accuracy can be True (100), int 0..100, float 0..1&#10;&#10;&#10;    if acc is True:&#10;&#10;&#10;        return 1.0&#10;&#10;&#10;    if acc is None:&#10;&#10;&#10;        return 1.0&#10;&#10;&#10;    try:&#10;&#10;&#10;        x = float(acc)&#10;&#10;&#10;        return x / 100.0 if x &gt; 1.0 else max(0.0, min(1.0, x))&#10;&#10;&#10;    except Exception:&#10;&#10;&#10;        return 1.0&#10;&#10;&#10;&#10;&#10;&#10;def _type_mult(att_type: str, defender_types, chart: Dict[str, Dict[str, float]]) -&gt; float:&#10;    &quot;&quot;&quot;Calculate type effectiveness multiplier correctly handling case sensitivity.&quot;&quot;&quot;&#10;    if not chart or not att_type or not defender_types:&#10;        return 1.0&#10;&#10;    # Normalize type names to match chart keys (usually UPPERCASE)&#10;    chart_keys = set(chart.keys())&#10;    att_type_norm = None&#10;&#10;    # Find the correct case for the attack type in the chart&#10;    for key in chart_keys:&#10;        if key.upper() == att_type.upper():&#10;            att_type_norm = key&#10;            break&#10;&#10;    if not att_type_norm:&#10;        return 1.0&#10;&#10;    mult = 1.0&#10;    for def_type in defender_types:&#10;        if not def_type:&#10;            continue&#10;&#10;        # Find the correct case for the defense type&#10;        def_type_norm = None&#10;        for target_key in chart[att_type_norm]:&#10;            if target_key.upper() == def_type.upper():&#10;                def_type_norm = target_key&#10;                break&#10;&#10;        if def_type_norm:&#10;            effectiveness = chart[att_type_norm][def_type_norm]&#10;            mult *= effectiveness&#10;&#10;    return mult&#10;&#10;&#10;&#10;&#10;&#10;# ---------------- Public data container -----------------&#10;&#10;&#10;@dataclass&#10;&#10;&#10;class ChosenAction:&#10;&#10;&#10;    kind: str  # 'move' | 'switch'&#10;&#10;&#10;    move_id: Optional[str] = None&#10;&#10;&#10;    switch_species: Optional[str] = None&#10;&#10;&#10;    debug: Dict[str, Any] | None = None&#10;&#10;&#10;&#10;&#10;&#10;# ----------------- Core engine --------------------------&#10;&#10;&#10;class StockfishModel:&#10;&#10;&#10;    def __init__(self, battle_format: str = 'gen9ou'):&#10;&#10;&#10;        self.battle_format = battle_format&#10;&#10;&#10;        self._W = _load_weights()&#10;        # configurable 'depth' knob the UI may tweak; we don't tree-search but keep it as a param&#10;&#10;&#10;        self._depth = 3&#10;&#10;&#10;&#10;&#10;&#10;    def set_depth(self, d: int):&#10;&#10;&#10;        self._depth = int(d)&#10;&#10;&#10;&#10;&#10;&#10;    def choose_action(self, battle: Any) -&gt; ChosenAction:&#10;&#10;&#10;        &quot;&quot;&quot;Return ChosenAction and rich debug info for the UI.&quot;&quot;&quot;&#10;&#10;&#10;        state = get_state(battle)&#10;&#10;&#10;        mi = MovesInfo(state.format or 9)&#10;        type_chart = mi.get_type_chart()&#10;        print(f&quot;DEBUG: MovesInfo format: {state.format or 9}&quot;)&#10;        print(f&quot;DEBUG: Type chart size: {len(type_chart) if type_chart else 0}&quot;)&#10;        if type_chart:&#10;            print(f&quot;DEBUG: Sample types: {list(type_chart.keys())[:5]}&quot;)&#10;        print(f&quot;DEBUG: MovesInfo initialized with format: {state.format or 9}&quot;)&#10;        print(f&quot;DEBUG: Type chart loaded: {bool(mi.get_type_chart())}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;        # Determine active slots for both sides&#10;&#10;&#10;        def _active_key(side: Dict[str, Any]) -&gt; Optional[str]:&#10;&#10;&#10;            for k, p in side.items():&#10;&#10;&#10;                if getattr(p, 'is_active', False):&#10;&#10;&#10;                    return k&#10;&#10;&#10;            for k, p in side.items():&#10;&#10;&#10;                if (getattr(p, 'status', None) or '').lower() == 'fnt':&#10;&#10;&#10;                    continue&#10;&#10;&#10;                chp = getattr(p, 'current_hp', None)&#10;&#10;&#10;                if chp is None:&#10;&#10;&#10;                    return k&#10;&#10;&#10;                if chp &gt; 0:&#10;&#10;&#10;                    return k&#10;&#10;&#10;            return None&#10;&#10;&#10;&#10;&#10;&#10;        my_key = _active_key(state.team.ours) if getattr(state, 'team', None) else None&#10;&#10;&#10;        opp_key = _active_key(state.team.opponent) if getattr(state, 'team', None) else None&#10;&#10;&#10;&#10;&#10;&#10;        legal_moves = list(getattr(battle, 'available_moves', []) or [])&#10;&#10;&#10;        legal_switches = list(getattr(battle, 'available_switches', []) or [])&#10;&#10;&#10;        force_switch = bool(getattr(battle, 'force_switch', False)) or (not legal_moves and bool(legal_switches))&#10;&#10;&#10;&#10;&#10;&#10;        # Reveal opponent move ids if we know them; give a safe default&#10;&#10;&#10;        opp_moves_known = []&#10;&#10;&#10;        try:&#10;&#10;&#10;            if opp_key:&#10;&#10;&#10;                opp_ps = state.team.opponent[opp_key]&#10;&#10;&#10;                opp_moves_known = [m.id for m in (opp_ps.moves or []) if getattr(m, &quot;id&quot;, None)]&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;        default_opp_move = opp_moves_known[0] if opp_moves_known else &quot;tackle&quot;&#10;&#10;&#10;&#10;&#10;&#10;        # ---- Evaluate MOVES ---------------------------------------------------&#10;&#10;&#10;        moves_eval: List[Dict[str, Any]] = []&#10;&#10;&#10;        if not force_switch and my_key and opp_key:&#10;&#10;&#10;            opp_ps = state.team.opponent[opp_key]&#10;&#10;&#10;            opp_max = int(getattr(opp_ps, 'max_hp', 0) or opp_ps.stats.raw.get('hp', 1) or 1)&#10;&#10;&#10;            for mv in legal_moves:&#10;&#10;&#10;                mid = getattr(mv, 'id', None) or getattr(mv, 'move_id', None)&#10;&#10;&#10;                name = getattr(mv, 'name', str(mid))&#10;&#10;&#10;                if not mid:&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                # Filter out immediate failure (eg. sleep talk while awake)&#10;&#10;&#10;                fail, why = False, None&#10;&#10;&#10;                try:&#10;&#10;&#10;                    fail, why = would_fail(str(mid), my_key, opp_key, state, mi)&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    pass&#10;&#10;&#10;                if fail:&#10;&#10;&#10;                    moves_eval.append({&#10;&#10;&#10;                        'id': str(mid), 'name': name, 'score': 0.0, 'expected': 0.0,&#10;&#10;&#10;                        'acc_mult': 0.0, 'effectiveness': 0.0, 'why_blocked': str(why or 'would fail')&#10;&#10;&#10;                    })&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                try:&#10;&#10;&#10;                    dmg = estimate_damage(state, my_key, opp_key, str(mid), mi)&#10;&#10;&#10;                    rolls = list(dmg.get('rolls', []) or [])&#10;&#10;&#10;                    avg = sum(rolls) / len(rolls) if rolls else 0.0&#10;&#10;&#10;                    eff = float(dmg.get('effectiveness', 1.0) or 1.0)&#10;                    # Use recalculated effectiveness from _type_mult if available&#10;                    move_raw = mi.raw(str(mid))&#10;                    if move_raw:&#10;                        move_type = move_raw.get(&quot;type&quot;, &quot;&quot;)&#10;                        def_types = getattr(state.team.opponent[opp_key], &quot;types&quot;, [])&#10;                        if move_type and def_types and type_chart:&#10;                            eff = _type_mult(move_type, def_types, type_chart)&#10;&#10;                    # Debug type effectiveness&#10;                    move_raw = mi.raw(str(mid))&#10;                    if move_raw:&#10;                        move_type = move_raw.get(&quot;type&quot;, &quot;unknown&quot;)&#10;                        def_types = getattr(state.team.opponent[opp_key], &quot;types&quot;, [])&#10;                        print(f&quot;DEBUG: Move {mid} ({move_type}) vs {def_types} = {eff}x effectiveness&quot;)&#10;&#10;                        # Recalculate effectiveness if we have type info&#10;                        if move_type != &quot;unknown&quot; and def_types and type_chart:&#10;                            recalc_eff = _type_mult(move_type, def_types, type_chart)&#10;                            if abs(recalc_eff - eff) &gt; 0.01:&#10;                                                                eff = recalc_eff&#10;                    print(f&quot;DEBUG: Move {mid} effectiveness: {eff}, damage rolls: {rolls}&quot;)&#10;                    # Show move type information&#10;                    move_raw = mi.raw(str(mid))&#10;                    move_type = move_raw.get(&quot;type&quot;, &quot;unknown&quot;) if move_raw else &quot;unknown&quot;&#10;                    print(f&quot;DEBUG: Move {mid} type: {move_type}&quot;)&#10;                    # Show defender types&#10;                    opp_types = getattr(state.team.opponent[opp_key], &quot;types&quot;, [])&#10;                    print(f&quot;DEBUG: Defender {opp_key} types: {opp_types}&quot;)&#10;&#10;                    acc_p = _acc_to_prob(getattr(mv, 'accuracy', 1.0))&#10;&#10;&#10;                    # chance to move first (priority/speed); use default opp move if unknown&#10;&#10;&#10;                    first_prob, _ = predict_order_for_ids(state, my_key, str(mid), opp_key, default_opp_move, mi)&#10;&#10;&#10;                    expected = (avg / float(opp_max)) * acc_p&#10;&#10;&#10;                    # mild emphasis on moving first, but don't double-count type (already in rolls)&#10;&#10;&#10;                    score = expected * (0.6 + 0.4 * float(first_prob))&#10;&#10;&#10;                    moves_eval.append({&#10;&#10;&#10;                        'id': str(mid), 'name': name,&#10;&#10;&#10;                        'score': float(score),&#10;&#10;&#10;                        'expected': float(expected),&#10;&#10;&#10;                        'acc_mult': float(acc_p),&#10;&#10;&#10;                        'effectiveness': float(eff),&#10;&#10;&#10;                    })&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    moves_eval.append({'id': str(mid), 'name': name, 'score': 0.0, 'expected': 0.0, 'note': f'err: {e}'})&#10;&#10;&#10;            moves_eval.sort(key=lambda x: x.get('score', 0.0), reverse=True)&#10;&#10;&#10;&#10;&#10;&#10;        # ---- Evaluate SWITCHES -----------------------------------------------&#10;&#10;&#10;        switches_eval: List[Dict[str, Any]] = []&#10;&#10;&#10;        if legal_switches and opp_key:&#10;&#10;&#10;            chart = mi.get_type_chart()&#10;&#10;&#10;            # Current active (for risk comparison if we stay)&#10;&#10;&#10;            stay_incoming = 0.0&#10;&#10;&#10;            try:&#10;&#10;&#10;                # worst revealed incoming against current active&#10;&#10;&#10;                if my_key and opp_moves_known:&#10;&#10;&#10;                    my_ps = state.team.ours[my_key]&#10;&#10;&#10;                    my_max = float(my_ps.max_hp or my_ps.stats.raw.get(&quot;hp&quot;, 1) or 1)&#10;&#10;&#10;                    worst = 0.0&#10;&#10;&#10;                    for om in opp_moves_known:&#10;&#10;&#10;                        d = estimate_damage(state, opp_key, my_key, str(om), mi)&#10;&#10;&#10;                        rr = d.get('rolls', []) or []&#10;&#10;&#10;                        if rr:&#10;&#10;&#10;                            worst = max(worst, sum(rr)/len(rr))&#10;&#10;&#10;                    stay_incoming = worst / my_max&#10;&#10;&#10;            except Exception:&#10;&#10;&#10;                pass&#10;&#10;&#10;&#10;&#10;&#10;            # Bench options&#10;&#10;&#10;            my_species_active = None&#10;&#10;&#10;            try:&#10;&#10;&#10;                if my_key:&#10;&#10;&#10;                    my_species_active = str(getattr(state.team.ours[my_key], &quot;species&quot;, &quot;&quot;) or &quot;&quot;).lower()&#10;&#10;&#10;            except Exception:&#10;&#10;&#10;                pass&#10;&#10;&#10;&#10;&#10;&#10;            for p in legal_switches:&#10;&#10;&#10;                species = str(getattr(p, 'species', '') or '')&#10;                print(f&quot;DEBUG: Evaluating switch to {species}&quot;)&#10;&#10;                if species.lower() == (my_species_active or &quot;&quot;):&#10;&#10;&#10;                    # Never try to switch to the active mon&#10;&#10;&#10;                    print(f&quot;DEBUG: Skipping {species} - already active&quot;)&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                # Find this species' key in our TeamState (best-effort, prefer non-active)&#10;&#10;&#10;                tmp_state = get_state(battle)&#10;&#10;&#10;                cand_key = None&#10;&#10;&#10;                for k, ps in tmp_state.team.ours.items():&#10;&#10;&#10;                    if str(getattr(ps, 'species', '')).lower() == species.lower() and not getattr(ps, &quot;is_active&quot;, False):&#10;&#10;&#10;                        cand_key = k&#10;&#10;&#10;                        break&#10;&#10;&#10;                if cand_key is None:&#10;&#10;&#10;                    # fallback: first matching by species&#10;&#10;&#10;                    for k, ps in tmp_state.team.ours.items():&#10;&#10;&#10;                        if str(getattr(ps, 'species', '')).lower() == species.lower():&#10;&#10;&#10;                            cand_key = k&#10;&#10;&#10;                            break&#10;&#10;&#10;                if cand_key is None:&#10;&#10;&#10;                    # give up gracefully&#10;&#10;&#10;                    print(f&quot;DEBUG: No key found for {species}&quot;)&#10;&#10;&#10;                    switches_eval.append({'species': species, 'score': 0.0, 'hp_fraction': float(getattr(p, 'current_hp_fraction', 1.0) or 1.0), 'note': 'no-key'})&#10;&#10;&#10;                    continue&#10;&#10;&#10;&#10;&#10;&#10;                print(f&quot;DEBUG: Found key {cand_key} for {species}&quot;)&#10;&#10;&#10;                # Hazard + Sticky Web effects on switch-in (no mutation)&#10;&#10;&#10;                haz = apply_switch_in_effects(tmp_state, cand_key, &quot;ally&quot;, mi, mutate=False)&#10;&#10;&#10;                haz_frac = float(haz.get(&quot;fraction_lost&quot;) or 0.0)&#10;&#10;&#10;                print(f&quot;DEBUG: Hazard damage for {species}: {haz_frac:.3f}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                # Expected incoming this turn if we switch (opponent attacks the switch-in)&#10;&#10;&#10;                cand_ps = tmp_state.team.ours[cand_key]&#10;&#10;&#10;                cand_max = float(cand_ps.max_hp or cand_ps.stats.raw.get(&quot;hp&quot;, 1) or 1)&#10;&#10;&#10;                incoming = 0.0&#10;&#10;&#10;                try:&#10;&#10;&#10;                    worst = 0.0&#10;&#10;&#10;                    test_moves = opp_moves_known or [default_opp_move]&#10;&#10;&#10;                    print(f&quot;DEBUG: Testing incoming damage with moves: {test_moves}&quot;)&#10;&#10;&#10;                    for om in test_moves:&#10;&#10;&#10;                        d = estimate_damage(tmp_state, opp_key, cand_key, str(om), mi)&#10;&#10;&#10;                        rr = d.get('rolls', []) or []&#10;&#10;&#10;                        if rr:&#10;&#10;&#10;                            avg_dmg = sum(rr)/len(rr)&#10;&#10;&#10;                            print(f&quot;DEBUG: Move {om} would deal {avg_dmg:.1f} to {species}&quot;)&#10;&#10;&#10;                            worst = max(worst, avg_dmg)&#10;&#10;&#10;                    incoming = worst / cand_max&#10;&#10;&#10;                    print(f&quot;DEBUG: Worst incoming for {species}: {worst:.1f}/{cand_max:.1f} = {incoming:.3f}&quot;)&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    print(f&quot;DEBUG: Error calculating incoming for {species}: {e}&quot;)&#10;&#10;&#10;                    pass&#10;&#10;&#10;&#10;&#10;&#10;                # Typing bonus: reward resist/immunity to revealed move types&#10;&#10;&#10;                immune = 0&#10;&#10;&#10;                resist = 0&#10;&#10;&#10;                try:&#10;&#10;&#10;                    print(f&quot;DEBUG: Checking type resistances for {species} with types {cand_ps.types}&quot;)&#10;&#10;&#10;                    print(f&quot;DEBUG: Known opponent moves: {opp_moves_known}&quot;)&#10;&#10;&#10;&#10;&#10;                    # Check against known opponent moves&#10;&#10;&#10;                    for om in opp_moves_known:&#10;&#10;&#10;                        # we need the move type; pull from moves DB&#10;&#10;&#10;                        raw = mi.raw(om)&#10;&#10;&#10;                        if raw:&#10;&#10;&#10;                            t = raw.get(&quot;type&quot;)&#10;&#10;&#10;                            mult = _type_mult(t, cand_ps.types, chart)&#10;&#10;&#10;                            print(f&quot;DEBUG: Move {om} ({t}) vs {species} = {mult}x&quot;)&#10;&#10;&#10;                            if mult == 0.0:&#10;&#10;&#10;                                immune += 1&#10;&#10;&#10;                            elif mult &lt;= 0.5:&#10;&#10;&#10;                                resist += 1&#10;&#10;&#10;                        else:&#10;&#10;&#10;                            print(f&quot;DEBUG: No raw data for move {om}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                    # If no known moves, check against common move types for type bonus estimation&#10;&#10;&#10;                    if not opp_moves_known:&#10;&#10;&#10;                        print(f&quot;DEBUG: No known opponent moves, checking against common move types&quot;)&#10;&#10;&#10;                        common_move_types = [&#10;&#10;&#10;                            'normal', 'fire', 'water', 'electric', 'grass', 'ice',&#10;&#10;&#10;                            'fighting', 'poison', 'ground', 'flying', 'psychic',&#10;&#10;&#10;                            'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy'&#10;&#10;&#10;                        ]&#10;&#10;&#10;&#10;&#10;&#10;                        for move_type in common_move_types:&#10;&#10;&#10;                            mult = _type_mult(move_type, cand_ps.types, chart)&#10;&#10;&#10;                            if mult == 0.0:&#10;&#10;&#10;                                immune += 1&#10;&#10;&#10;                            elif mult &lt;= 0.5:&#10;&#10;&#10;                                resist += 1&#10;&#10;&#10;&#10;&#10;                        print(f&quot;DEBUG: Against all types - immune: {immune}, resist: {resist}&quot;)&#10;&#10;&#10;&#10;                        # Scale down since we're checking against all types&#10;&#10;&#10;                        # Give partial credit for type advantages&#10;&#10;&#10;                        type_bonus = (0.5 * immune + 0.3 * resist) * 0.1  # Scale factor for fallback&#10;&#10;&#10;                    else:&#10;&#10;&#10;                        # Use full bonus for known moves&#10;&#10;&#10;                        type_bonus = 0.5 * immune + 0.3 * resist&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    print(f&quot;DEBUG: Error calculating type bonus for {species}: {e}&quot;)&#10;&#10;&#10;                    pass&#10;&#10;&#10;                print(f&quot;DEBUG: Type bonus for {species}: immune={immune}, resist={resist}, bonus={type_bonus:.3f}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                # Outgoing potential next turn from the candidate (if we know its moves)&#10;&#10;&#10;                out_frac = 0.0&#10;&#10;&#10;                try:&#10;&#10;&#10;                    best = 0.0&#10;&#10;&#10;                    opp_ps = tmp_state.team.opponent[opp_key]&#10;&#10;&#10;                    opp_max = float(opp_ps.max_hp or opp_ps.stats.raw.get(&quot;hp&quot;, 1) or 1)&#10;&#10;&#10;                    # First try to get moves from the team state&#10;&#10;&#10;                    cand_moves = cand_ps.moves or []&#10;&#10;&#10;                    print(f&quot;DEBUG: {species} has {len(cand_moves)} moves from team state&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                    # If no moves in team state, try to get them from the original poke-env object&#10;&#10;&#10;                    if not cand_moves:&#10;&#10;&#10;                        print(f&quot;DEBUG: {species} trying to get moves from poke-env battle object&quot;)&#10;&#10;&#10;                        try:&#10;&#10;&#10;                            # Find the corresponding poke-env Pokemon object&#10;&#10;&#10;                            poke_env_pokemon = None&#10;&#10;&#10;                            for switch_option in legal_switches:&#10;&#10;&#10;                                if str(getattr(switch_option, 'species', '')).lower() == species.lower():&#10;&#10;&#10;                                    poke_env_pokemon = switch_option&#10;&#10;&#10;                                    break&#10;&#10;&#10;                            if poke_env_pokemon:&#10;&#10;&#10;                                # Try to get moves from the poke-env object&#10;&#10;&#10;                                penv_moves = getattr(poke_env_pokemon, 'moves', None) or []&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} found {len(penv_moves)} moves in poke-env object&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                                # Convert poke-env moves to our format for damage calculation&#10;&#10;&#10;                                for penv_move in penv_moves:&#10;&#10;&#10;                                    mid = getattr(penv_move, 'id', None) or getattr(penv_move, 'move_id', None)&#10;&#10;&#10;                                    if mid:&#10;&#10;&#10;                                        print(f&quot;DEBUG: {species} found move {mid} from poke-env object&quot;)&#10;&#10;&#10;                                        try:&#10;&#10;&#10;                                            d2 = estimate_damage(tmp_state, cand_key, opp_key, str(mid), mi)&#10;&#10;&#10;                                            print(f&quot;DEBUG: {species} move {mid} damage result: {d2}&quot;)&#10;&#10;&#10;                                            rr2 = d2.get('rolls', []) or []&#10;&#10;&#10;                                            if rr2:&#10;&#10;&#10;                                                avg_out = sum(rr2)/len(rr2)&#10;&#10;&#10;                                                print(f&quot;DEBUG: {species} move {mid} would deal {avg_out:.1f}&quot;)&#10;&#10;&#10;                                                best = max(best, avg_out)&#10;&#10;&#10;                                            else:&#10;&#10;&#10;                                                print(f&quot;DEBUG: {species} move {mid} returned no damage rolls&quot;)&#10;&#10;&#10;                                        except Exception as move_err:&#10;&#10;&#10;                                            print(f&quot;DEBUG: {species} error calculating damage for move {mid}: {move_err}&quot;)&#10;&#10;&#10;                            else:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} no corresponding poke-env object found&quot;)&#10;&#10;&#10;                        except Exception as penv_err:&#10;&#10;&#10;                            print(f&quot;DEBUG: {species} error accessing poke-env moves: {penv_err}&quot;)&#10;&#10;&#10;                    else:&#10;&#10;&#10;                        # Use team state moves (original logic)&#10;&#10;&#10;                        for i, mslot in enumerate(cand_moves):&#10;&#10;&#10;                            print(f&quot;DEBUG: {species} move slot {i}: {mslot}&quot;)&#10;&#10;&#10;                            mid = getattr(mslot, &quot;id&quot;, None)&#10;&#10;&#10;                            if not mid:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} move slot {i} has no id, trying other attributes&quot;)&#10;&#10;&#10;                                # Try alternative attribute names&#10;&#10;&#10;                                for attr in ['move', 'name', 'move_id']:&#10;&#10;&#10;                                    alt_id = getattr(mslot, attr, None)&#10;&#10;&#10;                                    if alt_id:&#10;&#10;&#10;                                        mid = alt_id&#10;&#10;&#10;                                        print(f&quot;DEBUG: {species} found move id '{mid}' via attribute '{attr}'&quot;)&#10;&#10;&#10;                                        break&#10;&#10;&#10;                            if not mid:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} skipping move slot {i} - no valid id found&quot;)&#10;&#10;&#10;                                continue&#10;&#10;&#10;                            print(f&quot;DEBUG: {species} calculating damage for move {mid}&quot;)&#10;&#10;&#10;                            try:&#10;&#10;&#10;                                d2 = estimate_damage(tmp_state, cand_key, opp_key, str(mid), mi)&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} move {mid} damage result: {d2}&quot;)&#10;&#10;&#10;                                rr2 = d2.get('rolls', []) or []&#10;&#10;&#10;                                if rr2:&#10;&#10;&#10;                                    avg_out = sum(rr2)/len(rr2)&#10;&#10;&#10;                                    print(f&quot;DEBUG: {species} move {mid} would deal {avg_out:.1f}&quot;)&#10;&#10;&#10;                                    best = max(best, avg_out)&#10;&#10;&#10;                                else:&#10;&#10;&#10;                                    print(f&quot;DEBUG: {species} move {mid} returned no damage rolls&quot;)&#10;&#10;&#10;                            except Exception as move_err:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} error calculating damage for move {mid}: {move_err}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                    # If still no moves found, try some fallback strategies&#10;&#10;&#10;                    if best == 0.0:&#10;&#10;&#10;                        print(f&quot;DEBUG: {species} no moves found via normal methods, trying fallbacks&quot;)&#10;&#10;&#10;                        # Try using a generic move based on the Pokemon's typing or common moves&#10;&#10;&#10;                        fallback_moves = []&#10;&#10;&#10;&#10;&#10;&#10;                        # Add type-based STAB moves&#10;&#10;&#10;                        pokemon_types = cand_ps.types or ()&#10;&#10;&#10;                        if 'fire' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['flamethrower', 'fireblast', 'overheat'])&#10;&#10;&#10;                        if 'water' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['surf', 'hydropump', 'watergun'])&#10;&#10;&#10;                        if 'electric' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['thunderbolt', 'thunder', 'discharge'])&#10;&#10;&#10;                        if 'grass' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['energyball', 'gigadrain', 'leafstorm'])&#10;&#10;&#10;                        if 'psychic' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['psychic', 'psyshock', 'futuresight'])&#10;&#10;&#10;                        if 'fighting' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['closecombat', 'superpower', 'focusblast'])&#10;&#10;&#10;                        if 'dragon' in str(pokemon_types).lower():&#10;&#10;&#10;                            fallback_moves.extend(['dragonpulse', 'dracometeor', 'outrage'])&#10;&#10;&#10;&#10;&#10;&#10;                        # Add common physical/special moves&#10;&#10;&#10;                        fallback_moves.extend(['return', 'bodyslam', 'doubleedge', 'facade'])&#10;&#10;&#10;&#10;&#10;&#10;                        for fallback_move in fallback_moves[:3]:  # Try top 3 fallbacks&#10;&#10;&#10;                            try:&#10;&#10;&#10;                                print(f&quot;DEBUG: {species} trying fallback move {fallback_move}&quot;)&#10;&#10;&#10;                                d2 = estimate_damage(tmp_state, cand_key, opp_key, fallback_move, mi)&#10;&#10;&#10;                                rr2 = d2.get('rolls', []) or []&#10;&#10;&#10;                                if rr2:&#10;&#10;&#10;                                    avg_out = sum(rr2)/len(rr2)&#10;&#10;&#10;                                    print(f&quot;DEBUG: {species} fallback move {fallback_move} would deal {avg_out:.1f}&quot;)&#10;&#10;&#10;                                    best = max(best, avg_out)&#10;&#10;&#10;                                    break  # Use first working fallback&#10;&#10;&#10;                            except Exception:&#10;&#10;&#10;                                continue&#10;&#10;&#10;&#10;&#10;&#10;                    if best &gt; 0:&#10;&#10;&#10;                        out_frac = best / opp_max&#10;&#10;&#10;                        print(f&quot;DEBUG: Best outgoing for {species}: {best:.1f}/{opp_max:.1f} = {out_frac:.3f}&quot;)&#10;&#10;&#10;                    else:&#10;&#10;&#10;                        print(f&quot;DEBUG: No outgoing damage calculated for {species} - best damage was {best}&quot;)&#10;&#10;&#10;                except Exception as e:&#10;&#10;&#10;                    print(f&quot;DEBUG: Error calculating outgoing for {species}: {e}&quot;)&#10;&#10;&#10;                    import traceback&#10;&#10;&#10;                    print(f&quot;DEBUG: Full traceback: {traceback.format_exc()}&quot;)&#10;&#10;&#10;                    pass&#10;&#10;&#10;&#10;&#10;&#10;                hp_frac = float(getattr(p, 'current_hp_fraction', 1.0) or 1.0)&#10;&#10;&#10;                print(f&quot;DEBUG: {species} HP fraction: {hp_frac:.3f}&quot;)&#10;&#10;&#10;&#10;&#10;&#10;                # Risk-aware switch score: prefer lower incoming + hazards, higher future output, and better typing&#10;&#10;&#10;                base_score = (out_frac * 1.2) - (incoming * 1.1) - (haz_frac * 0.5)&#10;&#10;&#10;                score = max(0.0, base_score) + type_bonus&#10;&#10;&#10;                print(f&quot;DEBUG: {species} score calculation:&quot;)&#10;&#10;&#10;                print(f&quot;  Base: ({out_frac:.3f} * 1.2) - ({incoming:.3f} * 1.1) - ({haz_frac:.3f} * 0.5) = {base_score:.3f}&quot;)&#10;&#10;&#10;                print(f&quot;  Final: max(0.0, {base_score:.3f}) + {type_bonus:.3f} = {score:.3f}&quot;)&#10;&#10;&#10;                switches_eval.append({&#10;&#10;&#10;                    'species': species,&#10;&#10;&#10;                    'score': float(score),&#10;&#10;&#10;                    'hp_fraction': hp_frac,&#10;&#10;&#10;                    'incoming_on_switch': float(incoming),&#10;&#10;&#10;                    'hazards_frac': float(haz_frac),&#10;&#10;&#10;                    'type_bonus': float(type_bonus),&#10;&#10;&#10;                    'stay_incoming': float(stay_incoming),&#10;&#10;&#10;                    'outgoing_frac': float(out_frac),  # Add this for debugging&#10;&#10;&#10;                    'base_score': float(base_score),    # Add this for debugging&#10;&#10;&#10;                })&#10;&#10;&#10;&#10;&#10;&#10;            switches_eval.sort(key=lambda x: x.get('score', 0.0), reverse=True)&#10;&#10;&#10;&#10;&#10;&#10;        # ---- Decide -----------------------------------------------------------&#10;&#10;&#10;        snap = snapshot_battle(battle)&#10;&#10;&#10;        best_move = moves_eval[0] if moves_eval else None&#10;&#10;&#10;        best_switch = switches_eval[0] if switches_eval else None&#10;&#10;&#10;&#10;&#10;&#10;        # If we are forced to switch, do it&#10;&#10;&#10;        if force_switch and best_switch:&#10;&#10;&#10;            return ChosenAction(kind='switch', switch_species=best_switch['species'],&#10;&#10;&#10;                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,&#10;&#10;&#10;                                       'picked': {'kind': 'switch', **best_switch}})&#10;&#10;&#10;&#10;&#10;&#10;        # Otherwise compare EVs&#10;&#10;&#10;        if best_move and (not best_switch or best_move['score'] &gt;= best_switch['score']):&#10;&#10;&#10;            return ChosenAction(kind='move', move_id=str(best_move['id']),&#10;&#10;&#10;                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,&#10;&#10;&#10;                                       'picked': {'kind': 'move', **best_move}})&#10;&#10;&#10;        if best_switch:&#10;&#10;&#10;            return ChosenAction(kind='switch', switch_species=best_switch['species'],&#10;&#10;&#10;                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,&#10;&#10;&#10;                                       'picked': {'kind': 'switch', **best_switch}})&#10;&#10;&#10;&#10;&#10;&#10;        # Fallbacks&#10;&#10;&#10;        if legal_moves:&#10;&#10;&#10;            return ChosenAction(kind='move', move_id=str(getattr(legal_moves[0], 'id', '')),&#10;&#10;&#10;                                debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;        if legal_switches:&#10;&#10;&#10;            # never pick active species&#10;&#10;&#10;            for p in legal_switches:&#10;&#10;&#10;                sp = str(getattr(p, 'species', '') or '')&#10;&#10;&#10;                if my_key:&#10;&#10;&#10;                    cursp = str(getattr(state.team.ours[my_key], 'species', '') or '')&#10;&#10;&#10;                else:&#10;&#10;&#10;                    cursp = ''&#10;&#10;&#10;                if sp.lower() != cursp.lower():&#10;&#10;&#10;                    return ChosenAction(kind='switch', switch_species=sp, debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;            # if all else fails, pick first bench&#10;&#10;&#10;            return ChosenAction(kind='switch', switch_species=str(getattr(legal_switches[0], 'species', '')),&#10;&#10;&#10;                                debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;        return ChosenAction(kind='move', move_id='struggle', debug={'snapshot': snap, 'fallback': True})&#10;&#10;&#10;&#10;&#10;&#10;# -------------- Poke-env Player wrapper -----------------------------------&#10;&#10;&#10;try:&#10;&#10;&#10;    from poke_env.player.player import Player  # type: ignore&#10;&#10;&#10;except Exception:&#10;&#10;&#10;    Player = object  # fallback for type checking&#10;&#10;&#10;&#10;&#10;&#10;class StockfishPokeEnvPlayer(Player):  # type: ignore[misc]&#10;&#10;&#10;    def __init__(self, *args, **kwargs):&#10;&#10;&#10;        # Hook for UI&#10;&#10;&#10;        self.on_think_hook = kwargs.pop('on_think', None)&#10;&#10;&#10;        engine_depth = kwargs.pop('engine_depth', None)&#10;&#10;&#10;        self.engine = kwargs.pop('engine', None) or StockfishModel(kwargs.get('battle_format', 'gen9ou'))&#10;&#10;&#10;        try:&#10;&#10;&#10;            self.engine.set_depth(int(engine_depth))&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;        super().__init__(*args, **kwargs)&#10;&#10;&#10;        # Convenience alias for older UI code&#10;&#10;&#10;        try:&#10;&#10;&#10;            self._psclient = self.ps_client&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;    # --------------- Buttons ---------------&#10;&#10;&#10;    async def forfeit_all(self):&#10;&#10;&#10;        # Forfeit all ongoing battles using the official client API.&#10;&#10;&#10;        try:&#10;&#10;&#10;            battles = dict(getattr(self, 'battles', {}) or {})&#10;&#10;&#10;            client = getattr(self, 'ps_client', None)&#10;&#10;&#10;            if not client:&#10;&#10;&#10;                return&#10;&#10;&#10;            for _id, b in battles.items():&#10;&#10;&#10;                try:&#10;&#10;&#10;                    tag = getattr(b, 'battle_tag', getattr(b, 'room_id', None)) or _id&#10;&#10;&#10;                    await client.send_message('/forfeit', room=str(tag))&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    continue&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;    async def timer_all(self, on: bool):&#10;&#10;&#10;        try:&#10;&#10;&#10;            battles = dict(getattr(self, 'battles', {}) or {})&#10;&#10;&#10;            client = getattr(self, 'ps_client', None)&#10;&#10;&#10;            if not client:&#10;&#10;&#10;                return&#10;&#10;&#10;            msg = '/timer on' if on else '/timer off'&#10;&#10;&#10;            for _id, b in battles.items():&#10;&#10;&#10;                try:&#10;&#10;&#10;                    tag = getattr(b, 'battle_tag', getattr(b, 'room_id', None)) or _id&#10;&#10;&#10;                    await client.send_message(msg, room=str(tag))&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    continue&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;    # --------------- Core decision ---------------&#10;&#10;&#10;    def choose_move(self, battle):&#10;&#10;&#10;        decision = self.engine.choose_action(battle)&#10;&#10;&#10;        try:&#10;&#10;&#10;            if self.on_think_hook and isinstance(decision.debug, dict):&#10;&#10;&#10;                # provide the snapshot and current battle object&#10;&#10;&#10;                dd = dict(decision.debug)&#10;&#10;&#10;                dd.setdefault('snapshot', snapshot_battle(battle))&#10;&#10;&#10;                try:&#10;&#10;&#10;                    import json, logging&#10;&#10;&#10;                    logging.getLogger('Think').info(&#10;&#10;&#10;                        'UI_THINK turn=%s payload=%s',&#10;&#10;&#10;                        getattr(battle, 'turn', None),&#10;&#10;&#10;                        json.dumps(dd, default=str)&#10;&#10;&#10;                    )&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    pass&#10;&#10;&#10;                self.on_think_hook(battle, dd)&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            pass&#10;&#10;&#10;&#10;&#10;&#10;        # Convert ChosenAction to poke-env order&#10;&#10;&#10;        try:&#10;&#10;&#10;            if decision.kind == 'move' and decision.move_id:&#10;&#10;&#10;                for m in (getattr(battle, 'available_moves', []) or []):&#10;&#10;&#10;                    if str(getattr(m, 'id', '')) == str(decision.move_id):&#10;&#10;&#10;                        return self.create_order(m)&#10;&#10;&#10;                # fallback: first legal move&#10;&#10;&#10;                return self.create_order((getattr(battle, 'available_moves', []) or [None])[0]) or self.choose_random_move(battle)&#10;&#10;&#10;            elif decision.kind == 'switch' and decision.switch_species:&#10;&#10;&#10;                # never select active mon&#10;&#10;&#10;                try:&#10;&#10;&#10;                    cur = getattr(battle, &quot;active_pokemon&quot;, None)&#10;&#10;&#10;                    cursp = (getattr(cur, &quot;species&quot;, None) or &quot;&quot;).lower()&#10;&#10;&#10;                except Exception:&#10;&#10;&#10;                    cursp = &quot;&quot;&#10;&#10;&#10;                for p in (getattr(battle, 'available_switches', []) or []):&#10;&#10;&#10;                    sp = (str(getattr(p, 'species', '')).lower())&#10;&#10;&#10;                    if sp == cursp:&#10;&#10;&#10;                        continue&#10;&#10;&#10;                    if sp == str(decision.switch_species).lower():&#10;&#10;&#10;                        return self.create_order(p)&#10;&#10;&#10;                # if not found by species, pick first bench (guard)&#10;&#10;&#10;                for p in (getattr(battle, 'available_switches', []) or []):&#10;&#10;&#10;                    if (str(getattr(p, 'species', '')).lower()) != cursp:&#10;&#10;&#10;                        return self.create_order(p)&#10;&#10;&#10;                return self.choose_random_move(battle)&#10;&#10;&#10;            return self.choose_random_move(battle)&#10;&#10;&#10;        except Exception:&#10;&#10;&#10;            return self.choose_random_move(battle)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/GPT_UI.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/GPT_UI.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;User interface for GPT-based Pokemon battle AI&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox, scrolledtext&#10;import threading&#10;from typing import Dict, List, Optional&#10;&#10;# Third-party imports&#10;# import matplotlib.pyplot as plt&#10;# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;&#10;# Local imports&#10;# from Models.GPT_Model import GPTModel&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;&#10;class GPT_UI:&#10;    &quot;&quot;&quot;User interface for GPT model interactions&quot;&quot;&quot;&#10;    &#10;    def __init__(self, root):&#10;        self.root = root&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/RL_UI.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/RL_UI.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;User interface for Reinforcement Learning Pokemon battle AI&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox, scrolledtext&#10;import threading&#10;import time&#10;from typing import Dict, List, Optional&#10;&#10;# Third-party imports&#10;# import matplotlib.pyplot as plt&#10;# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;# import numpy as np&#10;&#10;# Local imports&#10;# from Models.RL_Model import RLModel&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;&#10;class RL_UI:&#10;    &quot;&quot;&quot;User interface for RL model interactions&quot;&quot;&quot;&#10;    &#10;    def __init__(self, root):&#10;        self.root = root&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>