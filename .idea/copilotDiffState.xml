<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Data/poke_env_moves_info.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/poke_env_moves_info.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Pokemon moves information and data management module&#10;---------------------------------------------------&#10;Lightweight wrapper around poke_env.data.GenData for moves and type chart access.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;# --- BEGIN UI TYPE-CHART NORMALIZER PATCH ---&#10;_UI_TC_NORMALIZER_INSTALLED = True&#10;&#10;_CANON_TYPES = [&quot;NORMAL&quot;,&quot;FIRE&quot;,&quot;WATER&quot;,&quot;ELECTRIC&quot;,&quot;GRASS&quot;,&quot;ICE&quot;,&quot;FIGHTING&quot;,&quot;POISON&quot;,&quot;GROUND&quot;,&quot;FLYING&quot;,&quot;PSYCHIC&quot;,&quot;BUG&quot;,&quot;ROCK&quot;,&quot;GHOST&quot;,&quot;DRAGON&quot;,&quot;DARK&quot;,&quot;STEEL&quot;,&quot;FAIRY&quot;,&quot;STELLAR&quot;]&#10;&#10;def _norm_type_name(t):&#10;    if not t: return None&#10;    s = str(t).strip().upper()&#10;    if s == &quot;&quot;: return None&#10;    return s&#10;&#10;def _normalize_showdown_typechart(tc):&#10;    &quot;&quot;&quot;Accepts Showdown's {Type: {damageTaken:{...}}} or a flat multiplier table.&#10;    Returns {ATTACKING_TYPE: {DEFENDING_TYPE: mult(float)}} with UPPERCASE keys.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(tc, dict):&#10;        return {}&#10;    out = {T:{} for T in _CANON_TYPES}&#10;    for atk, row in tc.items():&#10;        A = _norm_type_name(atk)&#10;        if not A: &#10;            continue&#10;        if isinstance(row, dict) and (&quot;damageTaken&quot; in row or &quot;damage_taken&quot; in row):&#10;            taken = row.get(&quot;damageTaken&quot;) or row.get(&quot;damage_taken&quot;) or {}&#10;            for dfd, code in taken.items():&#10;                D = _norm_type_name(dfd)&#10;                if not D: &#10;                    continue&#10;                mult = 1.0&#10;                try:&#10;                    code = int(code)&#10;                except Exception:&#10;                    code = None&#10;                if code == 1: mult = 0.5&#10;                elif code == 2: mult = 2.0&#10;                elif code == 3: mult = 0.0&#10;                out[A][D] = float(mult)&#10;        else:&#10;            for dfd, mult in (row or {}).items():&#10;                D = _norm_type_name(dfd)&#10;                if not D:&#10;                    continue&#10;                try:&#10;                    out[A][D] = float(mult)&#10;                except Exception:&#10;                    pass&#10;    return out&#10;# --- END UI TYPE-CHART NORMALIZER PATCH ---&#10;&#10;from dataclasses import dataclass, field&#10;from typing import Any, Dict, List, Optional, Sequence, Union&#10;&#10;# Added by patch_think_showdown.py&#10;import os&#10;try:&#10;    from tools.Data.showdown.ps_data_loader import load_showdown_dir  # noqa: F401&#10;except Exception:&#10;    load_showdown_dir = None&#10;&#10;try:&#10;    from poke_env.data import GenData&#10;    from poke_env.data.normalize import to_id_str&#10;except Exception:  # pragma: no cover - allow import without poke-env&#10;    GenData = None&#10;    def to_id_str(s: str) -&gt; str:&#10;        return &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())&#10;&#10;&#10;@dataclass&#10;class MoveInfo:&#10;    id: str&#10;    name: str&#10;    type: Optional[str] = None&#10;    category: Optional[str] = None&#10;    base_power: Optional[int] = None&#10;    accuracy: Optional[Union[int, float, bool]] = None&#10;    priority: int = 0&#10;    target: Optional[str] = None&#10;    pp: Optional[int] = None&#10;    flags: Dict[str, bool] = field(default_factory=dict)&#10;    secondary: Optional[Dict[str, Any]] = None&#10;    secondaries: Optional[List[Dict[str, Any]]] = None&#10;    status: Optional[str] = None&#10;    volatile_status: Optional[str] = None&#10;    boosts: Optional[Dict[str, int]] = None&#10;    multihit: Optional[Union[int, List[int]]] = None&#10;    drain: Optional[List[int]] = None&#10;    recoil: Optional[List[int]] = None&#10;    raw: Dict[str, Any] = field(default_factory=dict)&#10;&#10;    @property&#10;    def makes_contact(self) -&gt; bool:&#10;        return bool(self.flags.get(&quot;contact&quot;))&#10;&#10;&#10;class MovesInfo:&#10;    def get_type_chart(self) -&gt; Dict[str, Dict[str, float]]:&#10;            &quot;&quot;&quot;Return a normalized, uppercase type chart with caching (falls back to Showdown).&quot;&quot;&quot;&#10;            try:&#10;                tc = getattr(self, &quot;_type_chart_cache&quot;, None)&#10;                if tc is None:&#10;                    raw_tc = (&#10;                        getattr(getattr(self, &quot;_data&quot;, None), &quot;type_chart&quot;, None)&#10;                        or getattr(self, &quot;type_chart&quot;, None)&#10;                        or (self._ps_dex.get(&quot;typechart&quot;) if getattr(self, &quot;_ps_dex&quot;, None) else {})&#10;                        or {}&#10;                    )&#10;                    tc = _normalize_showdown_typechart(raw_tc)&#10;                    setattr(self, &quot;_type_chart_cache&quot;, tc)&#10;                return tc&#10;            except Exception:&#10;                return {}&#10;&#10;                def __init__(self, gen_or_format: Union[int, str] = 9):&#10;            if isinstance(gen_or_format, int):&#10;                self._data = GenData.from_gen(gen_or_format) if GenData else None&#10;            else:&#10;                self._data = GenData.from_format(gen_or_format) if GenData else None&#10;            # Load Showdown dex as a secondary source (items/abilities/moves/typechart)&#10;            self._ps_dex: Dict[str, Dict[str, Any]] = {}&#10;            try:&#10;                if load_showdown_dir:&#10;                    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))&#10;                    sd_dir = os.path.join(repo_root, &quot;tools&quot;, &quot;Data&quot;, &quot;showdown&quot;)&#10;                    if os.path.isdir(sd_dir):&#10;                        self._ps_dex = load_showdown_dir(sd_dir)&#10;            except Exception:&#10;                self._ps_dex = {}    def gen(self) -&gt; int:&#10;        return getattr(self._data, &quot;gen&quot;, 9)&#10;&#10;    def exists(self, name_or_id: str) -&gt; bool:&#10;        if not self._data:&#10;            return False&#10;        return to_id_str(name_or_id) in self._data.moves&#10;&#10;    def all_ids(self) -&gt; List[str]:&#10;        if not self._data:&#10;            return []&#10;        return list(self._data.moves.keys())&#10;&#10;    def raw(self, name_or_id: str) -&gt; Dict[str, Any]:&#10;        if not self._data:&#10;            raise RuntimeError(&quot;poke_env not available&quot;)&#10;        mid = to_id_str(name_or_id)&#10;        m = self._data.moves.get(mid)&#10;        if m is None:&#10;            raise KeyError(f&quot;Unknown move: {name_or_id} (normalized: {mid})&quot;)&#10;        return m&#10;&#10;    def get(self, name_or_id: str) -&gt; MoveInfo:&#10;        m = self.raw(name_or_id)&#10;        mid = to_id_str(name_or_id)&#10;        return MoveInfo(&#10;            id=mid,&#10;            name=m.get(&quot;name&quot;, mid),&#10;            type=m.get(&quot;type&quot;),&#10;            category=m.get(&quot;category&quot;),&#10;            base_power=m.get(&quot;basePower&quot;),&#10;            accuracy=m.get(&quot;accuracy&quot;),&#10;            priority=m.get(&quot;priority&quot;, 0),&#10;            target=m.get(&quot;target&quot;),&#10;            pp=m.get(&quot;pp&quot;),&#10;            flags=m.get(&quot;flags&quot;, {}),&#10;            secondary=m.get(&quot;secondary&quot;),&#10;            secondaries=m.get(&quot;secondaries&quot;),&#10;            status=m.get(&quot;status&quot;),&#10;            volatile_status=m.get(&quot;volatileStatus&quot;),&#10;            boosts=m.get(&quot;boosts&quot;),&#10;            multihit=m.get(&quot;multihit&quot;),&#10;            drain=m.get(&quot;drain&quot;),&#10;            recoil=m.get(&quot;recoil&quot;),&#10;            raw=m,&#10;        )&#10;&#10;    def exists(self, name_or_id: str) -&gt; bool:&#10;            mid = to_id_str(name_or_id)&#10;            in_pokeenv = bool(getattr(self, &quot;_data&quot;, None)) and (mid in getattr(self._data, &quot;moves&quot;, {}))&#10;            in_ps = bool(self._ps_dex) and (mid in self._ps_dex.get(&quot;moves&quot;, {}))&#10;            return in_pokeenv or in_ps&#10;&#10;    def raw(self, name_or_id: str) -&gt; Dict[str, Any]:&#10;            mid = to_id_str(name_or_id)&#10;            m = None&#10;            try:&#10;                if getattr(self, &quot;_data&quot;, None):&#10;                    m = self._data.moves.get(mid)&#10;            except Exception:&#10;                m = None&#10;            if m is None and self._ps_dex:&#10;                m = self._ps_dex.get(&quot;moves&quot;, {}).get(mid)&#10;            if m is None:&#10;                raise KeyError(f&quot;Unknown move: {name_or_id} (normalized: {mid})&quot;)&#10;            return m&#10;&#10;    def get(self, name_or_id: str) -&gt; MoveInfo:&#10;            m = self.raw(name_or_id)&#10;            mid = to_id_str(name_or_id)&#10;            return MoveInfo(&#10;                id=mid,&#10;                name=m.get(&quot;name&quot;, mid),&#10;                type=m.get(&quot;type&quot;),&#10;                category=m.get(&quot;category&quot;),&#10;                base_power=m.get(&quot;basePower&quot;) if &quot;basePower&quot; in m else m.get(&quot;base_power&quot;),&#10;                accuracy=m.get(&quot;accuracy&quot;),&#10;                priority=m.get(&quot;priority&quot;, 0),&#10;                target=m.get(&quot;target&quot;),&#10;                pp=m.get(&quot;pp&quot;),&#10;                flags=m.get(&quot;flags&quot;, {}),&#10;                secondary=m.get(&quot;secondary&quot;),&#10;                secondaries=m.get(&quot;secondaries&quot;),&#10;                status=m.get(&quot;status&quot;),&#10;                volatile_status=m.get(&quot;volatileStatus&quot;) or m.get(&quot;volatile_status&quot;),&#10;                boosts=m.get(&quot;boosts&quot;),&#10;                multihit=m.get(&quot;multihit&quot;),&#10;                drain=m.get(&quot;drain&quot;),&#10;                recoil=m.get(&quot;recoil&quot;),&#10;                raw=m,&#10;            )&#10;def get_type_chart(self) -&gt; Dict[str, Dict[str, float]]:&#10;    &quot;&quot;&quot;Return a normalized, uppercase type chart mapping ATK-&gt;{DEF: multiplier}.&#10;&#10;    This is applied once at source so every downstream caller sees consistent data:&#10;    - Attack/Defense type names uppercased&#10;    - Multipliers coerced to float (0, 0.5, 1, 2, etc.)&#10;    - Odd dumps (True/False/None/strings) mapped to sane defaults&#10;    &quot;&quot;&quot;&#10;    if not self._data:&#10;        return {}&#10;&#10;    raw_tc = getattr(self._data, &quot;type_chart&quot;, {}) or {}&#10;    norm: Dict[str, Dict[str, float]] = {}&#10;&#10;    for atk, row in raw_tc.items():&#10;        if not isinstance(row, dict):&#10;            # Some older exports wrap rows differently; skip if malformed&#10;            continue&#10;        atk_u = str(atk).upper()&#10;        out: Dict[str, float] = {}&#10;&#10;        for d, mult in (row or {}).items():&#10;            d_u = str(d).upper()&#10;            try:&#10;                out[d_u] = float(mult)&#10;            except Exception:&#10;                # Robust coercion for quirky exports&#10;                if mult is True:&#10;                    out[d_u] = 1.0&#10;                elif mult in (False, 0, &quot;0&quot;, &quot;0.0&quot;, None):&#10;                    out[d_u] = 0.0&#10;                elif mult in (&quot;0.5&quot;, &quot;.5&quot;, &quot;½&quot;):&#10;                    out[d_u] = 0.5&#10;                elif mult in (&quot;2&quot;, &quot;2.0&quot;, &quot;×2&quot;):&#10;                    out[d_u] = 2.0&#10;                else:&#10;                    # Final fallback: neutral&#10;                    out[d_u] = 1.0&#10;&#10;        norm[atk_u] = out&#10;&#10;    return norm&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Pokemon moves information and data management module&#10;---------------------------------------------------&#10;Lightweight wrapper around poke_env.data.GenData for moves and type chart access.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;# --- BEGIN UI TYPE-CHART NORMALIZER PATCH ---&#10;_UI_TC_NORMALIZER_INSTALLED = True&#10;&#10;_CANON_TYPES = [&quot;NORMAL&quot;,&quot;FIRE&quot;,&quot;WATER&quot;,&quot;ELECTRIC&quot;,&quot;GRASS&quot;,&quot;ICE&quot;,&quot;FIGHTING&quot;,&quot;POISON&quot;,&quot;GROUND&quot;,&quot;FLYING&quot;,&quot;PSYCHIC&quot;,&quot;BUG&quot;,&quot;ROCK&quot;,&quot;GHOST&quot;,&quot;DRAGON&quot;,&quot;DARK&quot;,&quot;STEEL&quot;,&quot;FAIRY&quot;,&quot;STELLAR&quot;]&#10;&#10;def _norm_type_name(t):&#10;    if not t: return None&#10;    s = str(t).strip().upper()&#10;    if s == &quot;&quot;: return None&#10;    return s&#10;&#10;def _normalize_showdown_typechart(tc):&#10;    &quot;&quot;&quot;Accepts Showdown's {Type: {damageTaken:{...}}} or a flat multiplier table.&#10;    Returns {ATTACKING_TYPE: {DEFENDING_TYPE: mult(float)}} with UPPERCASE keys.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(tc, dict):&#10;        return {}&#10;    out = {T:{} for T in _CANON_TYPES}&#10;    for atk, row in tc.items():&#10;        A = _norm_type_name(atk)&#10;        if not A: &#10;            continue&#10;        if isinstance(row, dict) and (&quot;damageTaken&quot; in row or &quot;damage_taken&quot; in row):&#10;            taken = row.get(&quot;damageTaken&quot;) or row.get(&quot;damage_taken&quot;) or {}&#10;            for dfd, code in taken.items():&#10;                D = _norm_type_name(dfd)&#10;                if not D: &#10;                    continue&#10;                mult = 1.0&#10;                try:&#10;                    code = int(code)&#10;                except Exception:&#10;                    code = None&#10;                if code == 1: mult = 0.5&#10;                elif code == 2: mult = 2.0&#10;                elif code == 3: mult = 0.0&#10;                out[A][D] = float(mult)&#10;        else:&#10;            for dfd, mult in (row or {}).items():&#10;                D = _norm_type_name(dfd)&#10;                if not D:&#10;                    continue&#10;                try:&#10;                    out[A][D] = float(mult)&#10;                except Exception:&#10;                    pass&#10;    return out&#10;# --- END UI TYPE-CHART NORMALIZER PATCH ---&#10;&#10;from dataclasses import dataclass, field&#10;from typing import Any, Dict, List, Optional, Sequence, Union&#10;&#10;# Added by patch_think_showdown.py&#10;import os&#10;try:&#10;    from tools.Data.showdown.ps_data_loader import load_showdown_dir  # noqa: F401&#10;except Exception:&#10;    load_showdown_dir = None&#10;&#10;try:&#10;    from poke_env.data import GenData&#10;    from poke_env.data.normalize import to_id_str&#10;except Exception:  # pragma: no cover - allow import without poke-env&#10;    GenData = None&#10;    def to_id_str(s: str) -&gt; str:&#10;        return &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())&#10;&#10;&#10;@dataclass&#10;class MoveInfo:&#10;    id: str&#10;    name: str&#10;    type: Optional[str] = None&#10;    category: Optional[str] = None&#10;    base_power: Optional[int] = None&#10;    accuracy: Optional[Union[int, float, bool]] = None&#10;    priority: int = 0&#10;    target: Optional[str] = None&#10;    pp: Optional[int] = None&#10;    flags: Dict[str, bool] = field(default_factory=dict)&#10;    secondary: Optional[Dict[str, Any]] = None&#10;    secondaries: Optional[List[Dict[str, Any]]] = None&#10;    status: Optional[str] = None&#10;    volatile_status: Optional[str] = None&#10;    boosts: Optional[Dict[str, int]] = None&#10;    multihit: Optional[Union[int, List[int]]] = None&#10;    drain: Optional[List[int]] = None&#10;    recoil: Optional[List[int]] = None&#10;    raw: Dict[str, Any] = field(default_factory=dict)&#10;&#10;    @property&#10;    def makes_contact(self) -&gt; bool:&#10;        return bool(self.flags.get(&quot;contact&quot;))&#10;&#10;&#10;class MovesInfo:&#10;    def __init__(self, gen_or_format: Union[int, str] = 9):&#10;        if isinstance(gen_or_format, int):&#10;            self._data = GenData.from_gen(gen_or_format) if GenData else None&#10;        else:&#10;            self._data = GenData.from_format(gen_or_format) if GenData else None&#10;        # Load Showdown dex as a secondary source (items/abilities/moves/typechart)&#10;        self._ps_dex: Dict[str, Dict[str, Any]] = {}&#10;        try:&#10;            if load_showdown_dir:&#10;                repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))&#10;                sd_dir = os.path.join(repo_root, &quot;tools&quot;, &quot;Data&quot;, &quot;showdown&quot;)&#10;                if os.path.isdir(sd_dir):&#10;                    self._ps_dex = load_showdown_dir(sd_dir)&#10;        except Exception:&#10;            self._ps_dex = {}&#10;&#10;    def gen(self) -&gt; int:&#10;        return getattr(self._data, &quot;gen&quot;, 9)&#10;&#10;    def exists(self, name_or_id: str) -&gt; bool:&#10;        mid = to_id_str(name_or_id)&#10;        in_pokeenv = bool(getattr(self, &quot;_data&quot;, None)) and (mid in getattr(self._data, &quot;moves&quot;, {}))&#10;        in_ps = bool(self._ps_dex) and (mid in self._ps_dex.get(&quot;moves&quot;, {}))&#10;        return in_pokeenv or in_ps&#10;&#10;    def all_ids(self) -&gt; List[str]:&#10;        if not self._data:&#10;            return []&#10;        return list(self._data.moves.keys())&#10;&#10;    def raw(self, name_or_id: str) -&gt; Dict[str, Any]:&#10;        mid = to_id_str(name_or_id)&#10;        m = None&#10;        try:&#10;            if getattr(self, &quot;_data&quot;, None):&#10;                m = self._data.moves.get(mid)&#10;        except Exception:&#10;            m = None&#10;        if m is None and self._ps_dex:&#10;            m = self._ps_dex.get(&quot;moves&quot;, {}).get(mid)&#10;        if m is None:&#10;            raise KeyError(f&quot;Unknown move: {name_or_id} (normalized: {mid})&quot;)&#10;        return m&#10;&#10;    def get(self, name_or_id: str) -&gt; MoveInfo:&#10;        m = self.raw(name_or_id)&#10;        mid = to_id_str(name_or_id)&#10;        return MoveInfo(&#10;            id=mid,&#10;            name=m.get(&quot;name&quot;, mid),&#10;            type=m.get(&quot;type&quot;),&#10;            category=m.get(&quot;category&quot;),&#10;            base_power=m.get(&quot;basePower&quot;) if &quot;basePower&quot; in m else m.get(&quot;base_power&quot;),&#10;            accuracy=m.get(&quot;accuracy&quot;),&#10;            priority=m.get(&quot;priority&quot;, 0),&#10;            target=m.get(&quot;target&quot;),&#10;            pp=m.get(&quot;pp&quot;),&#10;            flags=m.get(&quot;flags&quot;, {}),&#10;            secondary=m.get(&quot;secondary&quot;),&#10;            secondaries=m.get(&quot;secondaries&quot;),&#10;            status=m.get(&quot;status&quot;),&#10;            volatile_status=m.get(&quot;volatileStatus&quot;) or m.get(&quot;volatile_status&quot;),&#10;            boosts=m.get(&quot;boosts&quot;),&#10;            multihit=m.get(&quot;multihit&quot;),&#10;            drain=m.get(&quot;drain&quot;),&#10;            recoil=m.get(&quot;recoil&quot;),&#10;            raw=m,&#10;        )&#10;&#10;    def get_type_chart(self) -&gt; Dict[str, Dict[str, float]]:&#10;        &quot;&quot;&quot;Return a normalized, uppercase type chart with caching (falls back to Showdown).&quot;&quot;&quot;&#10;        try:&#10;            tc = getattr(self, &quot;_type_chart_cache&quot;, None)&#10;            if tc is None:&#10;                raw_tc = (&#10;                    getattr(getattr(self, &quot;_data&quot;, None), &quot;type_chart&quot;, None)&#10;                    or getattr(self, &quot;type_chart&quot;, None)&#10;                    or (self._ps_dex.get(&quot;typechart&quot;) if getattr(self, &quot;_ps_dex&quot;, None) else {})&#10;                    or {}&#10;                )&#10;                tc = _normalize_showdown_typechart(raw_tc)&#10;                setattr(self, &quot;_type_chart_cache&quot;, tc)&#10;            return tc&#10;        except Exception:&#10;            return {}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Models/GPT_Model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Models/GPT_Model.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;GPT-based AI model for Pokemon battle decisions&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import os&#10;import json&#10;from typing import Dict, List, Optional, Any&#10;import asyncio&#10;&#10;# Third-party imports&#10;# import openai&#10;# import torch&#10;# from transformers import GPTModel, GPTTokenizer&#10;# import numpy as np&#10;&#10;# Local imports&#10;# from Data.battle_helper import BattleHelper&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;# from Data.poke_env_pokemon_info import PokemonInfo&#10;&#10;class GPTModel:&#10;    &quot;&quot;&quot;GPT-based model for Pokemon battle AI&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/GPT_UI.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/GPT_UI.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;User interface for GPT-based Pokemon battle AI&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox, scrolledtext&#10;import threading&#10;from typing import Dict, List, Optional&#10;&#10;# Third-party imports&#10;# import matplotlib.pyplot as plt&#10;# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;&#10;# Local imports&#10;# from Models.GPT_Model import GPTModel&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;&#10;class GPT_UI:&#10;    &quot;&quot;&quot;User interface for GPT model interactions&quot;&quot;&quot;&#10;    &#10;    def __init__(self, root):&#10;        self.root = root&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/RL_UI.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/RL_UI.py" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;User interface for Reinforcement Learning Pokemon battle AI&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox, scrolledtext&#10;import threading&#10;import time&#10;from typing import Dict, List, Optional&#10;&#10;# Third-party imports&#10;# import matplotlib.pyplot as plt&#10;# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;# import numpy as np&#10;&#10;# Local imports&#10;# from Models.RL_Model import RLModel&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;&#10;class RL_UI:&#10;    &quot;&quot;&quot;User interface for RL model interactions&quot;&quot;&quot;&#10;&#10;    def __init__(self, root):&#10;        self.root = root&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>