<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Data/battle_runtime.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/battle_runtime.py" />
              <option name="originalContent" value="# battle_runtime.py&#10;&quot;&quot;&quot;&#10;Runtime glue for live poke-env battles and our mechanics modules.&#10;&#10;This file exposes a minimal, clean API your model can call:&#10;- get_state(battle, gen=9) -&gt; CombinedState&#10;- enumerate_actions(battle) -&gt; {&quot;moves&quot;: [MoveChoice...], &quot;switches&quot;: [species_id...]}&#10;- predict_order_for_ids(state, my_key, my_move_id, opp_key, opp_move_id, moves_info, *, my_tailwind=None, opp_tailwind=None) -&gt; (prob, details)&#10;- estimate_damage(state, attacker_key, defender_key, move_id, moves_info, *, is_crit=False) -&gt; dict&#10;- apply_switch_in_effects(state, switch_in_key, side: &quot;ally&quot;|&quot;opponent&quot;, moves_info) -&gt; dict&#10;- would_fail(move_id, user_key, target_key, state, moves_info) -&gt; (bool, reason)&#10;&#10;It uses these modules:&#10;  - team_state.TeamState (resolved stats &amp; volatiles)&#10;  - poke_env_battle_environment.to_field_state (weather/terrain/screens, etc.)&#10;  - turn_order (priority + speed)&#10;  - damage_helper (damage pipeline with fixed-point chain)&#10;  - battle_helper (type/screen/weather/terrain helpers)&#10;  - field_effects (hazards &amp; Sticky Web)&#10;  - stat_effects (stage change machinery; grounded inference)&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, List, Optional, Tuple&#10;import os&#10;&#10;from .team_state import TeamState, PokemonState&#10;from .poke_env_battle_environment import to_field_state, FieldState as EnvFieldState&#10;from .poke_env_moves_info import MovesInfo&#10;from .poke_env_pokemon_info import PokemonInfo&#10;from .stat_effects import compute_passive_multipliers, augment_grounded&#10;from .field_effects import apply_entry_hazards_on_switch_in&#10;from .turn_order import (&#10;    SpeedContext as TO_SpeedContext,&#10;    MoveContext as TO_MoveContext,&#10;    Action as TO_Action,&#10;    predict_order as to_predict_order,&#10;    compute_effective_speed as to_compute_speed,&#10;)&#10;from .damage_helper import (&#10;    CombatantState as DMG_Combatant,&#10;    MoveContext as DMG_Move,&#10;    FieldState as DMG_Field,&#10;    calc_damage_range,&#10;)&#10;from .battle_helper import (&#10;    type_effectiveness,&#10;    weather_modifier,&#10;    screen_modifier,&#10;    terrain_modifier,&#10;    stab_multiplier,&#10;)&#10;&#10;# New: common boosting item lookup&#10;_BOOST_ITEMS_TYPE = {&#10;    # plates &amp; drives &amp; standard type boosters (approx 1.2)&#10;    'charcoal': (1.2, 'fire'), 'mysticwater': (1.2, 'water'), 'magnet': (1.2, 'electric'), 'miracleseed': (1.2, 'grass'),&#10;    'nevermeltice': (1.2, 'ice'), 'blackbelt': (1.2, 'fighting'), 'poisonbarb': (1.2, 'poison'), 'softsand': (1.2, 'ground'),&#10;    'sharpbeak': (1.2, 'flying'), 'twistedspoon': (1.2, 'psychic'), 'silkscarf': (1.2, 'normal'), 'spelltag': (1.2, 'ghost'),&#10;    'dragonfang': (1.2, 'dragon'), 'blackglasses': (1.2, 'dark'), 'metalcoat': (1.2, 'steel'), 'pixieplate': (1.2, 'fairy'),&#10;}&#10;# --------------------------------- State -----------------------------------------&#10;&#10;@dataclass&#10;class CombinedState:&#10;    team: TeamState&#10;    field: EnvFieldState&#10;    turn: Optional[int]&#10;    format: Optional[str]&#10;    my_side: Dict[str, Any]&#10;    opp_side: Dict[str, Any]&#10;    force_switch: bool = False&#10;&#10;def _extract_side_flags(battle) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:&#10;    # reuse the helper from poke_env_battle_environment&#10;    from .poke_env_battle_environment import _extract_side_conditions&#10;    my_side = _extract_side_conditions(getattr(battle, &quot;side_conditions&quot;, None) or getattr(battle, &quot;side&quot;, None))&#10;    opp_side = _extract_side_conditions(getattr(battle, &quot;opponent_side_conditions&quot;, None) or getattr(battle, &quot;opponent_side&quot;, None))&#10;    return my_side, opp_side&#10;&#10;def get_state(battle, gen: int = 9, ev_policy: str = &quot;auto&quot;) -&gt; CombinedState:&#10;    ts = TeamState.from_battle(battle, gen=gen, ev_policy=ev_policy)&#10;    field = to_field_state(battle)&#10;    my_side, opp_side = _extract_side_flags(battle)&#10;    return CombinedState(&#10;        team=ts,&#10;        field=field,&#10;        turn=getattr(battle, &quot;turn&quot;, None),&#10;        format=getattr(battle, &quot;format&quot;, None),&#10;        my_side=my_side,&#10;        opp_side=opp_side,&#10;        force_switch=bool(getattr(battle, &quot;force_switch&quot;, False)),&#10;    )&#10;&#10;# ------------------------------ Actions ------------------------------------------&#10;&#10;@dataclass&#10;class MoveChoice:&#10;    id: str&#10;    name: Optional[str]&#10;    priority: int&#10;    type: Optional[str]&#10;    category: Optional[str]&#10;" />
              <option name="updatedContent" value="# battle_runtime.py&#10;&quot;&quot;&quot;&#10;Runtime glue for live poke-env battles and our mechanics modules.&#10;&#10;This file exposes a minimal, clean API your model can call:&#10;- get_state(battle, gen=9) -&gt; CombinedState&#10;- enumerate_actions(battle) -&gt; {&quot;moves&quot;: [MoveChoice...], &quot;switches&quot;: [species_id...]}&#10;- predict_order_for_ids(state, my_key, my_move_id, opp_key, opp_move_id, moves_info, *, my_tailwind=None, opp_tailwind=None) -&gt; (prob, details)&#10;- estimate_damage(state, attacker_key, defender_key, move_id, moves_info, *, is_crit=False) -&gt; dict&#10;- apply_switch_in_effects(state, switch_in_key, side: &quot;ally&quot;|&quot;opponent&quot;, moves_info) -&gt; dict&#10;- would_fail(move_id, user_key, target_key, state, moves_info) -&gt; (bool, reason)&#10;&#10;It uses these modules:&#10;  - team_state.TeamState (resolved stats &amp; volatiles)&#10;  - poke_env_battle_environment.to_field_state (weather/terrain/screens, etc.)&#10;  - turn_order (priority + speed)&#10;  - damage_helper (damage pipeline with fixed-point chain)&#10;  - battle_helper (type/screen/weather/terrain helpers)&#10;  - field_effects (hazards &amp; Sticky Web)&#10;  - stat_effects (stage change machinery; grounded inference)&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, List, Optional, Tuple&#10;import os&#10;&#10;from .team_state import TeamState, PokemonState&#10;from .poke_env_battle_environment import to_field_state, FieldState as EnvFieldState&#10;from .poke_env_moves_info import MovesInfo&#10;from .poke_env_pokemon_info import PokemonInfo&#10;from .stat_effects import compute_passive_multipliers, augment_grounded&#10;from .field_effects import apply_entry_hazards_on_switch_in&#10;from .turn_order import (&#10;    SpeedContext as TO_SpeedContext,&#10;    MoveContext as TO_MoveContext,&#10;    Action as TO_Action,&#10;    predict_order as to_predict_order,&#10;    compute_effective_speed as to_compute_speed,&#10;)&#10;from .damage_helper import (&#10;    CombatantState as DMG_Combatant,&#10;    MoveContext as DMG_Move,&#10;    FieldState as DMG_Field,&#10;    calc_damage_range,&#10;)&#10;from .battle_helper import (&#10;    type_effectiveness,&#10;    weather_modifier,&#10;    screen_modifier,&#10;    terrain_modifier,&#10;    stab_multiplier,&#10;)&#10;&#10;# New: common boosting item lookup&#10;_BOOST_ITEMS_TYPE = {&#10;    # plates &amp; drives &amp; standard type boosters (approx 1.2)&#10;    'charcoal': (1.2, 'fire'), 'mysticwater': (1.2, 'water'), 'magnet': (1.2, 'electric'), 'miracleseed': (1.2, 'grass'),&#10;    'nevermeltice': (1.2, 'ice'), 'blackbelt': (1.2, 'fighting'), 'poisonbarb': (1.2, 'poison'), 'softsand': (1.2, 'ground'),&#10;    'sharpbeak': (1.2, 'flying'), 'twistedspoon': (1.2, 'psychic'), 'silkscarf': (1.2, 'normal'), 'spelltag': (1.2, 'ghost'),&#10;    'dragonfang': (1.2, 'dragon'), 'blackglasses': (1.2, 'dark'), 'metalcoat': (1.2, 'steel'), 'pixieplate': (1.2, 'fairy'),&#10;}&#10;# --------------------------------- State -----------------------------------------&#10;&#10;@dataclass&#10;class CombinedState:&#10;    team: TeamState&#10;    field: EnvFieldState&#10;    turn: Optional[int]&#10;    format: Optional[str]&#10;    my_side: Dict[str, Any]&#10;    opp_side: Dict[str, Any]&#10;    force_switch: bool = False&#10;&#10;def _extract_side_flags(battle) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:&#10;    # reuse the helper from poke_env_battle_environment&#10;    from .poke_env_battle_environment import _extract_side_conditions&#10;    my_side = _extract_side_conditions(getattr(battle, &quot;side_conditions&quot;, None) or getattr(battle, &quot;side&quot;, None))&#10;    opp_side = _extract_side_conditions(getattr(battle, &quot;opponent_side_conditions&quot;, None) or getattr(battle, &quot;opponent_side&quot;, None))&#10;    return my_side, opp_side&#10;&#10;def get_state(battle, gen: int = 9, ev_policy: str = &quot;auto&quot;) -&gt; CombinedState:&#10;    ts = TeamState.from_battle(battle, gen=gen, ev_policy=ev_policy)&#10;    field = to_field_state(battle)&#10;    my_side, opp_side = _extract_side_flags(battle)&#10;    return CombinedState(&#10;        team=ts,&#10;        field=field,&#10;        turn=getattr(battle, &quot;turn&quot;, None),&#10;        format=getattr(battle, &quot;format&quot;, None),&#10;        my_side=my_side,&#10;        opp_side=opp_side,&#10;        force_switch=bool(getattr(battle, &quot;force_switch&quot;, False)),&#10;    )&#10;&#10;# ------------------------------ Actions ------------------------------------------&#10;&#10;@dataclass&#10;class MoveChoice:&#10;    id: str&#10;    name: Optional[str]&#10;    priority: int&#10;    type: Optional[str]&#10;    category: Optional[str]&#10;    # Extended metadata for UI / heuristics&#10;    pp: Optional[int] = None&#10;    max_pp: Optional[int] = None&#10;    disabled: bool = False&#10;&#10;def enumerate_actions(battle) -&gt; Dict[str, List[Any]]:&#10;    moves = []&#10;    for m in (getattr(battle, &quot;available_moves&quot;, None) or []):&#10;        mid = getattr(m, &quot;id&quot;, None) or getattr(m, &quot;name&quot;, None)&#10;        moves.append(MoveChoice(&#10;            id=str(mid),&#10;            name=getattr(m, &quot;name&quot;, None),&#10;            priority=int(getattr(m, &quot;priority&quot;, 0) or 0),&#10;            type=getattr(m, &quot;type&quot;, None),&#10;            category=getattr(m, &quot;category&quot;, None),&#10;            pp=getattr(m, &quot;pp&quot;, None),&#10;            max_pp=getattr(m, &quot;max_pp&quot;, None) or getattr(m, &quot;maxpp&quot;, None),&#10;            disabled=bool(getattr(m, &quot;disabled&quot;, False)),&#10;        ))&#10;    switches = [getattr(p, &quot;species&quot;, None) for p in (getattr(battle, &quot;available_switches&quot;, None) or [])]&#10;    return {&quot;moves&quot;: moves, &quot;switches&quot;: switches}&#10;&#10;# --------------------------- Priority + Speed ------------------------------------&#10;&#10;def _is_sun(weather: Optional[str]) -&gt; bool:&#10;    return str(weather or &quot;&quot;).lower() in {&quot;sun&quot;,&quot;harshsunlight&quot;,&quot;desolateland&quot;}&#10;&#10;def _is_electric(terrain: Optional[str]) -&gt; bool:&#10;    return str(terrain or &quot;&quot;).lower() == &quot;electric&quot;&#10;&#10;def _highest_stat_is_speed(ps: PokemonState) -&gt; bool:&#10;    r = ps.stats.raw&#10;    return r.get(&quot;spe&quot;, 0) &gt;= max(r.get(&quot;atk&quot;, 0), r.get(&quot;spa&quot;, 0), r.get(&quot;def&quot;, 0), r.get(&quot;spd&quot;, 0))&#10;&#10;def _speed_context_from_state(ps: PokemonState, *, field: EnvFieldState, tailwind_active: bool) -&gt; TO_SpeedContext:&#10;    status = (ps.status or &quot;&quot;).lower()&#10;    ability = (ps.ability or &quot;&quot;).lower()&#10;    item = (ps.item or &quot;&quot;).lower() if ps.item else None&#10;    nature = (ps.stats.nature or &quot;serious&quot;).lower()&#10;&#10;    # Paradox speed boost when Speed is highest stat and activation condition met&#10;    has_proto_speed = ability == &quot;protosynthesis&quot; and (_is_sun(field.weather)) and _highest_stat_is_speed(ps)&#10;    has_quark_speed = ability == &quot;quarkdrive&quot; and (_is_electric(field.terrain)) and _highest_stat_is_speed(ps)&#10;&#10;    # Unburden heuristic: if ability is unburden and item is None but consumed_item was present at some point&#10;    unburden_active = ability == &quot;unburden&quot; and (ps.consumed_item is not None) and (ps.item is None)&#10;&#10;    return TO_SpeedContext(&#10;        base_spe=int(ps.stats.base.get(&quot;spe&quot;, 0)),&#10;        iv_spe=int(ps.stats.ivs.get(&quot;spe&quot;, 31)),&#10;        ev_spe=int(ps.stats.evs.get(&quot;spe&quot;, 0)),&#10;        level=int(ps.stats.level),&#10;        nature_id=nature,&#10;        boost_stage_spe=int(ps.stats.boosts.get(&quot;spe&quot;, 0)),&#10;        user_is_paralyzed=(status == &quot;par&quot;),&#10;        user_has_quickfeet=(ability == &quot;quickfeet&quot;),&#10;        user_is_statused=bool(status),&#10;        ability_id=ability,&#10;        item_id=item,&#10;        user_unburden_active=unburden_active,&#10;        user_protosynthesis_speed=has_proto_speed,&#10;        user_quarkdrive_speed=has_quark_speed,&#10;        user_slowstart_active=(ability == &quot;slowstart&quot;),&#10;        is_ditto_untransformed=(ps.species.lower() == &quot;ditto&quot; and &quot;transform&quot; not in ps.volatiles),&#10;        weather=field.weather,&#10;        terrain=field.terrain,&#10;        side_tailwind_active=bool(tailwind_active),&#10;        trick_room_active=bool(getattr(field, &quot;trick_room&quot;, False)),&#10;        magic_room_active=False,  # if you track Magic Room, set this accordingly&#10;    )&#10;&#10;def _to_move_ctx_for_order(mv: Any, user: PokemonState, target: PokemonState, field: EnvFieldState, mi: Optional[MovesInfo] = None) -&gt; TO_MoveContext:&#10;    raw = mi.get(mv)&#10;    is_heal = bool(raw.raw.get(&quot;heal&quot;)) or bool(raw.raw.get(&quot;drain&quot;))&#10;    return TO_MoveContext(&#10;        name=raw.id,&#10;        base_priority=int(raw.priority or 0),&#10;        category=str(raw.category or &quot;Status&quot;).capitalize(),&#10;        type=str(raw.type or &quot;Unknown&quot;),&#10;        is_healing_or_drain=is_heal,&#10;        user_hp_is_full=bool((user.current_hp or 0) &gt;= (user.max_hp or 0)),&#10;        terrain=field.terrain,&#10;        target_is_grounded=bool(target.grounded if target.grounded is not None else True),&#10;        opponent_has_priority_block_ability=bool(target.has_priority_block),&#10;        is_prankster_applied=False,   # computed inside the order engine&#10;        target_is_dark=(&quot;dark&quot; in {t for t in target.types if t}),&#10;    )&#10;&#10;def _tailwind_flags(my_side: Dict[str, Any], opp_side: Dict[str, Any]) -&gt; Tuple[bool, bool]:&#10;    return bool(my_side.get(&quot;tailwind&quot;, False)), bool(opp_side.get(&quot;tailwind&quot;, False))&#10;&#10;def predict_order_for_ids(&#10;    state: CombinedState,&#10;    my_key: str,&#10;    my_move_id: str,&#10;    opp_key: str,&#10;    opp_move_id: str,&#10;    mi: Optional[MovesInfo] = None,&#10;    *,&#10;    my_tailwind: Optional[bool] = None,&#10;    opp_tailwind: Optional[bool] = None,&#10;) -&gt; Tuple[float, Dict[str, Any]]:&#10;    mi = mi or MovesInfo(state.format or 9)&#10;    me = state.team.ours[my_key]&#10;    opp = state.team.opponent[opp_key]&#10;&#10;    # Ensure grounded flags are known for priority blocks/terrain&#10;    if me.grounded is None: augment_grounded(me, {&quot;gravity&quot;: state.field.gravity})&#10;    if opp.grounded is None: augment_grounded(opp, {&quot;gravity&quot;: state.field.gravity})&#10;&#10;    # Tailwind flags&#10;    tw_my, tw_opp = _tailwind_flags(state.my_side, state.opp_side)&#10;    tw_my = tw_my if my_tailwind is None else my_tailwind&#10;    tw_opp = tw_opp if opp_tailwind is None else opp_tailwind&#10;&#10;    # Speed&#10;    me_ctx = _speed_context_from_state(me, field=state.field, tailwind_active=tw_my)&#10;    opp_ctx = _speed_context_from_state(opp, field=state.field, tailwind_active=tw_opp)&#10;    me_speed = to_compute_speed(me_ctx)&#10;    opp_speed = to_compute_speed(opp_ctx)&#10;&#10;    # Moves&#10;    u_move = _to_move_ctx_for_order(my_move_id, me, opp, state.field, mi)&#10;    o_move = _to_move_ctx_for_order(opp_move_id, opp, me, state.field, mi)&#10;&#10;&#10;    # Custap Berry precedence: set flags on contexts so turn_order can read them via move_ctx&#10;    try:&#10;        me_ctx.hp = int(me.current_hp or 0); me_ctx.max_hp = int(me.max_hp or 0)&#10;        opp_ctx.hp = int(opp.current_hp or 0); opp_ctx.max_hp = int(opp.max_hp or 0)&#10;    except Exception:&#10;        pass&#10;    me_ctx.custap_active = ((str(me.item or '').lower() == 'custapberry') and not me_ctx.magic_room_active and me_ctx.max_hp and me_ctx.hp * 4 &lt;= me_ctx.max_hp)&#10;    opp_ctx.custap_active = ((str(opp.item or '').lower() == 'custapberry') and not opp_ctx.magic_room_active and opp_ctx.max_hp and opp_ctx.hp * 4 &lt;= opp_ctx.max_hp)&#10;&#10;    pred = to_predict_order(&#10;        me_speed, opp_speed,&#10;        TO_Action(kind=&quot;move&quot;, move=u_move),&#10;        TO_Action(kind=&quot;move&quot;, move=o_move),&#10;        me_ctx, opp_ctx,&#10;        (me.ability or &quot;&quot;).lower(), (me.item or &quot;&quot;).lower() if me.item else None,&#10;        (opp.ability or &quot;&quot;).lower(), (opp.item or &quot;&quot;).lower() if opp.item else None,&#10;    )&#10;&#10;    details = {&#10;        &quot;user_effective_speed&quot;: me_speed,&#10;        &quot;opp_effective_speed&quot;: opp_speed,&#10;        &quot;user_bracket&quot;: pred.bracket_user,&#10;        &quot;opp_bracket&quot;: pred.bracket_opp,&#10;        &quot;notes&quot;: pred.notes,&#10;    }&#10;    return float(pred.user_first_probability), details&#10;&#10;# ------------------------------ Damage -------------------------------------------&#10;&#10;def _apply_stat_side_modifiers(&#10;    pinfo: PokemonInfo, ps: PokemonState, *, for_attacker: bool, field: Optional[EnvFieldState] = None&#10;) -&gt; Tuple[int,int,int,int,int,int]:&#10;    &quot;&quot;&quot;Return modified (hp, atk, def, spa, spd, spe) after item+ability passive stat multipliers.&quot;&quot;&quot;&#10;    base = (ps.stats.raw[&quot;hp&quot;], ps.stats.raw[&quot;atk&quot;], ps.stats.raw[&quot;def&quot;], ps.stats.raw[&quot;spa&quot;], ps.stats.raw[&quot;spd&quot;], ps.stats.raw[&quot;spe&quot;])&#10;&#10;    # Item-side mods (Choice/Eviolite/AV/etc)&#10;    from .poke_env_pokemon_info import apply_item_stat_modifiers, PokemonStats&#10;    it_applied = apply_item_stat_modifiers(pinfo, ps.species, ps.item, PokemonStats(*base))&#10;    hp, atk, deff, spa, spd, spe = it_applied.hp, it_applied.atk, it_applied.def_, it_applied.spa, it_applied.spd, it_applied.spe&#10;&#10;    # Ability passives (Huge Power/Guts/etc) -&gt; only stat-side ones here&#10;    mults = compute_passive_multipliers(ps, {&quot;weather&quot;: field.weather if field else None})&#10;    # The helper above expects a field dict; we pass a conservative context (weather only).&#10;    # Apply multipliers to the relevant stats:&#10;    atk = int(atk * mults.get(&quot;atk&quot;, 1.0))&#10;    deff = int(deff * mults.get(&quot;def&quot;, 1.0))&#10;    spa = int(spa * mults.get(&quot;spa&quot;, 1.0))&#10;    spd = int(spd * mults.get(&quot;spd&quot;, 1.0))&#10;    spe = int(spe * mults.get(&quot;spe&quot;, 1.0))&#10;&#10;    return hp, atk, deff, spa, spd, spe&#10;&#10;def _combatant_from_state(&#10;    ps: PokemonState,&#10;    pinfo: PokemonInfo,&#10;    *,&#10;    apply_stat_mods: bool = True,&#10;    field: Optional[EnvFieldState] = None&#10;) -&gt; DMG_Combatant:&#10;    if apply_stat_mods:&#10;        hp, atk, deff, spa, spd, spe = _apply_stat_side_modifiers(pinfo, ps, for_attacker=True, field=field)&#10;    else:&#10;        hp, atk, deff, spa, spd, spe = (ps.stats.raw[&quot;hp&quot;], ps.stats.raw[&quot;atk&quot;], ps.stats.raw[&quot;def&quot;], ps.stats.raw[&quot;spa&quot;], ps.stats.raw[&quot;spd&quot;], ps.stats.raw[&quot;spe&quot;])&#10;&#10;    return DMG_Combatant(&#10;        level=int(ps.stats.level),&#10;        types=[t.capitalize() for t in ps.types if t],&#10;        atk=atk, def_=deff, spa=spa, spd=spd, spe=spe,&#10;        tera_type=ps.tera_type.capitalize() if ps.tera_type else None,&#10;        grounded=bool(ps.grounded if ps.grounded is not None else True),&#10;        is_burned=(ps.status == &quot;brn&quot;),&#10;        ability=(ps.ability or None),&#10;        item=(ps.item or None),&#10;        atk_stage=int(ps.stats.boosts.get(&quot;atk&quot;, 0)),&#10;        def_stage=int(ps.stats.boosts.get(&quot;def&quot;, 0)),&#10;        spa_stage=int(ps.stats.boosts.get(&quot;spa&quot;, 0)),&#10;        spd_stage=int(ps.stats.boosts.get(&quot;spd&quot;, 0)),&#10;        spe_stage=int(ps.stats.boosts.get(&quot;spe&quot;, 0)),&#10;    )&#10;&#10;def _dm_field_from_env_field(field: EnvFieldState) -&gt; DMG_Field:&#10;    return DMG_Field(&#10;        weather=field.weather, terrain=field.terrain, gravity=field.gravity, trick_room=field.trick_room,&#10;        is_doubles=field.is_doubles, targets_on_target_side=field.targets_on_target_side,&#10;        reflect=field.reflect, light_screen=field.light_screen, aurora_veil=field.aurora_veil&#10;    )&#10;&#10;def estimate_damage(&#10;    state: CombinedState,&#10;    attacker_key: str,&#10;    defender_key: str,&#10;    move_id: str,&#10;    mi: Optional[MovesInfo] = None,&#10;    *,&#10;    is_critical: bool = False,&#10;) -&gt; Dict[str, Any]:&#10;    mi = mi or MovesInfo(state.format or 9)&#10;    pinfo = PokemonInfo(9)&#10;    atk = state.team.ours.get(attacker_key) or state.team.opponent.get(attacker_key)&#10;    dfd = state.team.ours.get(defender_key) or state.team.opponent.get(defender_key)&#10;    if atk is None or dfd is None:&#10;        raise KeyError(&quot;Unknown attacker or defender key.&quot;)&#10;&#10;    # Build combatants&#10;    c_atk = _combatant_from_state(atk, pinfo, apply_stat_mods=True, field=state.field)&#10;    c_dfd = _combatant_from_state(dfd, pinfo, apply_stat_mods=True, field=state.field)&#10;&#10;    # Build move&#10;    mi = mi or MovesInfo(state.format or 9)&#10;    raw = mi.get(move_id)&#10;    mv = DMG_Move(&#10;        move_id=raw.id,&#10;        name=raw.name,&#10;        type=str(raw.type or &quot;Unknown&quot;),&#10;        category=str(raw.category or &quot;Status&quot;).capitalize(),&#10;        base_power=int(raw.base_power or 0),&#10;        is_spread=(raw.target in {&quot;allAdjacent&quot;, &quot;allAdjacentFoes&quot;, &quot;all&quot;}),&#10;        hits_multiple_targets_on_execution=(state.field.is_doubles and raw.target in {&quot;allAdjacent&quot;, &quot;allAdjacentFoes&quot;, &quot;all&quot;}),&#10;        makes_contact=bool(raw.flags.get(&quot;contact&quot;, False)),&#10;        is_sound=bool(raw.flags.get(&quot;sound&quot;, False)),&#10;        is_punch=bool(raw.flags.get(&quot;punch&quot;, False)),&#10;        is_biting=bool(raw.flags.get(&quot;bite&quot;, False)),&#10;        multihit=(raw.multihit if isinstance(raw.multihit, list) else None),&#10;    )&#10;    # Adjust contact if Punching Glove (boost applied later) removes contact&#10;    if (atk.item or '').lower() == 'punchingglove' and mv.is_punch:&#10;        mv.makes_contact = False  # negate contact interactions&#10;&#10;    # Type chart and helpers&#10;    chart_fn = mi.get_type_chart&#10;    dmg_field = _dm_field_from_env_field(state.field)&#10;&#10;    # Extra modifiers (Life Orb, Expert Belt, Muscle Band, Wise Glasses, type boosters, Technician, Sheer Force)&#10;    extra: List[float] = []&#10;    it = (atk.item or &quot;&quot;).lower() if atk.item else &quot;&quot;&#10;    ability = (atk.ability or '').lower()&#10;    mv_type = (mv.type or '').lower()&#10;    category = (mv.category or '').lower()&#10;    base_power = mv.base_power or 0&#10;&#10;    # Life Orb&#10;    if it == &quot;lifeorb&quot;:&#10;        extra.append(1.3)&#10;    # Expert Belt (only if SE hit -&gt; we append later conditionally)&#10;    expert_belt = it == 'expertbelt'&#10;    # Muscle Band / Wise Glasses&#10;    if it == 'muscleband' and category == 'physical':&#10;        extra.append(1.1)&#10;    if it == 'wiseglasses' and category == 'special':&#10;        extra.append(1.1)&#10;    # Type boosting items&#10;    if it in _BOOST_ITEMS_TYPE:&#10;        mult, t = _BOOST_ITEMS_TYPE[it]&#10;        if t == mv_type:&#10;            extra.append(mult)&#10;    # Technician&#10;    if ability == 'technician' and base_power and base_power &lt;= 60:&#10;        extra.append(1.5)&#10;    # Sheer Force (approx power mod 1.3 if move has a secondary effect)&#10;    if ability == 'sheerforce':&#10;        try:&#10;            if raw.raw.get('secondary') or raw.raw.get('secondaries'):&#10;                extra.append(1.3)&#10;        except Exception:&#10;            pass&#10;    # Tough Claws (contact physical damaging moves)&#10;    if ability == 'toughclaws' and mv.makes_contact and category in {'physical'}:&#10;        extra.append(1.3)&#10;    # Iron Fist (punching moves)&#10;    if ability == 'ironfist' and mv.is_punch:&#10;        extra.append(1.2)&#10;    # Strong Jaw (biting moves)&#10;    if ability == 'strongjaw' and mv.is_biting:&#10;        extra.append(1.5)&#10;    # Sharpness (slicing flag in move data)&#10;    try:&#10;        if ability == 'sharpness' and raw.flags.get('slicing', False):&#10;            extra.append(1.5)&#10;    except Exception:&#10;        pass&#10;    # Punk Rock (sound moves offensive boost)&#10;    if ability == 'punkrock' and mv.is_sound and category in {'physical','special'}:&#10;        extra.append(1.3)&#10;    # Reckless (recoil moves power boost)&#10;    try:&#10;        if ability == 'reckless' and (raw.raw.get('recoil') or raw.raw.get('hasCrashDamage')):&#10;            extra.append(1.2)&#10;    except Exception:&#10;        pass&#10;    # Punching Glove boost (already removed contact, boosts punch moves)&#10;    if it == 'punchingglove' and mv.is_punch:&#10;        extra.append(1.1)&#10;    # Guts handled in passive multipliers, Adaptability in STAB, Hustle in passive.&#10;&#10;    # Wrap type effectiveness for Tinted Lens &amp; Expert Belt conditional application&#10;    def _type_eff(move_type: str, defender_types, type_chart, move_id=None):&#10;        eff = type_effectiveness(move_type, defender_types, type_chart, move_id=move_id)&#10;        if ability == 'tintedlens' and eff &lt; 1.0:&#10;            eff *= 2.0&#10;        # Expert Belt conditional (only if SE &gt;1 after tint lens)&#10;        if expert_belt and eff &gt; 1.0:&#10;            eff *= 1.2&#10;        return eff&#10;&#10;    res = calc_damage_range(&#10;        c_atk, c_dfd, mv, dmg_field,&#10;        get_type_chart=chart_fn,&#10;        is_critical=is_critical,&#10;        extra_modifiers=extra,&#10;        type_effectiveness_fn=_type_eff,&#10;        stab_fn=stab_multiplier,&#10;        weather_fn=weather_modifier,&#10;        terrain_fn=terrain_modifier,&#10;        screen_fn=screen_modifier,&#10;    )&#10;    out = {&#10;        &quot;min&quot;: res.min_damage,&#10;        &quot;max&quot;: res.max_damage,&#10;        &quot;rolls&quot;: res.rolls,&#10;        &quot;effectiveness&quot;: res.effectiveness,&#10;        &quot;mods&quot;: res.applied_modifiers,&#10;    }&#10;    if os.getenv('POKECHAD_DEBUG_TYPES'):&#10;        out.update({&#10;            'attacker_species': atk.species,&#10;            'attacker_types': c_atk.types,&#10;            'defender_species': dfd.species,&#10;            'defender_types': c_dfd.types,&#10;            'move_type': mv.type,&#10;            'move_id': mv.move_id,&#10;        })&#10;    return out&#10;&#10;# ------------------------- Switch-in effects -------------------------------------&#10;&#10;def apply_switch_in_effects(&#10;    state: CombinedState,&#10;    switch_in_key: str,&#10;    side: str,&#10;    mi: Optional[MovesInfo] = None,&#10;    *,&#10;    mutate: bool = False,&#10;) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Apply hazards + Sticky Web + entry status logic (prediction helper).&quot;&quot;&quot;&#10;    mi = mi or MovesInfo(state.format or 9)&#10;    type_chart = mi.get_type_chart()&#10;    ps = state.team.ours.get(switch_in_key) if side == &quot;ally&quot; else state.team.opponent.get(switch_in_key)&#10;    if ps is None:&#10;        raise KeyError(f&quot;Unknown key on side {side}: {switch_in_key}&quot;)&#10;    field_dict = {&quot;gravity&quot;: state.field.gravity, &quot;terrain&quot;: state.field.terrain}&#10;&#10;    # Pick the *opponent* side hazards relative to the switching-in Pokémon&#10;    side_obj = type(&quot;Side&quot;, (), {})()&#10;    opp_side_dict = state.opp_side if side == &quot;ally&quot; else state.my_side&#10;    for k in (&quot;stealth_rock&quot;,&quot;spikes&quot;,&quot;toxic_spikes&quot;,&quot;sticky_web&quot;):&#10;        setattr(side_obj, k, opp_side_dict.get(k, 0 if k in (&quot;spikes&quot;,&quot;toxic_spikes&quot;) else False))&#10;&#10;    # Apply&#10;    out = apply_entry_hazards_on_switch_in(ps, side_obj, field_dict, type_chart, mutate=mutate)&#10;    return out&#10;&#10;# ------------------------- Move failure checks -----------------------------------&#10;&#10;_PROTECTIVES = {&quot;protect&quot;,&quot;kingsshield&quot;,&quot;spikyshield&quot;,&quot;banefulbunker&quot;,&quot;obstruct&quot;,&quot;silktrap&quot;,&quot;maxguard&quot;}&#10;_BYPASS_PROTECT_IDS = {&quot;feint&quot;,&quot;hyperspacefury&quot;,&quot;hyperspacehole&quot;,&quot;phantomforce&quot;,&quot;shadowforce&quot;}&#10;&#10;def _effective_priority_for_blockers(raw_move, user_ps: PokemonState, field: EnvFieldState) -&gt; int:&#10;    # Base&#10;    pri = int(raw_move.priority or 0)&#10;    # Grassy Glide +1 in Grassy Terrain&#10;    if raw_move.id == &quot;grassyglide&quot; and str(field.terrain or &quot;&quot;) == &quot;grassy&quot;:&#10;        pri += 1&#10;    # Prankster to Status +1&#10;    if (user_ps.ability or &quot;&quot;).lower() == &quot;prankster&quot; and (raw_move.category or &quot;&quot;).lower() == &quot;status&quot;:&#10;        pri += 1&#10;    # Triage +3 to healing&#10;    if raw_move.raw.get(&quot;heal&quot;) or raw_move.raw.get(&quot;drain&quot;):&#10;        if (user_ps.ability or &quot;&quot;).lower() == &quot;triage&quot;:&#10;            pri += 3&#10;    # Gale Wings +1 to Flying moves at full HP&#10;    if (user_ps.ability or &quot;&quot;).lower() == &quot;galewings&quot; and (raw_move.type or &quot;&quot;).lower() == &quot;flying&quot;        and (user_ps.current_hp or 0) &gt;= (user_ps.max_hp or 0):&#10;        pri += 1&#10;    return pri&#10;&#10;def would_fail(&#10;    move_id: str,&#10;    user_key: str,&#10;    target_key: str,&#10;    state: CombinedState,&#10;    mi: MovesInfo&#10;) -&gt; Tuple[bool, str]:&#10;    &quot;&quot;&quot;Best-effort &quot;would fail&quot; gate for Protect/Quick Guard/Wide Guard/Psychic Terrain/priority blocks.&#10;&#10;    NOTE: This does not resolve dynamic outcomes like Sucker Punch failing or niche exceptions like&#10;    Instruct, Immunity gating, etc. It's aimed at the high-impact gating for planning.&#10;    &quot;&quot;&quot;&#10;    user = state.team.ours.get(user_key) or state.team.opponent.get(user_key)&#10;    target = state.team.ours.get(target_key) or state.team.opponent.get(target_key)&#10;    if user is None or target is None:&#10;        return False, &quot;unknown-actors&quot;&#10;&#10;    mi = mi or MovesInfo(state.format or 9)&#10;    raw = mi.get(move_id)&#10;    cat = (raw.category or &quot;Status&quot;).lower()&#10;    is_damaging = cat in {&quot;physical&quot;,&quot;special&quot;}&#10;&#10;    # 1) Direct Protect family on target&#10;    if _PROTECTIVES &amp; set(target.volatiles):&#10;        if raw.id in _BYPASS_PROTECT_IDS or raw.raw.get(&quot;breaksProtect&quot;) or raw.raw.get(&quot;bypassProtect&quot;):&#10;            return False, &quot;bypasses-protect&quot;&#10;        if raw.flags.get(&quot;protect&quot;, True):&#10;            return True, &quot;blocked-by-protect&quot;&#10;&#10;    # 2) Psychic Terrain (blocks priority from grounded attackers hitting grounded targets)&#10;    if str(state.field.terrain or &quot;&quot;) == &quot;psychic&quot;:&#10;        # We need groundedness for both&#10;        if user.grounded is None: augment_grounded(user, {&quot;gravity&quot;: state.field.gravity})&#10;        if target.grounded is None: augment_grounded(target, {&quot;gravity&quot;: state.field.gravity})&#10;        pri = _effective_priority_for_blockers(raw, user, state.field)&#10;        if pri &gt; 0 and user.grounded and target.grounded:&#10;            # Dazzling/Queenly also block priority at target ability&#10;            return True, &quot;blocked-by-psychic-terrain&quot;&#10;&#10;    # 3) Priority blockers at target: Dazzling / Queenly Majesty / Armor Tail&#10;    if is_damaging:&#10;        if target.has_priority_block:&#10;            pri = _effective_priority_for_blockers(raw, user, state.field)&#10;            if pri &gt; 0:&#10;                return True, &quot;blocked-by-priority-ability&quot;&#10;&#10;    # 4) Quick Guard on target side blocks all +priority moves (damaging or status)&#10;    if state.opp_side.get(&quot;quick_guard&quot;, False) and user_key in state.team.ours:&#10;        pri = _effective_priority_for_blockers(raw, user, state.field)&#10;        if pri &gt; 0:&#10;            if raw.id != &quot;feint&quot;:&#10;                return True, &quot;blocked-by-quick-guard&quot;&#10;    if state.my_side.get(&quot;quick_guard&quot;, False) and user_key in state.team.opponent:&#10;        pri = _effective_priority_for_blockers(raw, user, state.field)&#10;        if pri &gt; 0:&#10;            if raw.id != &quot;feint&quot;:&#10;                return True, &quot;blocked-by-quick-guard&quot;&#10;&#10;    # 5) Wide Guard on target side vs spread damaging move&#10;    targets_spread = raw.target in {&quot;allAdjacent&quot;,&quot;allAdjacentFoes&quot;,&quot;all&quot;}&#10;    if state.opp_side.get(&quot;wide_guard&quot;, False) and user_key in state.team.ours:&#10;        if is_damaging and targets_spread and raw.id != &quot;feint&quot;:&#10;            return True, &quot;blocked-by-wide-guard&quot;&#10;    if state.my_side.get(&quot;wide_guard&quot;, False) and user_key in state.team.opponent:&#10;        if is_damaging and targets_spread and raw.id != &quot;feint&quot;:&#10;            return True, &quot;blocked-by-wide-guard&quot;&#10;&#10;    # 6) Prankster vs Dark: status move boosted by Prankster fails on Dark-type targets&#10;    if (user.ability or &quot;&quot;).lower() == &quot;prankster&quot; and cat == &quot;status&quot; and (&quot;dark&quot; in {t for t in target.types if t}):&#10;        return True, &quot;prankster-vs-dark&quot;&#10;&#10;    # Heal Bell / Aromatherapy futility (Showdown: fails if no party member would be cured)&#10;    try:&#10;        if raw.id in {&quot;healbell&quot;,&quot;aromatherapy&quot;}:&#10;            side_dict = state.team.ours if user_key in state.team.ours else state.team.opponent&#10;            has_curable = False&#10;            for pk in side_dict.values():&#10;                st = (pk.status or '').lower()&#10;                if st and st not in {&quot;fnt&quot;, &quot;&quot;, &quot;none&quot;}:&#10;                    has_curable = True; break&#10;            if not has_curable:&#10;                return True, &quot;no-status-to-heal&quot;&#10;    except Exception:&#10;        pass&#10;    # Recovery at full HP (simple heuristic) – treat purely healing moves as futile&#10;    try:&#10;        if (raw.raw.get('heal') or raw.id in {&quot;recover&quot;,&quot;softboiled&quot;,&quot;roost&quot;,&quot;morningsun&quot;,&quot;synthesis&quot;,&quot;slackoff&quot;,&quot;milkdrink&quot;,&quot;shoreup&quot;,&quot;strengthsap&quot;}) and (user.current_hp is not None) and (user.max_hp is not None) and user.current_hp &gt;= user.max_hp:&#10;            return True, &quot;full-hp&quot;&#10;    except Exception:&#10;        pass&#10;    # Thunder Wave basic immunities / redundancy&#10;    try:&#10;        if raw.id == &quot;thunderwave&quot;:&#10;            tgt_status = (target.status or '').lower()&#10;            if tgt_status and tgt_status not in {&quot;fnt&quot;,&quot;&quot;,&quot;none&quot;}:&#10;                return True, &quot;target-already-statused&quot;&#10;            tgt_types = {t for t in target.types if t}&#10;            if 'electric' in tgt_types or 'ground' in tgt_types:&#10;                return True, &quot;immune-thunder-wave&quot;&#10;            # Safeguard check&#10;            side_has_safeguard = (state.opp_side.get('safeguard') if user_key in state.team.ours else state.my_side.get('safeguard'))&#10;            if side_has_safeguard:&#10;                return True, &quot;blocked-by-safeguard&quot;&#10;    except Exception:&#10;        pass&#10;    # Will-O-Wisp immunities / redundancy&#10;    try:&#10;        if raw.id == &quot;willowisp&quot;:&#10;            tgt_status = (target.status or '').lower()&#10;            if tgt_status and tgt_status not in {&quot;fnt&quot;,&quot;&quot;,&quot;none&quot;}:&#10;                return True, &quot;target-already-statused&quot;&#10;            tgt_types = {t for t in target.types if t}&#10;            if 'fire' in tgt_types:&#10;                return True, &quot;immune-wisp&quot;&#10;            side_has_safeguard = (state.opp_side.get('safeguard') if user_key in state.team.ours else state.my_side.get('safeguard'))&#10;            if side_has_safeguard:&#10;                return True, &quot;blocked-by-safeguard&quot;&#10;    except Exception:&#10;        pass&#10;    # Toxic immunities / redundancy (ignore Toxic Spikes etc.)&#10;    try:&#10;        if raw.id == &quot;toxic&quot; or raw.id == &quot;poisonpowder&quot;:&#10;            tgt_status = (target.status or '').lower()&#10;            if tgt_status and tgt_status not in {&quot;fnt&quot;,&quot;&quot;,&quot;none&quot;}:&#10;                return True, &quot;target-already-statused&quot;&#10;            tgt_types = {t for t in target.types if t}&#10;            if 'steel' in tgt_types or 'poison' in tgt_types:&#10;                return True, &quot;immune-toxic&quot;&#10;            side_has_safeguard = (state.opp_side.get('safeguard') if user_key in state.team.ours else state.my_side.get('safeguard'))&#10;            if side_has_safeguard:&#10;                return True, &quot;blocked-by-safeguard&quot;&#10;    except Exception:&#10;        pass&#10;    return False, &quot;ok&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Data/dex_registry.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/dex_registry.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;dex_registry.py&#10;Central lightweight registry wrapping the raw Showdown JS / JSON data files&#10;(abilities, items, moves) so that battle logic can access richer passive data&#10;without re-parsing each time.&#10;&#10;Loads from the first existing directory among (relative to project root):&#10;  - showdown/&#10;  - Resources/showdown/&#10;  - tools/Data/showdown/&#10;&#10;Provides helper functions:&#10;  get_item(id) -&gt; dict | None&#10;  get_ability(id) -&gt; dict | None&#10;  get_move(id) -&gt; dict | None&#10;&#10;All ids are normalized with _to_id (lowercase alphanumerics only).&#10;&#10;We intentionally keep parsing extremely simple: JS exports are parsed via the&#10;existing ps_data_loader when possible; otherwise we fall back to the local&#10;loader here.&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;&#10;from functools import lru_cache&#10;import os, json, re&#10;from typing import Dict, Any, Optional&#10;&#10;_DEF_DIR_CANDIDATES = [&#10;    os.path.join(os.getcwd(), 'showdown'),&#10;    os.path.join(os.getcwd(), 'Resources', 'showdown'),&#10;    os.path.join(os.getcwd(), 'tools', 'Data', 'showdown'),&#10;]&#10;&#10;_ID_RX = re.compile(r&quot;[^a-z0-9]&quot;)&#10;&#10;def _to_id(s: str) -&gt; str:&#10;    return _ID_RX.sub('', (s or '').lower())&#10;&#10;def _strip_js_comments(src: str) -&gt; str:&#10;    src = re.sub(r&quot;/\*.*?\*/&quot;, &quot;&quot;, src, flags=re.S)&#10;    src = re.sub(r&quot;(^|\s)//.*?$&quot;, r&quot;\1&quot;, src, flags=re.M)&#10;    return src&#10;&#10;def _parse_js_object_literal(text: str) -&gt; Dict[str, Any]:&#10;    # Extract the last object literal assignment&#10;    m = re.search(r&quot;=\s*({.*})\s*;?\s*$&quot;, text, flags=re.S)&#10;    if not m:&#10;        m = re.search(r&quot;({.*})\s*;?\s*$&quot;, text, flags=re.S)&#10;    if not m:&#10;        return {}&#10;    obj = m.group(1)&#10;    obj = re.sub(r&quot;,(\s*[}\]])&quot;, r&quot;\1&quot;, obj)  # trailing commas&#10;    # quote bare keys safely&#10;    obj = re.sub(r'([:{,]\s*)([A-Za-z0-9_]+)\s*:', r'\1&quot;\2&quot;:', obj)&#10;    try:&#10;        data = json.loads(obj)&#10;    except Exception:&#10;        return {}&#10;    return { _to_id(k): v for k, v in data.items() }&#10;&#10;@lru_cache(maxsize=1)&#10;def _load_all() -&gt; Dict[str, Dict[str, Any]]:&#10;    root = None&#10;    for cand in _DEF_DIR_CANDIDATES:&#10;        if os.path.isdir(cand):&#10;            root = cand&#10;            break&#10;    if root is None:&#10;        return {'items': {}, 'abilities': {}, 'moves': {}}&#10;&#10;    def load_json(name: str) -&gt; Dict[str, Any]:&#10;        p = os.path.join(root, name)&#10;        if not os.path.isfile(p):&#10;            return {}&#10;        try:&#10;            with open(p, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;            if isinstance(data, dict):&#10;                return { _to_id(k): v for k, v in data.items() }&#10;            return {}&#10;        except Exception:&#10;            return {}&#10;&#10;    def load_js(name: str) -&gt; Dict[str, Any]:&#10;        p = os.path.join(root, name)&#10;        if not os.path.isfile(p):&#10;            return {}&#10;        try:&#10;            with open(p, 'r', encoding='utf-8') as f:&#10;                txt = _strip_js_comments(f.read())&#10;            return _parse_js_object_literal(txt)&#10;        except Exception:&#10;            return {}&#10;&#10;    # Try both js and json variants&#10;    items = load_js('items.js') or load_json('items.json')&#10;    abilities = load_js('abilities.js') or load_json('abilities.json')&#10;    moves = load_json('moves.json') or load_js('moves.js')  # moves.json usually large&#10;&#10;    return {'items': items, 'abilities': abilities, 'moves': moves}&#10;&#10;# Public API&#10;&#10;def get_item(item_id: str) -&gt; Optional[Dict[str, Any]]:&#10;    d = _load_all()['items']&#10;    return d.get(_to_id(item_id))&#10;&#10;def get_ability(ability_id: str) -&gt; Optional[Dict[str, Any]]:&#10;    d = _load_all()['abilities']&#10;    return d.get(_to_id(ability_id))&#10;&#10;def get_move(move_id: str) -&gt; Optional[Dict[str, Any]]:&#10;    d = _load_all()['moves']&#10;    return d.get(_to_id(move_id))&#10;&#10;def has_data() -&gt; bool:&#10;    data = _load_all()&#10;    return bool(data['items'] or data['abilities'] or data['moves'])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Data/poke_env_battle_environment.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/poke_env_battle_environment.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Pokemon environment battle integration module&#10;---------------------------------------------&#10;This wraps a poke-env `Battle` object into a compact, serializable snapshot and a&#10;`FieldState` suitable for the damage calculator.&#10;&#10;We purposely avoid importing poke-env at module import time. The functions will&#10;use duck-typing against a `Battle` object at runtime.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass, asdict&#10;from typing import Any, Dict, List, Optional, Tuple&#10;&#10;# We mirror the calculator's light FieldState to avoid circular imports.&#10;@dataclass&#10;class FieldState:&#10;    weather: Optional[str] = None&#10;    terrain: Optional[str] = None&#10;    gravity: bool = False&#10;    trick_room: bool = False&#10;    is_doubles: bool = False&#10;    targets_on_target_side: int = 1&#10;    reflect: bool = False&#10;    light_screen: bool = False&#10;    aurora_veil: bool = False&#10;&#10;&#10;def _safe_lower(x: Any) -&gt; Optional[str]:&#10;    return x.lower() if isinstance(x, str) else None&#10;&#10;&#10;def _extract_side_conditions(side) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Best-effort extraction of hazards/screens from a poke-env Side object.&quot;&quot;&quot;&#10;    out = {&#10;        &quot;stealth_rock&quot;: False,&#10;        &quot;spikes&quot;: 0,&#10;        &quot;toxic_spikes&quot;: 0,&#10;        &quot;sticky_web&quot;: False,&#10;        &quot;reflect&quot;: False,&#10;        &quot;light_screen&quot;: False,&#10;        &quot;aurora_veil&quot;: False,&#10;        &quot;tailwind&quot;: False,&#10;        &quot;safeguard&quot;: False,&#10;        &quot;mist&quot;: False,&#10;    }&#10;    if side is None:&#10;        return out&#10;&#10;    # poke-env represents side conditions via enums/sets; we use getattr defensively.&#10;    sconds = getattr(side, &quot;conditions&quot;, None) or getattr(side, &quot;side_conditions&quot;, None)&#10;    if isinstance(sconds, dict):&#10;        # Newer poke-env stores counts for stackables&#10;        out[&quot;stealth_rock&quot;] = bool(sconds.get(&quot;STEALTH_ROCK&quot;) or sconds.get(&quot;Stealth Rock&quot;))&#10;        out[&quot;spikes&quot;] = int(sconds.get(&quot;SPIKES&quot;) or sconds.get(&quot;Spikes&quot;) or 0)&#10;        out[&quot;toxic_spikes&quot;] = int(sconds.get(&quot;TOXIC_SPIKES&quot;) or sconds.get(&quot;Toxic Spikes&quot;) or 0)&#10;        out[&quot;sticky_web&quot;] = bool(sconds.get(&quot;STICKY_WEB&quot;) or sconds.get(&quot;Sticky Web&quot;))&#10;        out[&quot;reflect&quot;] = bool(sconds.get(&quot;REFLECT&quot;) or sconds.get(&quot;Reflect&quot;))&#10;        out[&quot;light_screen&quot;] = bool(sconds.get(&quot;LIGHT_SCREEN&quot;) or sconds.get(&quot;Light Screen&quot;))&#10;        out[&quot;aurora_veil&quot;] = bool(sconds.get(&quot;AURORA_VEIL&quot;) or sconds.get(&quot;Aurora Veil&quot;))&#10;        out[&quot;tailwind&quot;] = bool(sconds.get(&quot;TAILWIND&quot;) or sconds.get(&quot;Tailwind&quot;))&#10;        out[&quot;safeguard&quot;] = bool(sconds.get(&quot;SAFEGUARD&quot;) or sconds.get(&quot;Safeguard&quot;))&#10;        out[&quot;mist&quot;] = bool(sconds.get(&quot;MIST&quot;) or sconds.get(&quot;Mist&quot;))&#10;    else:&#10;        # Very old poke-env&#10;        for name in (&quot;Stealth Rock&quot;, &quot;Spikes&quot;, &quot;Toxic Spikes&quot;, &quot;Sticky Web&quot;,&#10;                     &quot;Reflect&quot;, &quot;Light Screen&quot;, &quot;Aurora Veil&quot;, &quot;Tailwind&quot;, &quot;Safeguard&quot;, &quot;Mist&quot;):&#10;            val = getattr(side, name.replace(&quot; &quot;, &quot;_&quot;).lower(), None)&#10;            if isinstance(val, bool):&#10;                out[name.replace(&quot; &quot;, &quot;_&quot;).lower()] = val&#10;    return out&#10;&#10;&#10;def to_field_state(battle) -&gt; FieldState:&#10;    &quot;&quot;&quot;Convert a poke-env Battle to our FieldState.&quot;&quot;&quot;&#10;    # Weather / terrain are enums or strings; coerce to lowercase keys&#10;    w = getattr(battle, &quot;weather&quot;, None)&#10;    weather = getattr(w, &quot;name&quot;, w)&#10;    t = getattr(battle, &quot;terrain&quot;, None)&#10;    terrain = getattr(t, &quot;name&quot;, t)&#10;&#10;    # Side conditions&#10;    my_side = getattr(battle, &quot;side_conditions&quot;, None) or getattr(battle, &quot;side&quot;, None)&#10;    opp_side = getattr(battle, &quot;opponent_side_conditions&quot;, None) or getattr(battle, &quot;opponent_side&quot;, None)&#10;&#10;    my = _extract_side_conditions(my_side)&#10;    opp = _extract_side_conditions(opp_side)&#10;&#10;    # Active target count for doubles (rough estimate: 2 if both active; else 1)&#10;    is_doubles = bool(getattr(battle, &quot;is_doubles&quot;, False) or getattr(battle, &quot;double_battle&quot;, False))&#10;    targets_on_target_side = 2 if (is_doubles and len(getattr(battle, &quot;opponent_active_pokemon&quot;, []) or []) == 2) else 1&#10;&#10;    # Screens are on defender's side; we return defender=opp by default for convenience&#10;    return FieldState(&#10;        weather=_safe_lower(weather),&#10;        terrain=_safe_lower(terrain),&#10;        trick_room=bool(getattr(battle, &quot;trick_room&quot;, False)),&#10;        gravity=bool(getattr(battle, &quot;gravity&quot;, False)),&#10;        is_doubles=is_doubles,&#10;        targets_on_target_side=targets_on_target_side,&#10;        reflect=opp[&quot;reflect&quot;],&#10;        light_screen=opp[&quot;light_screen&quot;],&#10;        aurora_veil=opp[&quot;aurora_veil&quot;],&#10;    )&#10;&#10;&#10;def snapshot(battle) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Dump a serializable, RL-friendly snapshot of a poke-env Battle.&#10;&#10;    This intentionally includes both IDs and human-readable names for stability.&#10;    &quot;&quot;&quot;&#10;    s = {&#10;        &quot;battle_tag&quot;: getattr(battle, &quot;battle_tag&quot;, &quot;&quot;),&#10;        &quot;format&quot;: getattr(battle, &quot;format&quot;, None),&#10;        &quot;turn&quot;: getattr(battle, &quot;turn&quot;, None),&#10;        &quot;weather&quot;: _safe_lower(getattr(getattr(battle, &quot;weather&quot;, None), &quot;name&quot;, None)),&#10;        &quot;terrain&quot;: _safe_lower(getattr(getattr(battle, &quot;terrain&quot;, None), &quot;name&quot;, None)),&#10;        &quot;trick_room&quot;: bool(getattr(battle, &quot;trick_room&quot;, False)),&#10;        &quot;gravity&quot;: bool(getattr(battle, &quot;gravity&quot;, False)),&#10;        &quot;is_doubles&quot;: bool(getattr(battle, &quot;is_doubles&quot;, False) or getattr(battle, &quot;double_battle&quot;, False)),&#10;        &quot;my_team&quot;: {},&#10;        &quot;opp_team&quot;: {},&#10;        &quot;active_moves_ids&quot;: [],&#10;        &quot;active_switch_ids&quot;: [],&#10;        &quot;force_switch&quot;: bool(getattr(battle, &quot;force_switch&quot;, False)),&#10;        &quot;can_tera&quot;: bool(getattr(battle, &quot;can_tera&quot;, False)),&#10;        &quot;side_conditions&quot;: _extract_side_conditions(getattr(battle, &quot;side_conditions&quot;, None) or getattr(battle, &quot;side&quot;, None)),&#10;        &quot;opp_side_conditions&quot;: _extract_side_conditions(getattr(battle, &quot;opponent_side_conditions&quot;, None) or getattr(battle, &quot;opponent_side&quot;, None)),&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Pokemon environment battle integration module&#10;---------------------------------------------&#10;This wraps a poke-env `Battle` object into a compact, serializable snapshot and a&#10;`FieldState` suitable for the damage calculator.&#10;&#10;We purposely avoid importing poke-env at module import time. The functions will&#10;use duck-typing against a `Battle` object at runtime.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass, asdict&#10;from typing import Any, Dict, List, Optional, Tuple&#10;&#10;# We mirror the calculator's light FieldState to avoid circular imports.&#10;@dataclass&#10;class FieldState:&#10;    weather: Optional[str] = None&#10;    terrain: Optional[str] = None&#10;    gravity: bool = False&#10;    trick_room: bool = False&#10;    is_doubles: bool = False&#10;    targets_on_target_side: int = 1&#10;    reflect: bool = False&#10;    light_screen: bool = False&#10;    aurora_veil: bool = False&#10;&#10;&#10;def _safe_lower(x: Any) -&gt; Optional[str]:&#10;    return x.lower() if isinstance(x, str) else None&#10;&#10;&#10;def _extract_side_conditions(side) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Best-effort extraction of hazards/screens from a poke-env Side object.&quot;&quot;&quot;&#10;    out = {&#10;        &quot;stealth_rock&quot;: False,&#10;        &quot;spikes&quot;: 0,&#10;        &quot;toxic_spikes&quot;: 0,&#10;        &quot;sticky_web&quot;: False,&#10;        &quot;reflect&quot;: False,&#10;        &quot;light_screen&quot;: False,&#10;        &quot;aurora_veil&quot;: False,&#10;        &quot;tailwind&quot;: False,&#10;        &quot;safeguard&quot;: False,&#10;        &quot;mist&quot;: False,&#10;    }&#10;    if side is None:&#10;        return out&#10;&#10;    # poke-env represents side conditions via enums/sets; we use getattr defensively.&#10;    sconds = getattr(side, &quot;conditions&quot;, None) or getattr(side, &quot;side_conditions&quot;, None)&#10;    if isinstance(sconds, dict):&#10;        # Newer poke-env stores counts for stackables&#10;        out[&quot;stealth_rock&quot;] = bool(sconds.get(&quot;STEALTH_ROCK&quot;) or sconds.get(&quot;Stealth Rock&quot;))&#10;        out[&quot;spikes&quot;] = int(sconds.get(&quot;SPIKES&quot;) or sconds.get(&quot;Spikes&quot;) or 0)&#10;        out[&quot;toxic_spikes&quot;] = int(sconds.get(&quot;TOXIC_SPIKES&quot;) or sconds.get(&quot;Toxic Spikes&quot;) or 0)&#10;        out[&quot;sticky_web&quot;] = bool(sconds.get(&quot;STICKY_WEB&quot;) or sconds.get(&quot;Sticky Web&quot;))&#10;        out[&quot;reflect&quot;] = bool(sconds.get(&quot;REFLECT&quot;) or sconds.get(&quot;Reflect&quot;))&#10;        out[&quot;light_screen&quot;] = bool(sconds.get(&quot;LIGHT_SCREEN&quot;) or sconds.get(&quot;Light Screen&quot;))&#10;        out[&quot;aurora_veil&quot;] = bool(sconds.get(&quot;AURORA_VEIL&quot;) or sconds.get(&quot;Aurora Veil&quot;))&#10;        out[&quot;tailwind&quot;] = bool(sconds.get(&quot;TAILWIND&quot;) or sconds.get(&quot;Tailwind&quot;))&#10;        out[&quot;safeguard&quot;] = bool(sconds.get(&quot;SAFEGUARD&quot;) or sconds.get(&quot;Safeguard&quot;))&#10;        out[&quot;mist&quot;] = bool(sconds.get(&quot;MIST&quot;) or sconds.get(&quot;Mist&quot;))&#10;    else:&#10;        # Very old poke-env&#10;        for name in (&quot;Stealth Rock&quot;, &quot;Spikes&quot;, &quot;Toxic Spikes&quot;, &quot;Sticky Web&quot;,&#10;                     &quot;Reflect&quot;, &quot;Light Screen&quot;, &quot;Aurora Veil&quot;, &quot;Tailwind&quot;, &quot;Safeguard&quot;, &quot;Mist&quot;):&#10;            val = getattr(side, name.replace(&quot; &quot;, &quot;_&quot;).lower(), None)&#10;            if isinstance(val, bool):&#10;                out[name.replace(&quot; &quot;, &quot;_&quot;).lower()] = val&#10;    return out&#10;&#10;&#10;def to_field_state(battle) -&gt; FieldState:&#10;    &quot;&quot;&quot;Convert a poke-env Battle to our FieldState.&quot;&quot;&quot;&#10;    # Weather / terrain are enums or strings; coerce to lowercase keys&#10;    w = getattr(battle, &quot;weather&quot;, None)&#10;    weather = getattr(w, &quot;name&quot;, w)&#10;    t = getattr(battle, &quot;terrain&quot;, None)&#10;    terrain = getattr(t, &quot;name&quot;, t)&#10;&#10;    # Side conditions&#10;    my_side = getattr(battle, &quot;side_conditions&quot;, None) or getattr(battle, &quot;side&quot;, None)&#10;    opp_side = getattr(battle, &quot;opponent_side_conditions&quot;, None) or getattr(battle, &quot;opponent_side&quot;, None)&#10;&#10;    my = _extract_side_conditions(my_side)&#10;    opp = _extract_side_conditions(opp_side)&#10;&#10;    # Active target count for doubles (rough estimate: 2 if both active; else 1)&#10;    is_doubles = bool(getattr(battle, &quot;is_doubles&quot;, False) or getattr(battle, &quot;double_battle&quot;, False))&#10;    targets_on_target_side = 2 if (is_doubles and len(getattr(battle, &quot;opponent_active_pokemon&quot;, []) or []) == 2) else 1&#10;&#10;    # Screens are on defender's side; we return defender=opp by default for convenience&#10;    return FieldState(&#10;        weather=_safe_lower(weather),&#10;        terrain=_safe_lower(terrain),&#10;        trick_room=bool(getattr(battle, &quot;trick_room&quot;, False)),&#10;        gravity=bool(getattr(battle, &quot;gravity&quot;, False)),&#10;        is_doubles=is_doubles,&#10;        targets_on_target_side=targets_on_target_side,&#10;        reflect=opp[&quot;reflect&quot;],&#10;        light_screen=opp[&quot;light_screen&quot;],&#10;        aurora_veil=opp[&quot;aurora_veil&quot;],&#10;    )&#10;&#10;&#10;def snapshot(battle) -&gt; Dict[str, Any]:&#10;    &quot;&quot;&quot;Dump a serializable, RL-friendly snapshot of a poke-env Battle.&#10;&#10;    This intentionally includes both IDs and human-readable names for stability.&#10;    &quot;&quot;&quot;&#10;    s = {&#10;        &quot;battle_tag&quot;: getattr(battle, &quot;battle_tag&quot;, &quot;&quot;),&#10;        &quot;format&quot;: getattr(battle, &quot;format&quot;, None),&#10;        &quot;turn&quot;: getattr(battle, &quot;turn&quot;, None),&#10;        &quot;weather&quot;: _safe_lower(getattr(getattr(battle, &quot;weather&quot;, None), &quot;name&quot;, None)),&#10;        &quot;terrain&quot;: _safe_lower(getattr(getattr(battle, &quot;terrain&quot;, None), &quot;name&quot;, None)),&#10;        &quot;trick_room&quot;: bool(getattr(battle, &quot;trick_room&quot;, False)),&#10;        &quot;gravity&quot;: bool(getattr(battle, &quot;gravity&quot;, False)),&#10;        &quot;is_doubles&quot;: bool(getattr(battle, &quot;is_doubles&quot;, False) or getattr(battle, &quot;double_battle&quot;, False)),&#10;        &quot;my_team&quot;: {},&#10;        &quot;opp_team&quot;: {},&#10;        &quot;active_moves_ids&quot;: [],&#10;        &quot;active_switch_ids&quot;: [],&#10;        &quot;force_switch&quot;: bool(getattr(battle, &quot;force_switch&quot;, False)),&#10;        &quot;can_tera&quot;: bool(getattr(battle, &quot;can_tera&quot;, False)),&#10;        &quot;side_conditions&quot;: _extract_side_conditions(getattr(battle, &quot;side_conditions&quot;, None) or getattr(battle, &quot;side&quot;, None)),&#10;        &quot;opp_side_conditions&quot;: _extract_side_conditions(getattr(battle, &quot;opponent_side_conditions&quot;, None) or getattr(battle, &quot;opponent_side&quot;, None)),&#10;    }&#10;&#10;    # Determine active references for quick flagging&#10;    try:&#10;        _active_me = getattr(battle, &quot;active_pokemon&quot;, None)&#10;    except Exception:&#10;        _active_me = None&#10;    try:&#10;        _active_opp = getattr(battle, &quot;opponent_active_pokemon&quot;, None)&#10;    except Exception:&#10;        _active_opp = None&#10;&#10;    # Team snapshots&#10;    team = getattr(battle, &quot;team&quot;, {}) or {}&#10;    for sid, p in team.items():&#10;        s[&quot;my_team&quot;][sid] = {&#10;            &quot;species&quot;: getattr(p, &quot;species&quot;, None),&#10;            &quot;types&quot;: getattr(p, &quot;types&quot;, None),&#10;            &quot;level&quot;: getattr(p, &quot;level&quot;, None),&#10;            &quot;hp_fraction&quot;: (getattr(p, &quot;current_hp_fraction&quot;, None) or getattr(p, &quot;hp_fraction&quot;, None)),&#10;            &quot;status&quot;: getattr(getattr(p, &quot;status&quot;, None), &quot;name&quot;, None),&#10;            &quot;boosts&quot;: getattr(p, &quot;boosts&quot;, None),&#10;            &quot;item&quot;: getattr(p, &quot;item&quot;, None),&#10;            &quot;ability&quot;: getattr(p, &quot;ability&quot;, None),&#10;            &quot;revealed_moves&quot;: [getattr(m, &quot;id&quot;, None) for m in (getattr(p, &quot;moves&quot;, None) or {}).values()],&#10;            &quot;is_active&quot;: bool(p is _active_me),&#10;        }&#10;&#10;    opp_team = getattr(battle, &quot;opponent_team&quot;, {}) or {}&#10;    for sid, p in opp_team.items():&#10;        s[&quot;opp_team&quot;][sid] = {&#10;            &quot;species&quot;: getattr(p, &quot;species&quot;, None),&#10;            &quot;types&quot;: getattr(p, &quot;types&quot;, None),&#10;            &quot;level&quot;: getattr(p, &quot;level&quot;, None),&#10;            &quot;hp_fraction&quot;: (getattr(p, &quot;current_hp_fraction&quot;, None) or getattr(p, &quot;hp_fraction&quot;, None)),&#10;            &quot;status&quot;: getattr(getattr(p, &quot;status&quot;, None), &quot;name&quot;, None),&#10;            &quot;boosts&quot;: getattr(p, &quot;boosts&quot;, None),&#10;            &quot;item&quot;: getattr(p, &quot;item&quot;, None),&#10;            &quot;ability&quot;: getattr(p, &quot;ability&quot;, None),&#10;            &quot;revealed_moves&quot;: [getattr(m, &quot;id&quot;, None) for m in (getattr(p, &quot;moves&quot;, None) or {}).values()],&#10;            &quot;is_active&quot;: bool(p is _active_opp),&#10;        }&#10;&#10;    # Actions available&#10;    try:&#10;        s[&quot;active_moves_ids&quot;] = [getattr(m, &quot;id&quot;, None) for m in (getattr(battle, &quot;available_moves&quot;, []) or [])]&#10;        s[&quot;active_switch_ids&quot;] = [getattr(p, &quot;species&quot;, None) for p in (getattr(battle, &quot;available_switches&quot;, []) or [])]&#10;    except Exception:&#10;        pass&#10;&#10;    return s" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Data/poke_env_moves_info.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/poke_env_moves_info.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Pokemon moves information and data management module&#10;---------------------------------------------------&#10;Lightweight wrapper around poke_env.data.GenData for moves and type chart access.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;# --- BEGIN UI TYPE-CHART NORMALIZER PATCH ---&#10;_UI_TC_NORMALIZER_INSTALLED = True&#10;&#10;_CANON_TYPES = [&quot;NORMAL&quot;,&quot;FIRE&quot;,&quot;WATER&quot;,&quot;ELECTRIC&quot;,&quot;GRASS&quot;,&quot;ICE&quot;,&quot;FIGHTING&quot;,&quot;POISON&quot;,&quot;GROUND&quot;,&quot;FLYING&quot;,&quot;PSYCHIC&quot;,&quot;BUG&quot;,&quot;ROCK&quot;,&quot;GHOST&quot;,&quot;DRAGON&quot;,&quot;DARK&quot;,&quot;STEEL&quot;,&quot;FAIRY&quot;,&quot;STELLAR&quot;]&#10;&#10;def _norm_type_name(t):&#10;    if not t: return None&#10;    s = str(t).strip().upper()&#10;    if s == &quot;&quot;: return None&#10;    return s&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Pokemon moves information and data management module&#10;---------------------------------------------------&#10;Lightweight wrapper around poke_env.data.GenData for moves and type chart access.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;# --- BEGIN UI TYPE-CHART NORMALIZER PATCH ---&#10;_UI_TC_NORMALIZER_INSTALLED = True&#10;&#10;_CANON_TYPES = [&quot;NORMAL&quot;,&quot;FIRE&quot;,&quot;WATER&quot;,&quot;ELECTRIC&quot;,&quot;GRASS&quot;,&quot;ICE&quot;,&quot;FIGHTING&quot;,&quot;POISON&quot;,&quot;GROUND&quot;,&quot;FLYING&quot;,&quot;PSYCHIC&quot;,&quot;BUG&quot;,&quot;ROCK&quot;,&quot;GHOST&quot;,&quot;DRAGON&quot;,&quot;DARK&quot;,&quot;STEEL&quot;,&quot;FAIRY&quot;,&quot;STELLAR&quot;]&#10;&#10;def _norm_type_name(t):&#10;    if not t: return None&#10;    s = str(t).strip().upper()&#10;    if s == &quot;&quot;: return None&#10;    return s&#10;&#10;def _to_title(s: str) -&gt; str:&#10;    return s[:1] + s[1:].lower() if s else s&#10;&#10;# Correct Showdown code mapping (defense-centric damageTaken): 0=neutral,1=weak(2x),2=resist(0.5x),3=immune(0x)&#10;_SHOWDOWN_CODE_TO_MULT = {0:1.0, 1:2.0, 2:0.5, 3:0.0}&#10;_ALT_SHOWDOWN_CODE_TO_MULT = {0:1.0, 1:0.5, 2:2.0, 3:0.0}  # fallback if first mapping clearly wrong&#10;&#10;_DEF_CENTRIC_KEYS = {&quot;DAMAGETAKEN&quot;,&quot;DAMAGE_TAKEN&quot;}&#10;&#10;def _looks_like_attack_matrix(tc: dict) -&gt; bool:&#10;    &quot;&quot;&quot;Heuristic: treat as attack-&gt;defense matrix if each row is a dict of numeric multipliers within plausible range.&quot;&quot;&quot;&#10;    if not tc: return False&#10;    rows = list(tc.values())&#10;    sample = None&#10;    for r in rows:&#10;        if isinstance(r, dict):&#10;            sample = r; break&#10;    if not isinstance(sample, dict):&#10;        return False&#10;    vals = list(sample.values())&#10;    if not vals:&#10;        return False&#10;    # If any float not in {0,1,2,3} assume already multipliers&#10;    if any(isinstance(v, (int,float)) and v not in (0,1,2,3) for v in vals):&#10;        return True&#10;    # If all rows contain any of the def-centric markers, not an attack matrix&#10;    for r in rows:&#10;        if isinstance(r, dict) and any(k.lower() == 'damagetaken' for k in r.keys()):&#10;            return False&#10;    # Ambiguous (all 0/1/2/3). Assume not attack matrix to avoid transposition errors.&#10;    return False&#10;&#10;def _normalize_showdown_typechart(tc):&#10;    &quot;&quot;&quot;Normalize Showdown type chart to attack-&gt;defense (Title-case keys).&#10;&#10;    Handles both:&#10;      * Defense-centric Showdown format: {DefType: {damageTaken: {AtkType: code}}}&#10;      * Already attack-centric matrix: {AtkType: {DefType: mult(float)}}&#10;&#10;    Previous buggy version misinterpreted orientation and swapped weakness/resist codes.&#10;    &quot;&quot;&quot;&#10;    import logging&#10;    log = logging.getLogger('typecalc')&#10;    if not isinstance(tc, dict):&#10;        return {}&#10;&#10;    # Fast path: already attack matrix with float multipliers&#10;    if _looks_like_attack_matrix(tc):&#10;        out = {}&#10;        for atk, row in tc.items():&#10;            A = _norm_type_name(atk)&#10;            if not A: continue&#10;            At = _to_title(A)&#10;            out.setdefault(At, {})&#10;            if not isinstance(row, dict):&#10;                continue&#10;            for dfd, mult in row.items():&#10;                D = _norm_type_name(dfd)&#10;                if not D: continue&#10;                Dt = _to_title(D)&#10;                try:&#10;                    out[At][Dt] = float(mult)&#10;                except Exception:&#10;                    pass&#10;        return out&#10;&#10;    # Defense-centric path&#10;    atk_mat = { _to_title(a): {} for a in _CANON_TYPES }&#10;    # We'll first collect raw codes per (atk,def) to allow adaptive mapping decision&#10;    raw_codes = []  # list of (atk, def, code_int)&#10;    for def_type, row in tc.items():&#10;        D = _norm_type_name(def_type)&#10;        if not D: continue&#10;        if not isinstance(row, dict):&#10;            continue&#10;        # locate damageTaken structure or treat row as codes&#10;        dmg_row = None&#10;        for k, v in row.items():&#10;            if isinstance(v, dict) and k.upper() in _DEF_CENTRIC_KEYS:&#10;                dmg_row = v; break&#10;        if dmg_row is None:&#10;            # Maybe row itself is the damageTaken dict&#10;            dmg_row = row if all(isinstance(x, (int,float)) for x in row.values()) else None&#10;        if not isinstance(dmg_row, dict):&#10;            continue&#10;        for atk_type, code in dmg_row.items():&#10;            A = _norm_type_name(atk_type)&#10;            if not A: continue&#10;            # Only translate known types&#10;            if A not in _CANON_TYPES: continue&#10;            try:&#10;                code_int = int(code)&#10;            except Exception:&#10;                code_int = 0&#10;            raw_codes.append((A, D, code_int))&#10;    # Decide which code mapping fits expectations better&#10;    def build_matrix(code_map):&#10;        m = { _to_title(a): {} for a in _CANON_TYPES }&#10;        for A,D,ci in raw_codes:&#10;            if A in _CANON_TYPES and D in _CANON_TYPES:&#10;                m[_to_title(A)][_to_title(D)] = code_map.get(ci, 1.0)&#10;        return m&#10;    cand1 = build_matrix(_SHOWDOWN_CODE_TO_MULT)&#10;    cand2 = build_matrix(_ALT_SHOWDOWN_CODE_TO_MULT)&#10;    # Expectation samples (atk,def,expected_mult)&#10;    expectations = [&#10;        ('Fire','Grass',2.0), ('Fire','Water',0.5), ('Water','Fire',2.0), ('Dark','Fairy',0.5), ('Fairy','Dark',2.0),&#10;        ('Fighting','Ghost',0.0), ('Ghost','Normal',0.0)&#10;    ]&#10;    def score(mat):&#10;        sc = 0&#10;        for a,d,exp in expectations:&#10;            got = mat.get(a, {}).get(d)&#10;            if got == exp: sc += 1&#10;        return sc&#10;    if score(cand2) &gt; score(cand1):&#10;        import logging; logging.getLogger('typecalc').info('Swapping to alternate typechart code mapping (detected inverted 1/2 codes).')&#10;        atk_mat = cand2&#10;    else:&#10;        atk_mat = cand1&#10;    # Drop empty rows&#10;    out = { atk: row for atk, row in atk_mat.items() if any(v != 1.0 for v in row.values()) }&#10;    if not out:&#10;        # If everything looked neutral (unlikely), fallback to atk_mat (retain structure)&#10;        out = atk_mat&#10;    # Basic sanity check example: Fire vs Ground should be 1.0&#10;    try:&#10;        fg = out.get('Fire', {}).get('Ground')&#10;        # Evaluate expectations; if badly wrong, fallback to static&#10;        expectations = [&#10;            ('Dark','Fairy',0.5),('Fairy','Dark',2.0),('Fire','Grass',2.0),('Fire','Water',0.5),('Water','Fire',2.0),('Fighting','Ghost',0.0),('Ghost','Normal',0.0)&#10;        ]&#10;        ok = sum(1 for a,d,exp in expectations if out.get(a, {}).get(d) == exp)&#10;        if ok &lt; len(expectations)-1:&#10;            import logging; logging.getLogger('typecalc').warning('Type chart mapping failed (%d/%d correct). Falling back to static canonical chart.', ok, len(expectations))&#10;            return _build_static_chart()&#10;        if fg and fg not in (0.0,0.25,0.5,1.0,2.0,4.0):&#10;            log.warning('Typechart anomaly Fire-&gt;Ground=%.3f (clamping)', fg)&#10;            out['Fire']['Ground'] = 1.0&#10;        if out.get('Fire', {}).get('Ground') == 2.0 and out.get('Ground', {}).get('Fire') in (0.5,1.0):&#10;            log.warning('Detected transposed weakness (Fire-&gt;Ground=2.0). Correcting to 1.0.')&#10;            out['Fire']['Ground'] = 1.0&#10;    except Exception:&#10;        pass&#10;    return out&#10;# --- END UI TYPE-CHART NORMALIZER PATCH ---&#10;&#10;from dataclasses import dataclass, field&#10;from typing import Any, Dict, List, Optional, Sequence, Union&#10;&#10;# Added by patch_think_showdown.py&#10;import os&#10;from Data.think_helpers import normalize_accuracy&#10;&#10;try:&#10;    from tools.Data.showdown.ps_data_loader import load_showdown_dir  # noqa: F401&#10;except Exception:&#10;    load_showdown_dir = None&#10;&#10;try:&#10;    from poke_env.data import GenData&#10;    from poke_env.data.normalize import to_id_str&#10;except Exception:  # pragma: no cover - allow import without poke-env&#10;    GenData = None&#10;    def to_id_str(s: str) -&gt; str:&#10;        return &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())&#10;&#10;&#10;@dataclass&#10;class MoveInfo:&#10;    id: str&#10;    name: str&#10;    type: Optional[str] = None&#10;    category: Optional[str] = None&#10;    base_power: Optional[int] = None&#10;    accuracy: Optional[Union[int, float, bool]] = None&#10;    priority: int = 0&#10;    target: Optional[str] = None&#10;    pp: Optional[int] = None&#10;    flags: Dict[str, bool] = field(default_factory=dict)&#10;    secondary: Optional[Dict[str, Any]] = None&#10;    secondaries: Optional[List[Dict[str, Any]]] = None&#10;    status: Optional[str] = None&#10;    volatile_status: Optional[str] = None&#10;    boosts: Optional[Dict[str, int]] = None&#10;    multihit: Optional[Union[int, List[int]]] = None&#10;    drain: Optional[List[int]] = None&#10;    recoil: Optional[List[int]] = None&#10;    raw: Dict[str, Any] = field(default_factory=dict)&#10;&#10;    @property&#10;    def makes_contact(self) -&gt; bool:&#10;        return bool(self.flags.get(&quot;contact&quot;))&#10;&#10;&#10;class MovesInfo:&#10;    def __init__(self, gen_or_format: Union[int, str] = 9):&#10;        if isinstance(gen_or_format, int):&#10;            self._data = GenData.from_gen(gen_or_format) if GenData else None&#10;        else:&#10;            self._data = GenData.from_format(gen_or_format) if GenData else None&#10;        # Load Showdown dex as a secondary source (items/abilities/moves/typechart)&#10;        self._ps_dex: Dict[str, Dict[str, Any]] = {}&#10;        try:&#10;            if load_showdown_dir:&#10;                repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))&#10;                sd_dir = os.path.join(repo_root, &quot;tools&quot;, &quot;Data&quot;, &quot;showdown&quot;)&#10;                if os.path.isdir(sd_dir):&#10;                    self._ps_dex = load_showdown_dir(sd_dir)&#10;        except Exception:&#10;            self._ps_dex = {}&#10;&#10;    def gen(self) -&gt; int:&#10;        return getattr(self._data, &quot;gen&quot;, 9)&#10;&#10;    def exists(self, name_or_id: str) -&gt; bool:&#10;        mid = to_id_str(name_or_id)&#10;        in_pokeenv = bool(getattr(self, &quot;_data&quot;, None)) and (mid in getattr(self._data, &quot;moves&quot;, {}))&#10;        in_ps = bool(self._ps_dex) and (mid in self._ps_dex.get(&quot;moves&quot;, {}))&#10;        return in_pokeenv or in_ps&#10;&#10;    def all_ids(self) -&gt; List[str]:&#10;        if not self._data:&#10;            return []&#10;        return list(self._data.moves.keys())&#10;&#10;    def raw(self, name_or_id: str) -&gt; Dict[str, Any]:&#10;        mid = to_id_str(name_or_id)&#10;        m = None&#10;        try:&#10;            if getattr(self, &quot;_data&quot;, None):&#10;                m = self._data.moves.get(mid)&#10;        except Exception:&#10;            m = None&#10;        if m is None and self._ps_dex:&#10;            m = self._ps_dex.get(&quot;moves&quot;, {}).get(mid)&#10;        if m is None:&#10;            raise KeyError(f&quot;Unknown move: {name_or_id} (normalized: {mid})&quot;)&#10;        return m&#10;&#10;    def get(self, name_or_id: str) -&gt; MoveInfo:&#10;        m = self.raw(name_or_id)&#10;        mid = to_id_str(name_or_id)&#10;        return MoveInfo(&#10;            id=mid,&#10;            name=m.get(&quot;name&quot;, mid),&#10;            type=m.get(&quot;type&quot;),&#10;            category=m.get(&quot;category&quot;),&#10;            base_power=m.get(&quot;basePower&quot;) if &quot;basePower&quot; in m else m.get(&quot;base_power&quot;),&#10;            accuracy=normalize_accuracy(m.get('accuracy')),&#10;            priority=m.get(&quot;priority&quot;, 0),&#10;            target=m.get(&quot;target&quot;),&#10;            pp=m.get(&quot;pp&quot;),&#10;            flags=m.get(&quot;flags&quot;, {}),&#10;            secondary=m.get(&quot;secondary&quot;),&#10;            secondaries=m.get(&quot;secondaries&quot;),&#10;            status=m.get(&quot;status&quot;),&#10;            volatile_status=m.get(&quot;volatileStatus&quot;) or m.get(&quot;volatile_status&quot;),&#10;            boosts=m.get(&quot;boosts&quot;),&#10;            multihit=m.get(&quot;multihit&quot;),&#10;            drain=m.get(&quot;drain&quot;),&#10;            recoil=m.get(&quot;recoil&quot;),&#10;            raw=m,&#10;        )&#10;&#10;    def get_type_chart(self) -&gt; Dict[str, Dict[str, float]]:&#10;        &quot;&quot;&quot;Return a normalized, Title-case type chart with caching (falls back to Showdown).&#10;        If an older cached uppercase chart is detected, convert it on the fly.&#10;        Added: strict validation vs canonical expectations; on failure, use static chart.&#10;        You can force static via env POKECHAD_FORCE_STATIC_TYPECHART=1.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            import os&#10;            if os.getenv('POKECHAD_FORCE_STATIC_TYPECHART'):&#10;                tc = _build_static_chart()&#10;                setattr(self, '_type_chart_cache', tc)&#10;                return tc&#10;            tc = getattr(self, &quot;_type_chart_cache&quot;, None)&#10;            if tc is None:&#10;                raw_tc = (&#10;                    getattr(getattr(self, &quot;_data&quot;, None), &quot;type_chart&quot;, None)&#10;                    or getattr(self, &quot;type_chart&quot;, None)&#10;                    or (self._ps_dex.get(&quot;typechart&quot;) if getattr(self, &quot;_ps_dex&quot;, None) else {})&#10;                    or {}&#10;                )&#10;                tc = _normalize_showdown_typechart(raw_tc)&#10;                # Validate expectations&#10;                expectations = [&#10;                    ('Fire','Grass',2.0),('Fire','Water',0.5),('Water','Fire',2.0),('Dark','Fairy',0.5),('Fairy','Dark',2.0),('Fighting','Ghost',0.0),('Ghost','Normal',0.0)&#10;                ]&#10;                ok = sum(1 for a,d,exp in expectations if tc.get(a, {}).get(d) == exp)&#10;                if ok &lt; len(expectations):&#10;                    import logging; logging.getLogger('typecalc').warning('Dynamic type chart failed validation (%d/%d). Using static canonical chart.', ok, len(expectations))&#10;                    tc = _build_static_chart()&#10;                setattr(self, &quot;_type_chart_cache&quot;, tc)&#10;            else:&#10;                if tc and all(k.isupper() for k in tc.keys()):&#10;                    converted = {}&#10;                    for atk, row in tc.items():&#10;                        converted[_to_title(atk)] = { _to_title(dfd): mult for dfd, mult in row.items() }&#10;                    tc = converted&#10;                    setattr(self, &quot;_type_chart_cache&quot;, tc)&#10;            return tc&#10;        except Exception:&#10;            return _build_static_chart()&#10;&#10;_STATIC_CHART = None&#10;&#10;def _build_static_chart():&#10;    global _STATIC_CHART&#10;    if _STATIC_CHART is not None:&#10;        return _STATIC_CHART&#10;    types = [&quot;Normal&quot;,&quot;Fire&quot;,&quot;Water&quot;,&quot;Electric&quot;,&quot;Grass&quot;,&quot;Ice&quot;,&quot;Fighting&quot;,&quot;Poison&quot;,&quot;Ground&quot;,&quot;Flying&quot;,&quot;Psychic&quot;,&quot;Bug&quot;,&quot;Rock&quot;,&quot;Ghost&quot;,&quot;Dragon&quot;,&quot;Dark&quot;,&quot;Steel&quot;,&quot;Fairy&quot;]&#10;    n=1.0; h=0.5; s=2.0; z=0.0&#10;    eff = {t:{u:n for u in types} for t in types}&#10;    eff[&quot;Normal&quot;][&quot;Rock&quot;]=h; eff[&quot;Normal&quot;][&quot;Ghost&quot;]=z; eff[&quot;Normal&quot;][&quot;Steel&quot;]=h&#10;    for u in [&quot;Fire&quot;,&quot;Water&quot;,&quot;Rock&quot;,&quot;Dragon&quot;]: eff[&quot;Fire&quot;][u]=h&#10;    for u in [&quot;Grass&quot;,&quot;Ice&quot;,&quot;Bug&quot;,&quot;Steel&quot;]: eff[&quot;Fire&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Ground&quot;,&quot;Rock&quot;]: eff[&quot;Water&quot;][u]=s&#10;    for u in [&quot;Water&quot;,&quot;Grass&quot;,&quot;Dragon&quot;]: eff[&quot;Water&quot;][u]=h&#10;    for u in [&quot;Water&quot;,&quot;Flying&quot;]: eff[&quot;Electric&quot;][u]=s&#10;    for u in [&quot;Electric&quot;,&quot;Grass&quot;,&quot;Dragon&quot;]: eff[&quot;Electric&quot;][u]=h&#10;    eff[&quot;Electric&quot;][&quot;Ground&quot;]=z&#10;    for u in [&quot;Water&quot;,&quot;Ground&quot;,&quot;Rock&quot;]: eff[&quot;Grass&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Grass&quot;,&quot;Poison&quot;,&quot;Flying&quot;,&quot;Bug&quot;,&quot;Dragon&quot;,&quot;Steel&quot;]: eff[&quot;Grass&quot;][u]=h&#10;    for u in [&quot;Grass&quot;,&quot;Ground&quot;,&quot;Flying&quot;,&quot;Dragon&quot;]: eff[&quot;Ice&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Water&quot;,&quot;Ice&quot;,&quot;Steel&quot;]: eff[&quot;Ice&quot;][u]=h&#10;    for u in [&quot;Normal&quot;,&quot;Ice&quot;,&quot;Rock&quot;,&quot;Dark&quot;,&quot;Steel&quot;]: eff[&quot;Fighting&quot;][u]=s&#10;    for u in [&quot;Poison&quot;,&quot;Flying&quot;,&quot;Psychic&quot;,&quot;Bug&quot;,&quot;Fairy&quot;]: eff[&quot;Fighting&quot;][u]=h&#10;    eff[&quot;Fighting&quot;][&quot;Ghost&quot;]=z&#10;    eff[&quot;Poison&quot;][&quot;Grass&quot;]=s&#10;    for u in [&quot;Poison&quot;,&quot;Ground&quot;,&quot;Rock&quot;,&quot;Ghost&quot;]: eff[&quot;Poison&quot;][u]=h&#10;    eff[&quot;Poison&quot;][&quot;Steel&quot;]=z&#10;    eff[&quot;Poison&quot;][&quot;Fairy&quot;]=s&#10;    for u in [&quot;Fire&quot;,&quot;Electric&quot;,&quot;Poison&quot;,&quot;Rock&quot;,&quot;Steel&quot;]: eff[&quot;Ground&quot;][u]=s&#10;    for u in [&quot;Grass&quot;,&quot;Bug&quot;]: eff[&quot;Ground&quot;][u]=h&#10;    eff[&quot;Ground&quot;][&quot;Flying&quot;]=z&#10;    for u in [&quot;Grass&quot;,&quot;Fighting&quot;,&quot;Bug&quot;]: eff[&quot;Flying&quot;][u]=s&#10;    for u in [&quot;Electric&quot;,&quot;Rock&quot;,&quot;Steel&quot;]: eff[&quot;Flying&quot;][u]=h&#10;    for u in [&quot;Fighting&quot;,&quot;Poison&quot;]: eff[&quot;Psychic&quot;][u]=s&#10;    for u in [&quot;Psychic&quot;,&quot;Steel&quot;]: eff[&quot;Psychic&quot;][u]=h&#10;    eff[&quot;Psychic&quot;][&quot;Dark&quot;]=z&#10;    for u in [&quot;Grass&quot;,&quot;Psychic&quot;,&quot;Dark&quot;]: eff[&quot;Bug&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Fighting&quot;,&quot;Poison&quot;,&quot;Flying&quot;,&quot;Ghost&quot;,&quot;Steel&quot;,&quot;Fairy&quot;]: eff[&quot;Bug&quot;][u]=h&#10;    for u in [&quot;Fire&quot;,&quot;Ice&quot;,&quot;Flying&quot;,&quot;Bug&quot;]: eff[&quot;Rock&quot;][u]=s&#10;    for u in [&quot;Fighting&quot;,&quot;Ground&quot;,&quot;Steel&quot;]: eff[&quot;Rock&quot;][u]=h&#10;    eff[&quot;Ghost&quot;][&quot;Ghost&quot;]=s; eff[&quot;Ghost&quot;][&quot;Psychic&quot;]=s&#10;    eff[&quot;Ghost&quot;][&quot;Dark&quot;]=h; eff[&quot;Ghost&quot;][&quot;Normal&quot;]=z&#10;    eff[&quot;Dragon&quot;][&quot;Dragon&quot;]=s; eff[&quot;Dragon&quot;][&quot;Steel&quot;]=h; eff[&quot;Dragon&quot;][&quot;Fairy&quot;]=z&#10;    eff[&quot;Dark&quot;][&quot;Psychic&quot;]=s; eff[&quot;Dark&quot;][&quot;Ghost&quot;]=s&#10;    for u in [&quot;Fighting&quot;,&quot;Dark&quot;,&quot;Fairy&quot;]: eff[&quot;Dark&quot;][u]=h&#10;    for u in [&quot;Rock&quot;,&quot;Ice&quot;,&quot;Fairy&quot;]: eff[&quot;Steel&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Water&quot;,&quot;Electric&quot;,&quot;Steel&quot;]: eff[&quot;Steel&quot;][u]=h&#10;    for u in [&quot;Fighting&quot;,&quot;Dragon&quot;,&quot;Dark&quot;]: eff[&quot;Fairy&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Poison&quot;,&quot;Steel&quot;]: eff[&quot;Fairy&quot;][u]=h&#10;    _STATIC_CHART = eff&#10;    return eff&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Data/poke_env_pokemon_info.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/poke_env_pokemon_info.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Pokemon information and data management module&#10;----------------------------------------------&#10;Wraps poke_env.data.GenData for species data and exposes a stat estimator that&#10;follows the in-game formulas (or defers to poke_env.stats.compute_raw_stats if&#10;available).&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass, field&#10;from typing import Any, Dict, List, Optional, Sequence, Tuple, Union&#10;&#10;try:&#10;    from poke_env.data import GenData&#10;    from poke_env.data.normalize import to_id_str&#10;    from poke_env import stats as pe_stats&#10;except Exception:  # pragma: no cover&#10;    GenData = None&#10;    pe_stats = None&#10;    def to_id_str(s: str) -&gt; str:&#10;        return &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Pokemon information and data management module&#10;----------------------------------------------&#10;Wraps poke_env.data.GenData for species data and exposes a stat estimator that&#10;follows the in-game formulas (or defers to poke_env.stats.compute_raw_stats if&#10;available).&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass, field&#10;from typing import Any, Dict, List, Optional, Sequence, Tuple, Union&#10;&#10;try:&#10;    from poke_env.data import GenData&#10;    from poke_env.data.normalize import to_id_str&#10;    from poke_env import stats as pe_stats&#10;except Exception:  # pragma: no cover&#10;    GenData = None&#10;    pe_stats = None&#10;    def to_id_str(s: str) -&gt; str:&#10;        return &quot;&quot;.join(ch.lower() for ch in s if ch.isalnum())&#10;from . import dex_registry  # lazy access to Showdown item data&#10;&#10;&#10;@dataclass&#10;class PokemonStats:&#10;    hp: int = 0&#10;    atk: int = 0&#10;    def_: int = 0&#10;    spa: int = 0&#10;    spd: int = 0&#10;    spe: int = 0&#10;&#10;&#10;@dataclass&#10;class SpeciesInfo:&#10;    id: str&#10;    name: str&#10;    types: List[str] = field(default_factory=list)&#10;    abilities: Dict[Union[str, int], str] = field(default_factory=dict)&#10;    base_stats: PokemonStats = field(default_factory=PokemonStats)&#10;    weightkg: Optional[float] = None&#10;    heightm: Optional[float] = None&#10;    evos: List[str] = field(default_factory=list)&#10;    prevo: Optional[str] = None&#10;    raw: Dict[str, Any] = field(default_factory=dict)&#10;&#10;&#10;# ------------------------- Core wrapper ------------------------------------------&#10;&#10;class PokemonInfo:&#10;    def __init__(self, gen_or_format: Union[int, str] = 9):&#10;        if isinstance(gen_or_format, int):&#10;            self._data = GenData.from_gen(gen_or_format) if GenData else None&#10;        else:&#10;            self._data = GenData.from_format(gen_or_format) if GenData else None&#10;&#10;    @property&#10;    def gen(self) -&gt; int:&#10;        return getattr(self._data, &quot;gen&quot;, 9)&#10;&#10;    def all_ids(self) -&gt; List[str]:&#10;        if not self._data:&#10;            return []&#10;        return list(self._data.pokedex.keys())&#10;&#10;    def exists(self, name_or_id: str) -&gt; bool:&#10;        if not self._data:&#10;            return False&#10;        return to_id_str(name_or_id) in self._data.pokedex&#10;&#10;    def raw(self, name_or_id: str) -&gt; Dict[str, Any]:&#10;        if not self._data:&#10;            raise RuntimeError(&quot;poke_env not available&quot;)&#10;        sid = to_id_str(name_or_id)&#10;        s = self._data.pokedex.get(sid)&#10;        if s is None:&#10;            raise KeyError(f&quot;Unknown species: {name_or_id} (normalized: {sid})&quot;)&#10;        return s&#10;&#10;    def get(self, name_or_id: str) -&gt; SpeciesInfo:&#10;        s = self.raw(name_or_id)&#10;        sid = to_id_str(name_or_id)&#10;        bs = s.get(&quot;baseStats&quot;, {})&#10;        return SpeciesInfo(&#10;            id=sid,&#10;            name=s.get(&quot;name&quot;, sid),&#10;            types=s.get(&quot;types&quot;, []),&#10;            abilities=s.get(&quot;abilities&quot;, {}),&#10;            base_stats=PokemonStats(&#10;                hp=bs.get(&quot;hp&quot;, 0), atk=bs.get(&quot;atk&quot;, 0), def_=bs.get(&quot;def&quot;, 0),&#10;                spa=bs.get(&quot;spa&quot;, 0), spd=bs.get(&quot;spd&quot;, 0), spe=bs.get(&quot;spe&quot;, 0),&#10;            ),&#10;            weightkg=s.get(&quot;weightkg&quot;),&#10;            heightm=s.get(&quot;heightm&quot;),&#10;            evos=s.get(&quot;evos&quot;, []),&#10;            prevo=s.get(&quot;prevo&quot;),&#10;            raw=s,&#10;        )&#10;&#10;    # ----------- Stats (poke_env path or fallback) --------------------------------&#10;&#10;    def compute_raw_stats(&#10;        self,&#10;        species: str,&#10;        evs: Sequence[int],&#10;        ivs: Sequence[int],&#10;        level: int,&#10;        nature: str,&#10;    ) -&gt; List[int]:&#10;        &quot;&quot;&quot;Delegate to poke_env.stats.compute_raw_stats when available, else fallback.&quot;&quot;&quot;&#10;        if pe_stats is not None:&#10;            return pe_stats.compute_raw_stats(species, list(evs), list(ivs), level, nature, self._data)&#10;        return self._fallback_compute_raw_stats(species, evs, ivs, level, nature)&#10;&#10;    def _fallback_compute_raw_stats(&#10;        self,&#10;        species: str,&#10;        evs: Sequence[int],&#10;        ivs: Sequence[int],&#10;        level: int,&#10;        nature: str,&#10;    ) -&gt; List[int]:&#10;        &quot;&quot;&quot;In-game formula fallback using the local GenData (approx identical).&quot;&quot;&quot;&#10;        s = self.get(species)&#10;        bs = s.base_stats&#10;        # Nature multipliers&#10;        nat = (nature or &quot;Serious&quot;).capitalize()&#10;        inc = {&quot;Lonely&quot;:&quot;atk&quot;,&quot;Brave&quot;:&quot;atk&quot;,&quot;Adamant&quot;:&quot;atk&quot;,&quot;Naughty&quot;:&quot;atk&quot;,&#10;               &quot;Bold&quot;:&quot;def_&quot;,&quot;Relaxed&quot;:&quot;def_&quot;,&quot;Impish&quot;:&quot;def_&quot;,&quot;Lax&quot;:&quot;def_&quot;,&#10;               &quot;Modest&quot;:&quot;spa&quot;,&quot;Mild&quot;:&quot;spa&quot;,&quot;Quiet&quot;:&quot;spa&quot;,&quot;Rash&quot;:&quot;spa&quot;,&#10;               &quot;Calm&quot;:&quot;spd&quot;,&quot;Gentle&quot;:&quot;spd&quot;,&quot;Sassy&quot;:&quot;spd&quot;,&quot;Careful&quot;:&quot;spd&quot;,&#10;               &quot;Timid&quot;:&quot;spe&quot;,&quot;Hasty&quot;:&quot;spe&quot;,&quot;Jolly&quot;:&quot;spe&quot;,&quot;Naive&quot;:&quot;spe&quot;}&#10;        dec = {&quot;Bold&quot;:&quot;atk&quot;,&quot;Relaxed&quot;:&quot;spe&quot;,&quot;Impish&quot;:&quot;spa&quot;,&quot;Lax&quot;:&quot;spd&quot;,&#10;               &quot;Modest&quot;:&quot;atk&quot;,&quot;Mild&quot;:&quot;def_&quot;,&quot;Quiet&quot;:&quot;spe&quot;,&quot;Rash&quot;:&quot;spd&quot;,&#10;               &quot;Calm&quot;:&quot;atk&quot;,&quot;Gentle&quot;:&quot;def_&quot;,&quot;Sassy&quot;:&quot;spe&quot;,&quot;Careful&quot;:&quot;spa&quot;,&#10;               &quot;Timid&quot;:&quot;atk&quot;,&quot;Hasty&quot;:&quot;def_&quot;,&quot;Jolly&quot;:&quot;spa&quot;,&quot;Naive&quot;:&quot;spd&quot;,&#10;               &quot;Lonely&quot;:&quot;def_&quot;,&quot;Brave&quot;:&quot;spe&quot;,&quot;Adamant&quot;:&quot;spa&quot;,&quot;Naughty&quot;:&quot;spd&quot;}&#10;        mults = {&quot;atk&quot;:1.0,&quot;def_&quot;:1.0,&quot;spa&quot;:1.0,&quot;spd&quot;:1.0,&quot;spe&quot;:1.0}&#10;        if nat in inc: mults[inc[nat]] = 1.1&#10;        if nat in dec: mults[dec[nat]] = 0.9&#10;&#10;        def stat_non_hp(base: int, ev: int, iv: int) -&gt; int:&#10;            pre = ((2*base + iv + ev//4) * level) // 100 + 5&#10;            return int(pre * mults_key)&#10;&#10;        # compute&#10;        ivs = list(ivs) if ivs else [31]*6&#10;        evs = list(evs) if evs else [0]*6&#10;        b = [bs.hp, bs.atk, bs.def_, bs.spa, bs.spd, bs.spe]&#10;        # HP special case&#10;        hp = ((2*b[0] + ivs[0] + evs[0]//4) * level) // 100 + level + 10&#10;        # Others with nature&#10;        defn = ((2*b[2] + ivs[2] + evs[2]//4) * level) // 100 + 5&#10;        atk = int( (((2*b[1] + ivs[1] + evs[1]//4) * level) // 100 + 5) * mults[&quot;atk&quot;] )&#10;        spa = int( (((2*b[3] + ivs[3] + evs[3]//4) * level) // 100 + 5) * mults[&quot;spa&quot;] )&#10;        spd = int( (((2*b[4] + ivs[4] + evs[4]//4) * level) // 100 + 5) * mults[&quot;spd&quot;] )&#10;        spe = int( (((2*b[5] + ivs[5] + evs[5]//4) * level) // 100 + 5) * mults[&quot;spe&quot;] )&#10;        return [hp, atk, defn, spa, spd, spe]&#10;&#10;&#10;# ------------------------- Estimation policy -------------------------------------&#10;&#10;@dataclass&#10;class StatEstimationPolicy:&#10;    &quot;&quot;&quot;Controls default IV/EV/nature assumptions for unknown opponents.&quot;&quot;&quot;&#10;    level: int = 50&#10;    default_ivs: Sequence[int] = (31,31,31,31,31,31)&#10;    default_evs: Sequence[int] = (0,0,0,0,0,0)&#10;    default_nature: str = &quot;Serious&quot;   # neutral&#10;    # If True, assume 252 in the attacker's relevant stat and Speed, and 4 HP by default&#10;    max_offense_hint: bool = True&#10;&#10;&#10;def estimate_stats(&#10;    pinfo: PokemonInfo,&#10;    species: str,&#10;    policy: Optional[StatEstimationPolicy] = None,&#10;    as_attacker: bool = False,&#10;    special_attacker_hint: bool = False,&#10;) -&gt; PokemonStats:&#10;    &quot;&quot;&quot;Estimate raw stats for a species according to a policy.&#10;&#10;    If `as_attacker=True`, we bias EVs toward Atk or SpA + Spe depending on hint.&#10;    &quot;&quot;&quot;&#10;    pol = policy or StatEstimationPolicy()&#10;    evs = list(pol.default_evs)&#10;    if as_attacker and pol.max_offense_hint:&#10;        if special_attacker_hint:&#10;            evs = [4, 0, 0, 252, 0, 252]  # 4 HP / 252 SpA / 252 Spe&#10;        else:&#10;            evs = [4, 252, 0, 0, 0, 252]  # 4 HP / 252 Atk / 252 Spe&#10;    ivs = list(pol.default_ivs)&#10;    stats = pinfo.compute_raw_stats(species, evs, ivs, pol.level, pol.default_nature)&#10;    return PokemonStats(*stats)&#10;&#10;&#10;# ------------------------- Known item -&gt; stat modifiers --------------------------&#10;&#10;def _is_unevolved(pinfo: &quot;PokemonInfo&quot;, species: str) -&gt; bool:&#10;    try:&#10;        info = pinfo.get(species)&#10;        # If it has evolutions, it's unevolved. Some species have branching/alt forms.&#10;        return bool(info.evos)&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def apply_item_stat_modifiers(pinfo: &quot;PokemonInfo&quot;, species: str, item: Optional[str], stats: PokemonStats) -&gt; PokemonStats:&#10;    &quot;&quot;&quot;Apply stat-side item multipliers to a PokemonStats snapshot.&#10;&#10;    Only items that *modify stats* (not damage multipliers) are applied here, to&#10;    preserve correct damage-ordering elsewhere (e.g., Life Orb is a damage mod).&#10;    &quot;&quot;&quot;&#10;    if not item:&#10;        return stats&#10;    it = item.lower()&#10;&#10;    hp, atk, deff, spa, spd, spe = stats.hp, stats.atk, stats.def_, stats.spa, stats.spd, stats.spe&#10;&#10;    # Choice items&#10;    if it == &quot;choiceband&quot;:&#10;        atk = int(atk * 1.5)&#10;    elif it == &quot;choicespecs&quot;:&#10;        spa = int(spa * 1.5)&#10;    elif it == &quot;choicescarf&quot;:&#10;        spe = int(spe * 1.5)&#10;&#10;    # Assault Vest&#10;    if it == &quot;assaultvest&quot;:&#10;        spd = int(spd * 1.5)&#10;&#10;    # Eviolite (only if unevolved)&#10;    if it == &quot;eviolite&quot; and _is_unevolved(pinfo, species):&#10;        deff = int(deff * 1.5)&#10;        spd = int(spd * 1.5)&#10;&#10;    # Species-specific doublers&#10;    sid = to_id_str(species)&#10;    if it == &quot;thickclub&quot; and sid in (&quot;cubone&quot;, &quot;marowak&quot;, &quot;marowakalola&quot;, &quot;marowakalolan&quot;):&#10;        atk = atk * 2&#10;    if it == &quot;lightball&quot; and sid == &quot;pikachu&quot;:&#10;        atk = atk * 2&#10;        spa = spa * 2&#10;    if sid == &quot;clamperl&quot;:&#10;        if it == &quot;deepseatooth&quot;:&#10;            spa = spa * 2&#10;        elif it == &quot;deepseascale&quot;:&#10;            spd = spd * 2&#10;    # Additional species/item-aware modifiers using Showdown data (if available)&#10;    # Metal Powder: Ditto Def/SpD x1.5 when not transformed&#10;    if it == &quot;metalpowder&quot; and sid == &quot;ditto&quot;:&#10;        # Transformation volatile not tracked here; assume untransformed if item present&#10;        deff = int(deff * 1.5)&#10;        spd = int(spd * 1.5)&#10;    # Quick Powder: Ditto Speed x2 when untransformed&#10;    if it == &quot;quickpowder&quot; and sid == &quot;ditto&quot;:&#10;        spe = int(spe * 2)&#10;    # Soul Dew: Latias/Latios SpA/SpD x1.2 (modern effect)&#10;    if it == &quot;souldew&quot; and sid in {&quot;latias&quot;,&quot;latios&quot;}:&#10;        spa = int(spa * 1.2)&#10;        spd = int(spd * 1.2)&#10;    # Use dex_registry for any explicit stat modifiers encoded (future-proof)&#10;    try:&#10;        data = dex_registry.get_item(it)&#10;        if isinstance(data, dict):&#10;            # Custom extension: if item data has keys like 'boostAtk':1.5 etc.&#10;            for key, mult in data.items():&#10;                if not isinstance(mult, (int, float)): continue&#10;                if key.lower() == 'boostatk': atk = int(atk * mult)&#10;                elif key.lower() == 'boostdef': deff = int(deff * mult)&#10;                elif key.lower() == 'boostspa': spa = int(spa * mult)&#10;                elif key.lower() == 'boostspd': spd = int(spd * mult)&#10;                elif key.lower() == 'boostspe': spe = int(spe * mult)&#10;    except Exception:&#10;        pass&#10;    return PokemonStats(hp, atk, deff, spa, spd, spe)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Data/stat_effects.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Data/stat_effects.py" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;def _to_id(s: str) -&gt; str:&#10;    return &quot;&quot;.join(ch.lower() for ch in str(s) if ch.isalnum())&#10;&#10;# ------------------------- Stage change application ------------------------------&#10;&#10;_PREVENT_DROP_ALL = {&quot;clearbody&quot;,&quot;fullmetalbody&quot;,&quot;whitesmoke&quot;}&#10;_PREVENT_DROP_ATK = {&quot;hypercutter&quot;,&quot;guarddog&quot;}   # guard dog also boosts on attempt&#10;_PREVENT_DROP_DEF = {&quot;bigpecks&quot;}&#10;_PREVENT_DROP_ACC = {&quot;keeneye&quot;}&#10;_REFLECT_DROPS = {&quot;mirrorarmor&quot;}&#10;&#10;_SIMPLE = &quot;simple&quot;&#10;_CONTRARY = &quot;contrary&quot;&#10;_DEFIANT = &quot;defiant&quot;&#10;_COMPETITIVE = &quot;competitive&quot;&#10;_OPPORTUNIST = &quot;opportunist&quot;&#10;&#10;def _apply_simple_contrary(ability: str, deltas: Dict[str, int]) -&gt; Dict[str, int]:&#10;    out = deltas.copy()&#10;    if ability == _SIMPLE:&#10;        for k in out: out[k] *= 2&#10;    if ability == _CONTRARY:&#10;        for k in out: out[k] *= -1&#10;    return out&#10;&#10;def _clamp_stage(x: int) -&gt; int:&#10;    return max(-6, min(6, x))&#10;&#10;def apply_stage_change(&#10;    target: PokemonState,&#10;    deltas: Dict[str, int],&#10;    *,&#10;    source: Optional[PokemonState] = None,&#10;    cause: str = &quot;&quot;,&#10;    dex: Optional[Dict[str, Dict[str, Any]]] = None,&#10;) -&gt; Dict[str, int]:&#10;    &quot;&quot;&quot;&#10;    Apply stage deltas to target, honoring prevention/redirect and reactive abilities/items.&#10;&#10;    Returns the *actually applied* deltas after prevention/reflection and Simple/Contrary.&#10;    May mutate target/item/ability (e.g., White Herb, Mirror Herb) and source (Mirror Armor reflect).&#10;    &quot;&quot;&quot;&#10;    ability_t = _to_id(target.ability or &quot;&quot;)&#10;    item_t = _to_id(target.item or &quot;&quot;)&#10;    ability_s = _to_id(source.ability) if source and source.ability else &quot;&quot;&#10;&#10;    # 1) Try to prevent or reflect drops (only for negative deltas from opponent)&#10;    attempted_negative = any(v &lt; 0 for v in deltas.values())&#10;    reflected = False&#10;    prevented = False&#10;    if attempted_negative and source and source is not target:&#10;        # Clear Amulet blocks all opposing-lowered stats&#10;        if item_t == &quot;clearamulet&quot;:&#10;            prevented = True&#10;        # Ability-based prevention&#10;        if ability_t in _PREVENT_DROP_ALL:&#10;            prevented = True&#10;        # Slot-specific prevention&#10;        if deltas.get(&quot;atk&quot;, 0) &lt; 0 and ability_t in _PREVENT_DROP_ATK:&#10;            prevented = True&#10;        if deltas.get(&quot;def&quot;, 0) &lt; 0 and ability_t in _PREVENT_DROP_DEF:&#10;            prevented = True&#10;        if deltas.get(&quot;accuracy&quot;, 0) &lt; 0 and ability_t in _PREVENT_DROP_ACC:&#10;            prevented = True&#10;        # Mirror Armor reflects&#10;        if ability_t in _REFLECT_DROPS and not prevented:&#10;            # reflect to source, nothing applied to target&#10;            reflected = True&#10;            prevented = True&#10;            # Recursively apply to source as if from target&#10;            if source:&#10;                apply_stage_change(source, deltas, source=target, cause=cause, dex=dex)&#10;&#10;        # Guard Dog: prevents Attack drop and raises Attack&#10;        if ability_t == &quot;guarddog&quot; and deltas.get(&quot;atk&quot;, 0) &lt; 0:&#10;            prevented = True&#10;            # boost Atk by 1&#10;            d = {&quot;atk&quot;: 1}&#10;            _apply_stage_internal(target, _apply_simple_contrary(ability_t, d))&#10;&#10;    # 2) If prevented (and not reflected), trigger reactions and bail&#10;    if prevented and not reflected:&#10;        # Defiant/Competitive trigger if something *attempted* to lower a stat but was prevented?&#10;        # In-game these trigger when stats are *actually lowered*. We therefore DO NOT trigger them here.&#10;        return {k: 0 for k in deltas}&#10;&#10;    # 3) Apply Simple/Contrary&#10;    deltas2 = _apply_simple_contrary(ability_t, deltas)&#10;&#10;    # 4) Apply and clamp&#10;    applied = _apply_stage_internal(target, deltas2)&#10;&#10;    # 5) White Herb if any negative after application&#10;    if any(v &lt; 0 for v in applied.values()) and item_t == &quot;whiteherb&quot;:&#10;        # cures *all* lowered stats by 1 stage&#10;        for k in list(target.stats.boosts.keys()):&#10;            if target.stats.boosts[k] &lt; 0:&#10;                target.stats.boosts[k] = min(0, target.stats.boosts[k] + 1)&#10;        # Mark consumption (caller should clear item if they want to simulate item loss)&#10;        target.item = None  # consumed&#10;&#10;    # 6) Reactive triggers: Defiant/Competitive, Adrenaline Orb, Opportunist/Mirror Herb&#10;    lowered = any(v &lt; 0 for v in applied.values())&#10;    if lowered and source and source is not target:&#10;        if ability_t == _DEFIANT:&#10;            _apply_stage_internal(target, _apply_simple_contrary(ability_t, {&quot;atk&quot;: 2}))&#10;        if ability_t == _COMPETITIVE:&#10;            _apply_stage_internal(target, _apply_simple_contrary(ability_t, {&quot;spa&quot;: 2}))&#10;        # Adrenaline Orb (item): +1 Speed when holder's stats are lowered by an opponent&#10;        if item_t == &quot;adrenalineorb&quot;:&#10;            _apply_stage_internal(target, {&quot;spe&quot;: 1})&#10;            target.item = None  # consumed&#10;&#10;    # Opportunist (copies an opponent's stat increases when they increase)&#10;    if source and source is not target:&#10;        ability_u = _to_id(source.ability or &quot;&quot;)&#10;        # If the *source* had positive deltas applied, target with Opportunist will copy them&#10;        if ability_t == _OPPORTUNIST and any(v &gt; 0 for v in deltas.values()):&#10;            plus = {k: v for k, v in deltas.items() if v &gt; 0}&#10;            if plus:&#10;                _apply_stage_internal(target, _apply_simple_contrary(ability_t, plus))&#10;        # Mirror Herb (item) copies opponent's boosts once&#10;        if item_t == &quot;mirrorherb&quot; and any(v &gt; 0 for v in deltas.values()):&#10;            plus = {k: v for k, v in deltas.items() if v &gt; 0}&#10;            if plus:&#10;                _apply_stage_internal(target, plus)&#10;                target.item = None  # consumed&#10;&#10;    return applied&#10;&#10;def _apply_stage_internal(target: PokemonState, deltas: Dict[str, int]) -&gt; Dict[str, int]:&#10;    # Ensure all boost keys exist&#10;    boosts = target.stats.boosts or {}&#10;    for k in STATS + (&quot;accuracy&quot;,&quot;evasion&quot;):&#10;        boosts[k] = int(boosts.get(k, 0))&#10;&#10;    # Apply and clamp&#10;    for k, dv in deltas.items():&#10;        if k not in boosts:&#10;            continue&#10;        boosts[k] = _clamp_stage(boosts[k] + int(dv))&#10;&#10;    target.stats.boosts = boosts&#10;    return deltas&#10;&#10;# ------------------------- Switch-in triggers ------------------------------------&#10;&#10;_ONE_TIME_ON_SWITCH = {&quot;intrepidsword&quot;,&quot;dauntlessshield&quot;}  # once per battle&#10;&#10;def on_switch_in(user: PokemonState, opponents: List[PokemonState]) -&gt; None:&#10;    &quot;&quot;&quot;Handle common entry abilities/items that affect stages immediately.&#10;&#10;    Applies:&#10;      - Intimidate: lowers foe Atk by 1, with Mirror Armor bounce, Guard Dog +1 Atk, prevention abilities.&#10;      - Download: +1 Atk or SpA based on lower opposing defensive stat.&#10;      - Intrepid Sword / Dauntless Shield: +1 Atk/Def (once per battle).&#10;    &quot;&quot;&quot;&#10;    abil = _to_id(user.ability or &quot;&quot;)&#10;    # Intimidate&#10;    if abil == &quot;intimidate&quot;:&#10;        for opp in opponents:&#10;            apply_stage_change(opp, {&quot;atk&quot;: -1}, source=user, cause=&quot;intimidate&quot;)&#10;&#10;    # Download&#10;    if abil == &quot;download&quot; and opponents:&#10;        # Compare sum or first opponent's current raw Def/SpD (we use the first active foe)&#10;        opp = opponents[0]&#10;        defn = int(opp.stats.raw.get(&quot;def&quot;, 0))&#10;        spd = int(opp.stats.raw.get(&quot;spd&quot;, 0))&#10;        if defn &gt;= spd:&#10;            apply_stage_change(user, {&quot;spa&quot;: 1}, source=user, cause=&quot;download&quot;)&#10;        else:&#10;            apply_stage_change(user, {&quot;atk&quot;: 1}, source=user, cause=&quot;download&quot;)&#10;&#10;    # Intrepid Sword / Dauntless Shield&#10;    if abil in _ONE_TIME_ON_SWITCH:&#10;        flag = f&quot;used_{abil}_once&quot;&#10;        # We'll tuck one-time flags into the state via volatiles set for simplicity&#10;        if flag not in user.volatiles:&#10;            if abil == &quot;intrepidsword&quot;:&#10;                apply_stage_change(user, {&quot;atk&quot;: 1}, source=user, cause=abil)&#10;            elif abil == &quot;dauntlessshield&quot;:&#10;                apply_stage_change(user, {&quot;def&quot;: 1}, source=user, cause=abil)&#10;            user.volatiles.add(flag)&#10;&#10;# ------------------------- Passive multiplicative modifiers ----------------------&#10;&#10;def compute_passive_multipliers(state: PokemonState, field: Dict[str, Any]) -&gt; Dict[str, float]:&#10;    &quot;&quot;&quot;Return per-stat multiplicative modifiers from abilities/items that are NOT stage-based.&#10;&#10;    Examples:&#10;        - Huge Power/Pure Power: ×2 Attack&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Hustle: ×1.5 Attack (accuracy penalty is handled elsewhere)&#10;        - Guts: ignore burn Attack halving (handled in damage code), and ×1.5 Attack when statused&#10;        - Marvel Scale: ×1.5 Defense when statused&#10;        - Fluffy/Ice Scales: category-based damage halving are better treated in damage layer&#10;        - Orichalcum Pulse: Attack ×1.33 in sun (we include as 1.33 here; also sets Sun elsewhere)&#10;        - Supreme Overlord: damage mod; handle in damage layer&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Hustle: ×1.5 Attack (accuracy penalty is handled elsewhere)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;        - Gorilla Tactics: ×1.5 Attack (with move-lock; we only return the multiplier)&#10;" />
              <option name="updatedContent" value="# stat_effects.py&#13;&#10;&quot;&quot;&quot;&#13;&#10;Stat change + passive multipliers engine (abilities &amp; items), designed to&#13;&#10;cooperate with team_state.PokemonState snapshots and Showdown JSON (optional).&#13;&#10;&#13;&#10;It provides:&#13;&#10;- apply_stage_change(state, deltas, source=..., dex=...) -&gt; actual_applied_deltas&#13;&#10;- on_switch_in(user, opponents, dex, context) -&gt; mutates states for entry abilities/items&#13;&#10;- compute_passive_multipliers(state, field, dex) -&gt; dict per-STAT multiplicative mods&#13;&#10;- augment_grounded(state, field, dex) -&gt; sets state.grounded if determinable&#13;&#10;&#13;&#10;Notes:&#13;&#10;- This module mutates PokemonState.stats.boosts in-place for stages and may&#13;&#10;  mutate item/ability fields (e.g., consume White Herb) via convenience helpers.&#13;&#10;- We honor Simple (double stage magnitude) and Contrary (invert sign) when&#13;&#10;  applying stage deltas.&#13;&#10;- We honor &quot;prevention/redirect&quot; abilities/items: Clear Body/Full Metal Body/White Smoke,&#13;&#10;  Mirror Armor, Hyper Cutter, Big Pecks, Keen Eye, Clear Amulet, Guard Dog.&#13;&#10;- We trigger &quot;on stat lowered&quot; reactions: Defiant, Competitive, Adrenaline Orb item,&#13;&#10;  Mirror Herb (copy boosts once), Opportunist (copy boosts), and Eject Pack desire.&#13;&#10;&quot;&quot;&quot;&#13;&#10;&#13;&#10;from __future__ import annotations&#13;&#10;&#13;&#10;from dataclasses import dataclass&#13;&#10;from typing import Dict, Any, Optional, Tuple, List&#13;&#10;&#13;&#10;# Light dependency on team_state for the dataclass&#13;&#10;from .team_state import PokemonState, STATS&#13;&#10;from . import dex_registry&#13;&#10;&#13;&#10;def _to_id(s: str) -&gt; str:&#13;&#10;    return &quot;&quot;.join(ch.lower() for ch in str(s) if ch.isalnum())&#13;&#10;&#13;&#10;# ------------------------- Stage change application ------------------------------&#13;&#10;&#13;&#10;_PREVENT_DROP_ALL = {&quot;clearbody&quot;,&quot;fullmetalbody&quot;,&quot;whitesmoke&quot;}&#13;&#10;_PREVENT_DROP_ATK = {&quot;hypercutter&quot;,&quot;guarddog&quot;}   # guard dog also boosts on attempt&#13;&#10;_PREVENT_DROP_DEF = {&quot;bigpecks&quot;}&#13;&#10;_PREVENT_DROP_ACC = {&quot;keeneye&quot;}&#13;&#10;_REFLECT_DROPS = {&quot;mirrorarmor&quot;}&#13;&#10;&#13;&#10;_SIMPLE = &quot;simple&quot;&#13;&#10;_CONTRARY = &quot;contrary&quot;&#13;&#10;_DEFIANT = &quot;defiant&quot;&#13;&#10;_COMPETITIVE = &quot;competitive&quot;&#13;&#10;_OPPORTUNIST = &quot;opportunist&quot;&#13;&#10;&#13;&#10;def _apply_simple_contrary(ability: str, deltas: Dict[str, int]) -&gt; Dict[str, int]:&#13;&#10;    out = deltas.copy()&#13;&#10;    if ability == _SIMPLE:&#13;&#10;        for k in out: out[k] *= 2&#13;&#10;    if ability == _CONTRARY:&#13;&#10;        for k in out: out[k] *= -1&#13;&#10;    return out&#13;&#10;&#13;&#10;def _clamp_stage(x: int) -&gt; int:&#13;&#10;    return max(-6, min(6, x))&#13;&#10;&#13;&#10;def apply_stage_change(&#13;&#10;    target: PokemonState,&#13;&#10;    deltas: Dict[str, int],&#13;&#10;    *,&#13;&#10;    source: Optional[PokemonState] = None,&#13;&#10;    cause: str = &quot;&quot;,&#13;&#10;    dex: Optional[Dict[str, Dict[str, Any]]] = None,&#13;&#10;) -&gt; Dict[str, int]:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Apply stage deltas to target, honoring prevention/redirect and reactive abilities/items.&#13;&#10;&#13;&#10;    Returns the *actually applied* deltas after prevention/reflection and Simple/Contrary.&#13;&#10;    May mutate target/item/ability (e.g., White Herb, Mirror Herb) and source (Mirror Armor reflect).&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    ability_t = _to_id(target.ability or &quot;&quot;)&#13;&#10;    item_t = _to_id(target.item or &quot;&quot;)&#13;&#10;    ability_s = _to_id(source.ability) if source and source.ability else &quot;&quot;&#13;&#10;&#13;&#10;    # 1) Try to prevent or reflect drops (only for negative deltas from opponent)&#13;&#10;    attempted_negative = any(v &lt; 0 for v in deltas.values())&#13;&#10;    reflected = False&#13;&#10;    prevented = False&#13;&#10;    if attempted_negative and source and source is not target:&#13;&#10;        # Clear Amulet blocks all opposing-lowered stats&#13;&#10;        if item_t == &quot;clearamulet&quot;:&#13;&#10;            prevented = True&#13;&#10;        # Ability-based prevention&#13;&#10;        if ability_t in _PREVENT_DROP_ALL:&#13;&#10;            prevented = True&#13;&#10;        # Slot-specific prevention&#13;&#10;        if deltas.get(&quot;atk&quot;, 0) &lt; 0 and ability_t in _PREVENT_DROP_ATK:&#13;&#10;            prevented = True&#13;&#10;        if deltas.get(&quot;def&quot;, 0) &lt; 0 and ability_t in _PREVENT_DROP_DEF:&#13;&#10;            prevented = True&#13;&#10;        if deltas.get(&quot;accuracy&quot;, 0) &lt; 0 and ability_t in _PREVENT_DROP_ACC:&#13;&#10;            prevented = True&#13;&#10;        # Mirror Armor reflects&#13;&#10;        if ability_t in _REFLECT_DROPS and not prevented:&#13;&#10;            # reflect to source, nothing applied to target&#13;&#10;            reflected = True&#13;&#10;            prevented = True&#13;&#10;            # Recursively apply to source as if from target&#13;&#10;            if source:&#13;&#10;                apply_stage_change(source, deltas, source=target, cause=cause, dex=dex)&#13;&#10;&#13;&#10;        # Guard Dog: prevents Attack drop and raises Attack&#13;&#10;        if ability_t == &quot;guarddog&quot; and deltas.get(&quot;atk&quot;, 0) &lt; 0:&#13;&#10;            prevented = True&#13;&#10;            # boost Atk by 1&#13;&#10;            d = {&quot;atk&quot;: 1}&#13;&#10;            _apply_stage_internal(target, _apply_simple_contrary(ability_t, d))&#13;&#10;&#13;&#10;    # 2) If prevented (and not reflected), trigger reactions and bail&#13;&#10;    if prevented and not reflected:&#13;&#10;        # Defiant/Competitive trigger if something *attempted* to lower a stat but was prevented?&#13;&#10;        # In-game these trigger when stats are *actually lowered*. We therefore DO NOT trigger them here.&#13;&#10;        return {k: 0 for k in deltas}&#13;&#10;&#13;&#10;    # 3) Apply Simple/Contrary&#13;&#10;    deltas2 = _apply_simple_contrary(ability_t, deltas)&#13;&#10;&#13;&#10;    # 4) Apply and clamp&#13;&#10;    applied = _apply_stage_internal(target, deltas2)&#13;&#10;&#13;&#10;    # 5) White Herb if any negative after application&#13;&#10;    if any(v &lt; 0 for v in applied.values()) and item_t == &quot;whiteherb&quot;:&#13;&#10;        # cures *all* lowered stats by 1 stage&#13;&#10;        for k in list(target.stats.boosts.keys()):&#13;&#10;            if target.stats.boosts[k] &lt; 0:&#13;&#10;                target.stats.boosts[k] = min(0, target.stats.boosts[k] + 1)&#13;&#10;        # Mark consumption (caller should clear item if they want to simulate item loss)&#13;&#10;        target.item = None  # consumed&#13;&#10;&#13;&#10;    # 6) Reactive triggers: Defiant/Competitive, Adrenaline Orb, Opportunist/Mirror Herb&#13;&#10;    lowered = any(v &lt; 0 for v in applied.values())&#13;&#10;    if lowered and source and source is not target:&#13;&#10;        if ability_t == _DEFIANT:&#13;&#10;            _apply_stage_internal(target, _apply_simple_contrary(ability_t, {&quot;atk&quot;: 2}))&#13;&#10;        if ability_t == _COMPETITIVE:&#13;&#10;            _apply_stage_internal(target, _apply_simple_contrary(ability_t, {&quot;spa&quot;: 2}))&#13;&#10;        # Adrenaline Orb (item): +1 Speed when holder's stats are lowered by an opponent&#13;&#10;        if item_t == &quot;adrenalineorb&quot;:&#13;&#10;            _apply_stage_internal(target, {&quot;spe&quot;: 1})&#13;&#10;            target.item = None  # consumed&#13;&#10;&#13;&#10;    # Opportunist (copies an opponent's stat increases when they increase)&#13;&#10;    if source and source is not target:&#13;&#10;        ability_u = _to_id(source.ability or &quot;&quot;)&#13;&#10;        # If the *source* had positive deltas applied, target with Opportunist will copy them&#13;&#10;        if ability_t == _OPPORTUNIST and any(v &gt; 0 for v in deltas.values()):&#13;&#10;            plus = {k: v for k, v in deltas.items() if v &gt; 0}&#13;&#10;            if plus:&#13;&#10;                _apply_stage_internal(target, _apply_simple_contrary(ability_t, plus))&#13;&#10;        # Mirror Herb (item) copies opponent's boosts once&#13;&#10;        if item_t == &quot;mirrorherb&quot; and any(v &gt; 0 for v in deltas.values()):&#13;&#10;            plus = {k: v for k, v in deltas.items() if v &gt; 0}&#13;&#10;            if plus:&#13;&#10;                _apply_stage_internal(target, plus)&#13;&#10;                target.item = None  # consumed&#13;&#10;&#13;&#10;    return applied&#13;&#10;&#13;&#10;def _apply_stage_internal(target: PokemonState, deltas: Dict[str, int]) -&gt; Dict[str, int]:&#13;&#10;    # Ensure all boost keys exist&#13;&#10;    boosts = target.stats.boosts or {}&#13;&#10;    for k in STATS + (&quot;accuracy&quot;,&quot;evasion&quot;):&#13;&#10;        boosts[k] = int(boosts.get(k, 0))&#13;&#10;&#13;&#10;    # Apply and clamp&#13;&#10;    for k, dv in deltas.items():&#13;&#10;        if k not in boosts:&#13;&#10;            continue&#13;&#10;        boosts[k] = _clamp_stage(boosts[k] + int(dv))&#13;&#10;&#13;&#10;    target.stats.boosts = boosts&#13;&#10;    return deltas&#13;&#10;&#13;&#10;# ------------------------- Switch-in triggers ------------------------------------&#13;&#10;&#13;&#10;_ONE_TIME_ON_SWITCH = {&quot;intrepidsword&quot;,&quot;dauntlessshield&quot;}  # once per battle&#13;&#10;&#13;&#10;def on_switch_in(user: PokemonState, opponents: List[PokemonState]) -&gt; None:&#13;&#10;    &quot;&quot;&quot;Handle common entry abilities/items that affect stages immediately.&#13;&#10;&#13;&#10;    Applies:&#13;&#10;      - Intimidate: lowers foe Atk by 1, with Mirror Armor bounce, Guard Dog +1 Atk, prevention abilities.&#13;&#10;      - Download: +1 Atk or SpA based on lower opposing defensive stat.&#13;&#10;      - Intrepid Sword / Dauntless Shield: +1 Atk/Def (once per battle).&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    abil = _to_id(user.ability or &quot;&quot;)&#13;&#10;    # Intimidate&#13;&#10;    if abil == &quot;intimidate&quot;:&#13;&#10;        for opp in opponents:&#13;&#10;            apply_stage_change(opp, {&quot;atk&quot;: -1}, source=user, cause=&quot;intimidate&quot;)&#13;&#10;&#13;&#10;    # Download&#13;&#10;    if abil == &quot;download&quot; and opponents:&#13;&#10;        # Compare sum or first opponent's current raw Def/SpD (we use the first active foe)&#13;&#10;        opp = opponents[0]&#13;&#10;        defn = int(opp.stats.raw.get(&quot;def&quot;, 0))&#13;&#10;        spd = int(opp.stats.raw.get(&quot;spd&quot;, 0))&#13;&#10;        if defn &gt;= spd:&#13;&#10;            apply_stage_change(user, {&quot;spa&quot;: 1}, source=user, cause=&quot;download&quot;)&#13;&#10;        else:&#13;&#10;            apply_stage_change(user, {&quot;atk&quot;: 1}, source=user, cause=&quot;download&quot;)&#13;&#10;&#13;&#10;    # Intrepid Sword / Dauntless Shield&#13;&#10;    if abil in _ONE_TIME_ON_SWITCH:&#13;&#10;        flag = f&quot;used_{abil}_once&quot;&#13;&#10;        # We'll tuck one-time flags into the state via volatiles set for simplicity&#13;&#10;        if flag not in user.volatiles:&#13;&#10;            if abil == &quot;intrepidsword&quot;:&#13;&#10;                apply_stage_change(user, {&quot;atk&quot;: 1}, source=user, cause=abil)&#13;&#10;            elif abil == &quot;dauntlessshield&quot;:&#13;&#10;                apply_stage_change(user, {&quot;def&quot;: 1}, source=user, cause=abil)&#13;&#10;            user.volatiles.add(flag)&#13;&#10;&#13;&#10;# ------------------------- Passive multiplicative modifiers ----------------------&#13;&#10;&#13;&#10;def compute_passive_multipliers(state: PokemonState, field: Dict[str, Any]) -&gt; Dict[str, float]:&#13;&#10;    &quot;&quot;&quot;Return per-stat multiplicative modifiers from abilities/items that are NOT stage-based.&#13;&#10;&#13;&#10;    Extended to include Solar Power, Flower Gift, Protosynthesis/Quark Drive (non-speed stats),&#13;&#10;    and optional registry-driven custom boost keys: boostAtk/Def/SpA/SpD/Spe.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    abil = _to_id(state.ability or &quot;&quot;)&#13;&#10;    status = (state.status or &quot;&quot;).lower()&#13;&#10;    weather = (field.get(&quot;weather&quot;) or &quot;&quot;).lower()&#13;&#10;    terrain = (field.get(&quot;terrain&quot;) or &quot;&quot;).lower()&#13;&#10;&#13;&#10;    mults = {&quot;atk&quot;: 1.0, &quot;def&quot;: 1.0, &quot;spa&quot;: 1.0, &quot;spd&quot;: 1.0, &quot;spe&quot;: 1.0}&#13;&#10;&#13;&#10;    if abil in {&quot;hugepower&quot;,&quot;purepower&quot;}:&#13;&#10;        mults[&quot;atk&quot;] *= 2.0&#13;&#10;    if abil == &quot;gorillatactics&quot;:&#13;&#10;        mults[&quot;atk&quot;] *= 1.5&#13;&#10;    if abil == &quot;hustle&quot;:&#13;&#10;        mults[&quot;atk&quot;] *= 1.5&#13;&#10;    if abil == &quot;guts&quot; and status in {&quot;brn&quot;,&quot;psn&quot;,&quot;tox&quot;,&quot;par&quot;,&quot;slp&quot;}:&#13;&#10;        mults[&quot;atk&quot;] *= 1.5&#13;&#10;    if abil == &quot;marvelscale&quot; and status in {&quot;brn&quot;,&quot;psn&quot;,&quot;tox&quot;,&quot;par&quot;,&quot;slp&quot;}:&#13;&#10;        mults[&quot;def&quot;] *= 1.5&#13;&#10;    if abil == &quot;orichalcumpulse&quot; and weather == &quot;sun&quot;:&#13;&#10;        mults[&quot;atk&quot;] *= 4/3&#13;&#10;    if abil == &quot;solarpower&quot; and weather == &quot;sun&quot;:&#13;&#10;        mults[&quot;spa&quot;] *= 1.5&#13;&#10;    if abil == &quot;flowergift&quot; and weather == &quot;sun&quot;:&#13;&#10;        mults[&quot;atk&quot;] *= 1.5&#13;&#10;        mults[&quot;spd&quot;] *= 1.5&#13;&#10;    # Protosynthesis / Quark Drive non-speed stat boost (speed handled elsewhere)&#13;&#10;    if abil in {&quot;protosynthesis&quot;,&quot;quarkdrive&quot;}:&#13;&#10;        active = False&#13;&#10;        if abil == &quot;protosynthesis&quot; and weather == &quot;sun&quot;:&#13;&#10;            active = True&#13;&#10;        if abil == &quot;quarkdrive&quot; and terrain == &quot;electric&quot;:&#13;&#10;            active = True&#13;&#10;        if active:&#13;&#10;            base_raw = state.stats.raw if state.stats else {}&#13;&#10;            subset = { 'atk': base_raw.get('atk',0), 'def': base_raw.get('def',0), 'spa': base_raw.get('spa',0), 'spd': base_raw.get('spd',0) }&#13;&#10;            if subset:&#13;&#10;                hi = max(subset.items(), key=lambda kv: kv[1])[0]&#13;&#10;                mults[hi] *= 1.3&#13;&#10;    # Registry-driven generic ability boosts&#13;&#10;    try:&#13;&#10;        adata = dex_registry.get_ability(abil)&#13;&#10;        if isinstance(adata, dict):&#13;&#10;            for k, v in adata.items():&#13;&#10;                if not isinstance(v, (int,float)): continue&#13;&#10;                lk = k.lower()&#13;&#10;                if lk == 'boostatk': mults['atk'] *= v&#13;&#10;                elif lk == 'boostdef': mults['def'] *= v&#13;&#10;                elif lk == 'boostspa': mults['spa'] *= v&#13;&#10;                elif lk == 'boostspd': mults['spd'] *= v&#13;&#10;                elif lk == 'boostspe': mults['spe'] *= v&#13;&#10;    except Exception:&#13;&#10;        pass&#13;&#10;    return mults&#13;&#10;&#13;&#10;# ------------------------- Groundedness ------------------------------------------&#13;&#10;&#13;&#10;def augment_grounded(state: PokemonState, field: Dict[str, Any]) -&gt; bool:&#13;&#10;    &quot;&quot;&quot;Infer `state.grounded` when possible.&#13;&#10;&#13;&#10;    Grounded if:&#13;&#10;      - Not Flying-type, not Levitate, not on Air Balloon&#13;&#10;      - Or under Gravity, or affected by Smack Down/Thousand Arrows, or holding Iron Ball&#13;&#10;      - Ingrain grounds the user; Magnet Rise/Telekinesis remove groundedness (ignored during Gravity)&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    types = {t for t in state.types if t}&#13;&#10;    abil = _to_id(state.ability or &quot;&quot;)&#13;&#10;    item = _to_id(state.item or &quot;&quot;)&#13;&#10;    vols = {v for v in (state.volatiles or set())}&#13;&#10;    gravity = bool(field.get(&quot;gravity&quot;, False))&#13;&#10;&#13;&#10;    grounded = True&#13;&#10;    if gravity:&#13;&#10;        grounded = True&#13;&#10;    else:&#13;&#10;        if &quot;flying&quot; in types or abil == &quot;levitate&quot; or item == &quot;airballoon&quot; or &quot;magnetrise&quot; in vols or &quot;telekinesis&quot; in vols:&#13;&#10;            grounded = False&#13;&#10;        if &quot;smackdown&quot; in vols or &quot;thousandarrows&quot; in vols or item == &quot;ironball&quot; or &quot;ingrain&quot; in vols:&#13;&#10;            grounded = True&#13;&#10;&#13;&#10;    state.grounded = grounded&#13;&#10;    return grounded&#13;&#10;&#13;&#10;&#13;&#10;# ------------------------- Switch-out cleanup ------------------------------------&#13;&#10;&#13;&#10;def on_switch_out(state: PokemonState) -&gt; None:&#13;&#10;    &quot;&quot;&quot;Reset volatile stages and common flags that clear on leaving the field.&quot;&quot;&quot;&#13;&#10;    # Reset stat stages&#13;&#10;    state.stats.boosts = {k: 0 for k in (list(STATS) + [&quot;accuracy&quot;,&quot;evasion&quot;])}&#13;&#10;    # Clear most volatiles; keep long-term battle notes (like used_intrepidsword_once) if you want&#13;&#10;    state.volatiles = {v for v in state.volatiles if v.startswith(&quot;used_&quot;)}&#13;&#10;    # End effects like Unburden (caller should track activation); we conservatively clear any hint flags&#13;&#10;    # Item stays whatever the server says; if it was consumed it should already be None/consumed_item set&#13;&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Models/GPT_Model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Models/GPT_Model.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;GPT-based AI model for Pokemon battle decisions&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import os&#10;import json&#10;from typing import Dict, List, Optional, Any&#10;import asyncio&#10;&#10;# Third-party imports&#10;# import openai&#10;# import torch&#10;# from transformers import GPTModel, GPTTokenizer&#10;# import numpy as np&#10;&#10;# Local imports&#10;# from Data.battle_helper import BattleHelper&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;# from Data.poke_env_pokemon_info import PokemonInfo&#10;&#10;class GPTModel:&#10;    &quot;&quot;&quot;GPT-based model for Pokemon battle AI&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Models/stockfish_model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Models/stockfish_model.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;&#10;import json, os&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, List, Optional, Tuple&#10;import logging&#10;&#10;from Data.battle_runtime import (&#10;    get_state,&#10;    predict_order_for_ids,&#10;    estimate_damage,&#10;    would_fail,&#10;)&#10;from Data.poke_env_battle_environment import snapshot as snapshot_battle&#10;from Data.poke_env_moves_info import MovesInfo&#10;&#10;# ---------------- Weights ----------------&#10;_DEFAULT_WEIGHTS: Dict[str, float] = {&#10;    &quot;expected_mult&quot;: 1.0,&#10;    &quot;go_first_bonus&quot;: 0.4,&#10;    &quot;opp_dmg_penalty&quot;: 1.0,&#10;    &quot;survival_bonus&quot;: 0.0,&#10;    &quot;accuracy_mult&quot;: 0.0,&#10;    &quot;effectiveness_mult&quot;: 0.0,&#10;    &quot;ko_bonus&quot;: 1.0,&#10;    # Switching&#10;    &quot;switch_outgoing_mult&quot;: 1.0,&#10;    &quot;switch_incoming_penalty&quot;: 1.0,&#10;}&#10;&#10;def _load_weights(path: str = os.path.join(&quot;Models&quot;, &quot;weights.json&quot;)) -&gt; Dict[str, float]:&#10;    try:&#10;        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            raw = json.load(f)&#10;        w = dict(_DEFAULT_WEIGHTS)&#10;        for k, v in raw.items():&#10;            if k in w:&#10;                try: w[k] = float(v)&#10;                except Exception: pass&#10;        return w&#10;    except Exception:&#10;        return dict(_DEFAULT_WEIGHTS)&#10;&#10;# ---------------- Helpers ----------------&#10;&#10;def _acc_to_prob(acc) -&gt; float:&#10;    if acc is True or acc is None: return 1.0&#10;    try:&#10;        x = float(acc)&#10;        return x / 100.0 if x &gt; 1.0 else max(0.0, min(1.0, x))&#10;    except Exception:&#10;        return 1.0&#10;&#10;def _hp_frac(ps) -&gt; float:&#10;    try:&#10;        if ps and ps.max_hp:&#10;            return max(0.0, min(1.0, (ps.current_hp or ps.max_hp) / ps.max_hp))&#10;    except Exception: pass&#10;    return 1.0&#10;&#10;def _expected_damage_fraction(state, atk_key: str, dfd_key: str, move_id: str, mi: MovesInfo) -&gt; Tuple[float, Dict[str, Any]]:&#10;    dmg = estimate_damage(state, atk_key, dfd_key, move_id, mi, is_critical=False)&#10;    rolls = dmg.get(&quot;rolls&quot;) or []&#10;    if not rolls:&#10;        return 0.0, dmg&#10;    dfd = state.team.ours.get(dfd_key) or state.team.opponent.get(dfd_key)&#10;    max_hp = int(getattr(dfd, &quot;max_hp&quot;, 0) or getattr(dfd, &quot;stats&quot;, {}).raw.get(&quot;hp&quot;, 1) or 1)&#10;    return (float(sum(rolls)) / (len(rolls) * max_hp)), dmg&#10;&#10;_COMMON_STAB = {&#10;    &quot;normal&quot;: [&quot;return&quot;,&quot;bodyslam&quot;],&#10;    &quot;fire&quot;: [&quot;flamethrower&quot;,&quot;fireblast&quot;],&#10;    &quot;water&quot;: [&quot;surf&quot;,&quot;hydropump&quot;],&#10;    &quot;electric&quot;: [&quot;thunderbolt&quot;,&quot;thunder&quot;],&#10;    &quot;grass&quot;: [&quot;energyball&quot;,&quot;leafstorm&quot;],&#10;    &quot;ice&quot;: [&quot;icebeam&quot;,&quot;blizzard&quot;],&#10;    &quot;fighting&quot;: [&quot;closecombat&quot;,&quot;drainpunch&quot;],&#10;    &quot;poison&quot;: [&quot;sludgebomb&quot;,&quot;gunkshot&quot;],&#10;    &quot;ground&quot;: [&quot;earthquake&quot;,&quot;earthpower&quot;],&#10;    &quot;flying&quot;: [&quot;hurricane&quot;,&quot;bravebird&quot;],&#10;    &quot;psychic&quot;: [&quot;psychic&quot;,&quot;psyshock&quot;],&#10;    &quot;bug&quot;: [&quot;bugbuzz&quot;,&quot;leechlife&quot;],&#10;    &quot;rock&quot;: [&quot;stoneedge&quot;,&quot;rockslide&quot;],&#10;    &quot;ghost&quot;: [&quot;shadowball&quot;,&quot;poltergeist&quot;],&#10;    &quot;dragon&quot;: [&quot;dracometeor&quot;,&quot;dragonpulse&quot;],&#10;    &quot;dark&quot;: [&quot;darkpulse&quot;,&quot;crunch&quot;],&#10;    &quot;steel&quot;: [&quot;flashcannon&quot;,&quot;ironhead&quot;],&#10;    &quot;fairy&quot;: [&quot;moonblast&quot;,&quot;playrough&quot;],&#10;}&#10;&#10;def _opp_best_on_target(state, opp_key: str, target_key: str, mi: MovesInfo) -&gt; float:&#10;    opp = state.team.opponent[opp_key]&#10;    best = 0.0&#10;    mv_list = [m for m in (opp.moves or []) if getattr(m, 'id', None)]&#10;    if mv_list:&#10;        for mv in mv_list:&#10;            if (getattr(mv, 'category', '') or '').lower() == 'status' or (getattr(mv, 'base_power', 0) or 0) &lt;= 0:&#10;                continue&#10;            frac, _ = _expected_damage_fraction(state, opp_key, target_key, mv.id, mi)&#10;            best = max(best, frac * _acc_to_prob(getattr(mv, 'accuracy', None)))&#10;        return best&#10;    for t in opp.types or []:&#10;        for mid in _COMMON_STAB.get((t or '').lower(), [])[:2]:&#10;            try:&#10;                frac, _ = _expected_damage_fraction(state, opp_key, target_key, mid, mi)&#10;                raw = mi.raw(mid) or {}&#10;                best = max(best, frac * _acc_to_prob(raw.get('accuracy')))&#10;            except Exception: continue&#10;    for mid in (&quot;icebeam&quot;,&quot;closecombat&quot;,&quot;earthquake&quot;):&#10;        try:&#10;            frac, _ = _expected_damage_fraction(state, opp_key, target_key, mid, mi)&#10;            raw = mi.raw(mid) or {}&#10;            best = max(best, frac * _acc_to_prob(raw.get('accuracy')))&#10;        except Exception: continue&#10;    return best&#10;&#10;# ---------------- Data container ----------------&#10;@dataclass&#10;class ChosenAction:&#10;    kind: str&#10;    move_id: Optional[str] = None&#10;    switch_species: Optional[str] = None&#10;    debug: Optional[Dict[str, Any]] = None&#10;&#10;# ---------------- Engine ----------------&#10;class StockfishModel:&#10;    def __init__(self, battle_format: str = 'gen9ou'):&#10;        self.battle_format = battle_format&#10;        self._W = _load_weights()&#10;        self._depth = 1&#10;        self._branching = 3&#10;        self._softmin_temp: float = 0.0  # 0 =&gt; hard minimax, &gt;0 =&gt; softmin over opponent replies&#10;        # Verbose think debug printing (terminal). Enable with env POKECHAD_THINK_DEBUG=1&#10;        try:&#10;            import os as _os&#10;            self._verbose = bool(int(_os.environ.get('POKECHAD_THINK_DEBUG', '0')))&#10;        except Exception:&#10;            self._verbose = False&#10;&#10;            for k,p in side.items():&#10;                if getattr(p,'is_active',False) and getattr(p,'current_hp',0) &gt; 0: return k&#10;            for k,p in side.items():&#10;                if (getattr(p,'status','') or '').lower()=='fnt': continue&#10;                if getattr(p,'current_hp',1) &gt; 0: return k&#10;            return None&#10;        my_key = _active(state.team.ours) if getattr(state,'team',None) else None&#10;        opp_key = _active(state.team.opponent) if getattr(state,'team',None) else None&#10;&#10;        legal_moves: List[Any] = list(getattr(battle,'available_moves',[]) or [])&#10;        legal_switches: List[Any] = list(getattr(battle,'available_switches',[]) or [])&#10;        # Define force_switch immediately so it's available for synthetic switch logic below&#10;        force_switch = bool(getattr(battle,'force_switch', False))&#10;        # If force switch but engine sees no available_switches, synthesize from team state (bench) to allow evaluation&#10;        if force_switch and not legal_switches and getattr(state,'team',None):&#10;            class _Stub:&#10;                __slots__ = ('species',)&#10;                def __init__(self, s): self.species = s&#10;            try:&#10;                active_species = None&#10;                if my_key and my_key in state.team.ours:&#10;                    active_species = getattr(state.team.ours[my_key],'species',None)&#10;                for k,ps in state.team.ours.items():&#10;                    if getattr(ps,'current_hp',0) &lt;= 0: continue&#10;                    sp = getattr(ps,'species',None)&#10;                    if not sp or sp==active_species: continue&#10;                    legal_switches.append(_Stub(sp))&#10;            except Exception: pass&#10;&#10;        # Only trust battle.force_switch flag; do not auto-set from (not legal_moves and legal_switches) because poke-env already handles this&#10;        # (force_switch already defined above)&#10;        # force_switch = bool(getattr(battle,'force_switch', False))&#10;&#10;        # Fallback: if active key missing, attempt to map from battle active pokemon species (helps after form changes / detailschange)&#10;        if not my_key:&#10;            try:&#10;                active_species = getattr(getattr(battle,'active_pokemon',None),'species',None)&#10;                if active_species:&#10;                    for k,p in getattr(state.team,'ours',{}).items():&#10;                        if getattr(p,'species',None)==active_species and (getattr(p,'current_hp',0)&gt;0):&#10;                            my_key = k; break&#10;            except Exception: pass&#10;        if not opp_key:&#10;            try:&#10;                opp_active_species = getattr(getattr(battle,'opponent_active_pokemon',None),'species',None) or getattr(getattr(battle,'opponent_active_pokemon',None),'base_species',None)&#10;                if opp_active_species:&#10;                    for k,p in getattr(state.team,'opponent',{}).items():&#10;                        if getattr(p,'species',None)==opp_active_species and (getattr(p,'current_hp',0)&gt;0):&#10;                            opp_key = k; break&#10;            except Exception: pass&#10;&#10;        opp_moves_known: List[str] = []&#10;        if opp_key:&#10;            try:&#10;                opp_ps = state.team.opponent.get(opp_key)&#10;                if opp_ps and getattr(opp_ps,'moves',None):&#10;                    opp_moves_known = [m.id for m in opp_ps.moves if getattr(m,'id',None)]&#10;            except Exception: pass&#10;&#10;        moves_eval: List[Dict[str, Any]] = []&#10;        switches_eval: List[Dict[str, Any]] = []  # ensure defined even if no evaluation block runs&#10;        skip_reason: Optional[str] = None&#10;        if not force_switch and my_key and opp_key:&#10;            opp_ps = state.team.opponent[opp_key]&#10;            opp_hp_frac = _hp_frac(opp_ps)&#10;            opp_max = int(getattr(opp_ps,'max_hp',0) or getattr(opp_ps,'stats',{}).raw.get('hp',1) or 1)&#10;            for mv in legal_moves:&#10;                mid = getattr(mv,'id',None) or getattr(mv,'move_id',None)&#10;                if not mid: continue&#10;                # failure&#10;                try: fail, why = would_fail(str(mid), my_key, opp_key, state, mi)&#10;                except Exception: fail, why = False, None&#10;                if fail:&#10;                    moves_eval.append({'id':mid,'name':getattr(mv,'name',mid),'score':0.0,'expected':0.0,'exp_dmg':0.0,'acc':0.0,'why_blocked':str(why or 'would fail')})&#10;                    continue&#10;                # expected damage&#10;                try: exp_frac, dmg = _expected_damage_fraction(state, my_key, opp_key, str(mid), mi)&#10;                except Exception: exp_frac, dmg = 0.0, {}&#10;                acc_p = _acc_to_prob(getattr(mv,'accuracy',1.0))&#10;                eff = float(dmg.get('effectiveness',1.0) or 1.0)&#10;                # order&#10;                try:&#10;                    first_prob,_ = predict_order_for_ids(state, my_key, str(mid), opp_key, (opp_moves_known[0] if opp_moves_known else 'tackle'), mi)&#10;                except Exception:&#10;                    first_prob = 0.5&#10;                first_prob = float(first_prob)&#10;                # KO chance if we hit&#10;                rolls = (dmg.get('rolls') or [])&#10;                thr_abs = int(round(opp_hp_frac * opp_max))&#10;                ko_rolls = sum(1 for r in rolls if int(r) &gt;= max(1,thr_abs))&#10;                p_ko_if_hit = (ko_rolls / max(1,len(rolls))) if rolls else 0.0&#10;                p_ko_first = acc_p * p_ko_if_hit * first_prob&#10;                # incoming expectation (worst move * chance opp acts)&#10;                try: incoming_best = _opp_best_on_target(state, opp_key, my_key, mi)&#10;                except Exception: incoming_best = 0.0&#10;                p_opp_acts = (1-first_prob) + first_prob * (1 - p_ko_if_hit * acc_p)&#10;                opp_counter_ev = incoming_best * p_opp_acts&#10;                effective_exp = exp_frac * acc_p&#10;                W=self._W&#10;                score = (W['expected_mult']*effective_exp&#10;                         - W['opp_dmg_penalty']*opp_counter_ev&#10;                         + W['go_first_bonus']*first_prob&#10;                         + W['effectiveness_mult']*eff&#10;                         + W['accuracy_mult']*acc_p&#10;                         + W['ko_bonus']*p_ko_first)&#10;                # Breakdown for debug printing&#10;                c_expected = W['expected_mult']*effective_exp&#10;                c_opp = - W['opp_dmg_penalty']*opp_counter_ev&#10;                c_first = W['go_first_bonus']*first_prob&#10;                c_eff = W['effectiveness_mult']*eff&#10;                c_acc = W['accuracy_mult']*acc_p&#10;                c_ko = W['ko_bonus']*p_ko_first&#10;                moves_eval.append({&#10;                    'id':mid,'name':getattr(mv,'name',mid),'score':float(score),&#10;                    'score_depth':float(score),'future_proj':0.0,'depth_used':1,&#10;                    'expected':float(exp_frac),'exp_dmg':float(exp_frac),&#10;                    'acc':float(acc_p),'effectiveness':float(eff),'first_prob':first_prob,&#10;                    'p_ko_if_hit':float(p_ko_if_hit),'p_ko_first':float(p_ko_first),&#10;                    'opp_counter_ev':float(opp_counter_ev),'incoming_frac':float(incoming_best),&#10;                    'score_breakdown': {&#10;                        'expected': c_expected,&#10;                        'opp_dmg_penalty': c_opp,&#10;                        'go_first_bonus': c_first,&#10;                        'effectiveness_mult': c_eff,&#10;                        'accuracy_mult': c_acc,&#10;                        'ko_bonus': c_ko,&#10;                    }&#10;                })&#10;            moves_eval.sort(key=lambda x: x.get('score_depth', x.get('score',0.0)), reverse=True)&#10;&#10;            # Build switch evaluations EARLY (needed for tree search) if not already built&#10;            # switches_eval already initialized above&#10;            if my_key and opp_key and legal_switches:&#10;                active_species = ''&#10;                try: active_species = str(getattr(state.team.ours.get(my_key),'species','') or '').lower()&#10;                except Exception: pass&#10;                for sw in legal_switches:&#10;                    try:&#10;                        species = str(getattr(sw,'species','') or '')&#10;                        if species.lower() == active_species: continue&#10;                        # locate key&#10;                        cand_key=None&#10;                        for k,ps in state.team.ours.items():&#10;                            if str(getattr(ps,'species','')).lower()==species.lower():&#10;                                cand_key=k; break&#10;                        if not cand_key: continue&#10;                        cand_hp = _hp_frac(state.team.ours[cand_key])&#10;                        try: incoming = _opp_best_on_target(state, opp_key, cand_key, mi)&#10;                        except Exception: incoming=0.0&#10;                        outgoing=0.0&#10;                        try:&#10;                            for mv_obj in getattr(state.team.ours[cand_key],'moves',[]) or []:&#10;                                mid2 = getattr(mv_obj,'id',None)&#10;                                if not mid2: continue&#10;                                bp2 = int(getattr(mv_obj,'base_power',0) or getattr(mv_obj,'basePower',0) or 0)&#10;                                if (getattr(mv_obj,'category','') or '').lower()=='status' or bp2&lt;=0: continue&#10;                                frac2,_ = _expected_damage_fraction(state, cand_key, opp_key, mid2, mi)&#10;                                outgoing = max(outgoing, frac2*_acc_to_prob(getattr(mv_obj,'accuracy',None)))&#10;                        except Exception: pass&#10;                        W=self._W&#10;                        score = W['switch_outgoing_mult']*outgoing - W['switch_incoming_penalty']*incoming&#10;                        switches_eval.append({&#10;                            'species':species,'score':float(score),'base_score':float(score),&#10;                            'outgoing_frac':float(outgoing),'incoming_on_switch':float(incoming),&#10;                            'hazards_frac':0.0,'hp_fraction':float(cand_hp),&#10;                            'score_breakdown': {&#10;                                'switch_outgoing_mult': W['switch_outgoing_mult']*outgoing,&#10;                                'switch_incoming_penalty': - W['switch_incoming_penalty']*incoming,&#10;                            }&#10;                        })&#10;                    except Exception: continue&#10;                switches_eval.sort(key=lambda x: x.get('score',0.0), reverse=True)&#10;&#10;            # depth augmentation (tree search including switches). Depth = number of full future turns (both sides acting) to evaluate (&gt;=1 already evaluated base turn).&#10;            if self._depth &gt; 1 and (moves_eval or switches_eval):&#10;                # Gather opponent damaging moves (limit by branching)&#10;                opp_moves_full = []&#10;                try:&#10;                    if opp_key:&#10;                        opp_ps = state.team.opponent[opp_key]&#10;                        for mv in (getattr(opp_ps,'moves',[]) or []):&#10;                            mid = getattr(mv,'id',None)&#10;                            if not mid: continue&#10;                            if (getattr(mv,'category','') or '').lower()=='status' or (getattr(mv,'base_power',0) or getattr(mv,'basePower',0) or 0) &lt;= 0:&#10;                                continue&#10;                            try: exp_frac_o, dmg_o = _expected_damage_fraction(state, opp_key, my_key, mid, mi)&#10;                            except Exception: exp_frac_o, dmg_o = 0.0, {}&#10;                            opp_moves_full.append({'id': mid, 'name': getattr(mv,'name',mid), 'exp': exp_frac_o, 'acc': _acc_to_prob(getattr(mv,'accuracy',1.0))})&#10;                except Exception:&#10;                    pass&#10;                if not opp_moves_full:&#10;                    try: base_in = _opp_best_on_target(state, opp_key, my_key, mi)&#10;                    except Exception: base_in = 0.0&#10;                    opp_moves_full = [{'id':'_synthetic','name':'(opp_best)','exp': base_in, 'acc':1.0}]&#10;                opp_moves = opp_moves_full[:self._branching]&#10;&#10;                # Baseline HP fractions&#10;                try: my_hp_now = _hp_frac(state.team.ours[my_key])&#10;                except Exception: my_hp_now = 1.0&#10;                try: opp_hp_now = _hp_frac(state.team.opponent[opp_key])&#10;                except Exception: opp_hp_now = 1.0&#10;&#10;                W = self._W&#10;&#10;                # Build our action list (top branching moves + top branching switches)&#10;                my_actions: List[Dict[str, Any]] = []&#10;                for mv in moves_eval[:self._branching]:&#10;                    my_actions.append({'kind':'move','ref':mv})&#10;                for sw in switches_eval[:self._branching]:&#10;                    my_actions.append({'kind':'switch','ref':sw})&#10;&#10;                # Caching for recursion (state abstraction by remaining hp and depth) to avoid explosion.&#10;                from functools import lru_cache&#10;&#10;                @lru_cache(maxsize=4096)&#10;                def recurse(my_rem: float, opp_rem: float, turns_left: int) -&gt; float:&#10;                    if turns_left &lt;= 0 or my_rem &lt;= 0 or opp_rem &lt;= 0:&#10;                        if tree_trace_enabled:&#10;                            tree_trace.append(f&quot;[TREE][BASE] turns_left={turns_left} my={my_rem:.3f} opp={opp_rem:.3f} -&gt; 0.000&quot;)&#10;                        return 0.0&#10;                    best_val = None&#10;                    temp = self._softmin_temp&#10;                    for act in my_actions:&#10;                        kind = act['kind']; ref = act['ref']&#10;                        our_exp = float(ref.get('expected',0.0))*float(ref.get('acc',1.0)) if kind=='move' else 0.0&#10;                # Caching for recursion (state abstraction by remaining hp and depth) to avoid explosion.&#10;            try:&#10;                active_species_lower = ''&#10;                @lru_cache(maxsize=4096)&#10;                def recurse(my_rem: float, opp_rem: float, turns_left: int) -&gt; float:&#10;                for sw in legal_switches:&#10;                    species = str(getattr(sw,'species','') or '')&#10;                            tree_trace.append(f&quot;[TREE][BASE] turns_left={turns_left} my={my_rem:.3f} opp={opp_rem:.3f} -&gt; 0.000&quot;)&#10;                    if species_lower == active_species_lower:&#10;                        continue  # do not switch to same&#10;                    temp = self._softmin_temp&#10;                        continue&#10;                        except Exception:&#10;                        our_exp = float(ref.get('expected',0.0))*float(ref.get('acc',1.0)) if kind=='move' else 0.0&#10;                # Caching for recursion (state abstraction by remaining hp and depth) to avoid explosion.&#10;                if legal_moves:&#10;                    dbg = _debug_base(); dbg['fallback']=True&#10;                @lru_cache(maxsize=4096)&#10;                def recurse(my_rem: float, opp_rem: float, turns_left: int) -&gt; float:&#10;                    dbg = _debug_base(); dbg['fallback']=True&#10;                    decision = ChosenAction(kind='switch', switch_species=str(getattr(legal_switches[0],'species','')), debug=dbg)&#10;                            tree_trace.append(f&quot;[TREE][BASE] turns_left={turns_left} my={my_rem:.3f} opp={opp_rem:.3f} -&gt; 0.000&quot;)&#10;                    dbg = _debug_base(); dbg['fallback']=True&#10;                    decision = ChosenAction(kind='move', move_id='struggle', debug=dbg)&#10;                    temp = self._softmin_temp&#10;                top_moves.append({&#10;                'predicted_incoming_frac': decision.debug.get('predicted_incoming_frac') if isinstance(decision.debug, dict) else None,&#10;                        our_exp = float(ref.get('expected',0.0))*float(ref.get('acc',1.0)) if kind=='move' else 0.0&#10;                # Caching for recursion (state abstraction by remaining hp and depth) to avoid explosion.&#10;" />
              <option name="updatedContent" value="from __future__ import annotations&#10;&#10;import json, os&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, List, Optional, Tuple&#10;import logging&#10;&#10;from Data.battle_runtime import (&#10;    get_state,&#10;    predict_order_for_ids,&#10;    estimate_damage,&#10;    would_fail,&#10;)&#10;from Data.poke_env_battle_environment import snapshot as snapshot_battle&#10;from Data.poke_env_moves_info import MovesInfo&#10;&#10;# ---------------- Weights ----------------&#10;_DEFAULT_WEIGHTS: Dict[str, float] = {&#10;    &quot;expected_mult&quot;: 1.0,&#10;    &quot;go_first_bonus&quot;: 0.3,  # slightly reduce overreliance on raw priority&#10;    &quot;opp_dmg_penalty&quot;: 1.0,&#10;    &quot;survival_bonus&quot;: 0.0,&#10;    &quot;accuracy_mult&quot;: 0.0,&#10;    &quot;effectiveness_mult&quot;: 0.0,&#10;    &quot;ko_bonus&quot;: 1.0,&#10;    # Switching&#10;    &quot;switch_outgoing_mult&quot;: 1.0,&#10;    &quot;switch_incoming_penalty&quot;: 1.0,&#10;}&#10;&#10;def _load_weights(path: str = os.path.join(&quot;Models&quot;, &quot;weights.json&quot;)) -&gt; Dict[str, float]:&#10;    try:&#10;        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            raw = json.load(f)&#10;        w = dict(_DEFAULT_WEIGHTS)&#10;        for k, v in raw.items():&#10;            if k in w:&#10;                try: w[k] = float(v)&#10;                except Exception: pass&#10;        return w&#10;    except Exception:&#10;        return dict(_DEFAULT_WEIGHTS)&#10;&#10;# ---------------- Helpers ----------------&#10;&#10;def _acc_to_prob(acc) -&gt; float:&#10;    if acc is True or acc is None: return 1.0&#10;    try:&#10;        x = float(acc)&#10;        return x / 100.0 if x &gt; 1.0 else max(0.0, min(1.0, x))&#10;    except Exception:&#10;        return 1.0&#10;&#10;def _hp_frac(ps) -&gt; float:&#10;    try:&#10;        if ps and ps.max_hp:&#10;            return max(0.0, min(1.0, (ps.current_hp or ps.max_hp) / ps.max_hp))&#10;    except Exception: pass&#10;    return 1.0&#10;&#10;def _expected_damage_fraction(state, atk_key: str, dfd_key: str, move_id: str, mi: MovesInfo) -&gt; Tuple[float, Dict[str, Any]]:&#10;    dmg = estimate_damage(state, atk_key, dfd_key, move_id, mi, is_critical=False)&#10;    rolls = dmg.get(&quot;rolls&quot;) or []&#10;    if not rolls:&#10;        return 0.0, dmg&#10;    dfd = state.team.ours.get(dfd_key) or state.team.opponent.get(dfd_key)&#10;    max_hp = int(getattr(dfd, &quot;max_hp&quot;, 0) or getattr(dfd, &quot;stats&quot;, {}).raw.get(&quot;hp&quot;, 1) or 1)&#10;    return (float(sum(rolls)) / (len(rolls) * max_hp)), dmg&#10;&#10;_COMMON_STAB = {&#10;    &quot;normal&quot;: [&quot;return&quot;,&quot;bodyslam&quot;],&#10;    &quot;fire&quot;: [&quot;flamethrower&quot;,&quot;fireblast&quot;],&#10;    &quot;water&quot;: [&quot;surf&quot;,&quot;hydropump&quot;],&#10;    &quot;electric&quot;: [&quot;thunderbolt&quot;,&quot;thunder&quot;],&#10;    &quot;grass&quot;: [&quot;energyball&quot;,&quot;leafstorm&quot;],&#10;    &quot;ice&quot;: [&quot;icebeam&quot;,&quot;blizzard&quot;],&#10;    &quot;fighting&quot;: [&quot;closecombat&quot;,&quot;drainpunch&quot;],&#10;    &quot;poison&quot;: [&quot;sludgebomb&quot;,&quot;gunkshot&quot;],&#10;    &quot;ground&quot;: [&quot;earthquake&quot;,&quot;earthpower&quot;],&#10;    &quot;flying&quot;: [&quot;hurricane&quot;,&quot;bravebird&quot;],&#10;    &quot;psychic&quot;: [&quot;psychic&quot;,&quot;psyshock&quot;],&#10;    &quot;bug&quot;: [&quot;bugbuzz&quot;,&quot;leechlife&quot;],&#10;    &quot;rock&quot;: [&quot;stoneedge&quot;,&quot;rockslide&quot;],&#10;    &quot;ghost&quot;: [&quot;shadowball&quot;,&quot;poltergeist&quot;],&#10;    &quot;dragon&quot;: [&quot;dracometeor&quot;,&quot;dragonpulse&quot;],&#10;    &quot;dark&quot;: [&quot;darkpulse&quot;,&quot;crunch&quot;],&#10;    &quot;steel&quot;: [&quot;flashcannon&quot;,&quot;ironhead&quot;],&#10;    &quot;fairy&quot;: [&quot;moonblast&quot;,&quot;playrough&quot;],&#10;}&#10;&#10;def _opp_best_on_target(state, opp_key: str, target_key: str, mi: MovesInfo) -&gt; float:&#10;    opp = state.team.opponent[opp_key]&#10;    best = 0.0&#10;    mv_list = [m for m in (opp.moves or []) if getattr(m, 'id', None)]&#10;    if mv_list:&#10;        for mv in mv_list:&#10;            if (getattr(mv, 'category', '') or '').lower() == 'status' or (getattr(mv, 'base_power', 0) or 0) &lt;= 0:&#10;                continue&#10;            frac, _ = _expected_damage_fraction(state, opp_key, target_key, mv.id, mi)&#10;            best = max(best, frac * _acc_to_prob(getattr(mv, 'accuracy', None)))&#10;        return best&#10;    for t in opp.types or []:&#10;        for mid in _COMMON_STAB.get((t or '').lower(), [])[:2]:&#10;            try:&#10;                frac, _ = _expected_damage_fraction(state, opp_key, target_key, mid, mi)&#10;                raw = mi.raw(mid) or {}&#10;                best = max(best, frac * _acc_to_prob(raw.get('accuracy')))&#10;            except Exception: continue&#10;    for mid in (&quot;icebeam&quot;,&quot;closecombat&quot;,&quot;earthquake&quot;):&#10;        try:&#10;            frac, _ = _expected_damage_fraction(state, opp_key, target_key, mid, mi)&#10;            raw = mi.raw(mid) or {}&#10;            best = max(best, frac * _acc_to_prob(raw.get('accuracy')))&#10;        except Exception: continue&#10;    return best&#10;&#10;# ---------------- Data container ----------------&#10;@dataclass&#10;class ChosenAction:&#10;    kind: str&#10;    move_id: Optional[str] = None&#10;    switch_species: Optional[str] = None&#10;    debug: Optional[Dict[str, Any]] = None&#10;&#10;# ---------------- Engine ----------------&#10;class StockfishModel:&#10;    def __init__(self, battle_format: str = 'gen9ou'):&#10;        self.battle_format = battle_format&#10;        self._W = _load_weights()&#10;        self._depth = 1&#10;        self._branching = 3&#10;        self._softmin_temp: float = 0.0  # 0 =&gt; hard minimax, &gt;0 =&gt; softmin (Boltzmann-weighted average)&#10;        # Verbose think debug printing (terminal). Enable with env POKECHAD_THINK_DEBUG=1&#10;        try:&#10;            import os as _os&#10;            self._verbose = bool(int(_os.environ.get('POKECHAD_THINK_DEBUG', '0')))&#10;        except Exception:&#10;            self._verbose = False&#10;&#10;    # New: external injection of a full weight mapping (used by tuner/self-play). Unknown keys ignored, missing keys preserved.&#10;    def set_weights(self, mapping: Dict[str, float]):  # type: ignore[name-defined]&#10;        try:&#10;            if not isinstance(mapping, dict):&#10;                return&#10;            for k, v in mapping.items():&#10;                if k in self._W:&#10;                    try:&#10;                        self._W[k] = float(v)&#10;                    except Exception:&#10;                        pass&#10;        except Exception:&#10;            pass&#10;&#10;    def set_depth(self, d: int):&#10;        try: d = int(d)&#10;        except Exception: d = 1&#10;        self._depth = max(1, min(10, d))&#10;&#10;    def set_branching(self, k: int):&#10;        try: k = int(k)&#10;        except Exception: k = 1&#10;        self._branching = max(1, min(10, k))&#10;&#10;    def set_softmin_temperature(self, t: float):&#10;        &quot;&quot;&quot;Set softmin temperature (opponent reply aggregation). 0 =&gt; pure minimax, &gt;0 softmin (Boltzmann-weighted average).&quot;&quot;&quot;&#10;        try: t = float(t)&#10;        except Exception: t = 0.0&#10;        if t &lt; 0: t = 0.0&#10;        self._softmin_temp = t&#10;&#10;    def set_verbose(self, flag: bool=True):&#10;        self._verbose = bool(flag)&#10;&#10;    def reload_weights(self, path: str = os.path.join('Models','weights.json')):&#10;        self._W = _load_weights(path)&#10;&#10;    # ---- core ----&#10;    def choose_action(self, battle: Any) -&gt; ChosenAction:&#10;        state = get_state(battle)&#10;        mi = MovesInfo(state.format or 9)&#10;        # decision instrumentation accumulator&#10;        _dec_log: Dict[str, Any] = { 'battle_tag': getattr(battle,'battle_tag', getattr(battle,'room_id', None)), 'turn': getattr(battle,'turn', None) }&#10;        # Defensive early initialization to avoid NameError in any early-return / exception paths&#10;        best_move = None  # type: ignore&#10;        best_switch = None  # type: ignore&#10;        # Tree trace accumulator (per-depth branch logging)&#10;        tree_trace: List[str] = []&#10;        try:&#10;            import os as _os&#10;            tree_trace_enabled = bool(int(_os.environ.get('POKECHAD_TREE_TRACE','0')))&#10;        except Exception:&#10;            tree_trace_enabled = False&#10;&#10;        # Active keys&#10;        def _active(side: Dict[str, Any]) -&gt; Optional[str]:&#10;            for k,p in side.items():&#10;                if getattr(p,'is_active',False) and getattr(p,'current_hp',0) &gt; 0: return k&#10;            for k,p in side.items():&#10;                if (getattr(p,'status','') or '').lower()=='fnt': continue&#10;                if getattr(p,'current_hp',1) &gt; 0: return k&#10;            return None&#10;        my_key = _active(state.team.ours) if getattr(state,'team',None) else None&#10;        opp_key = _active(state.team.opponent) if getattr(state,'team',None) else None&#10;&#10;        legal_moves: List[Any] = list(getattr(battle,'available_moves',[]) or [])&#10;        legal_switches: List[Any] = list(getattr(battle,'available_switches',[]) or [])&#10;        # Define force_switch immediately so it's available for synthetic switch logic below&#10;        force_switch = bool(getattr(battle,'force_switch', False))&#10;        # If force switch but engine sees no available_switches, synthesize from team state (bench) to allow evaluation&#10;        if force_switch and not legal_switches and getattr(state,'team',None):&#10;            class _Stub:&#10;                __slots__ = ('species',)&#10;                def __init__(self, s): self.species = s&#10;            try:&#10;                active_species = None&#10;                if my_key and my_key in state.team.ours:&#10;                    active_species = getattr(state.team.ours[my_key],'species',None)&#10;                for k,ps in state.team.ours.items():&#10;                    if getattr(ps,'current_hp',0) &lt;= 0: continue&#10;                    sp = getattr(ps,'species',None)&#10;                    if not sp or sp==active_species: continue&#10;                    legal_switches.append(_Stub(sp))&#10;            except Exception: pass&#10;&#10;        # Only trust battle.force_switch flag; do not auto-set from (not legal_moves and legal_switches) because poke-env already handles this&#10;        # (force_switch already defined above)&#10;        # force_switch = bool(getattr(battle,'force_switch', False))&#10;&#10;        # Fallback: if active key missing, attempt to map from battle active pokemon species (helps after form changes / detailschange)&#10;        if not my_key:&#10;            try:&#10;                active_species = getattr(getattr(battle,'active_pokemon',None),'species',None)&#10;                if active_species:&#10;                    for k,p in getattr(state.team,'ours',{}).items():&#10;                        if getattr(p,'species',None)==active_species and (getattr(p,'current_hp',0)&gt;0):&#10;                            my_key = k; break&#10;            except Exception: pass&#10;        if not opp_key:&#10;            try:&#10;                opp_active_species = getattr(getattr(battle,'opponent_active_pokemon',None),'species',None) or getattr(getattr(battle,'opponent_active_pokemon',None),'base_species',None)&#10;                if opp_active_species:&#10;                    for k,p in getattr(state.team,'opponent',{}).items():&#10;                        if getattr(p,'species',None)==opp_active_species and (getattr(p,'current_hp',0)&gt;0):&#10;                            opp_key = k; break&#10;            except Exception: pass&#10;        # NEW: if keys exist but species mismatch current battle view, remap to the correct slot&#10;        try:&#10;            cur_my_sp = getattr(getattr(battle,'active_pokemon',None),'species',None)&#10;            if my_key and cur_my_sp and getattr(state.team.ours.get(my_key),'species',None) != cur_my_sp:&#10;                for k,p in getattr(state.team,'ours',{}).items():&#10;                    if getattr(p,'species',None)==cur_my_sp and getattr(p,'current_hp',0)&gt;0:&#10;                        my_key = k; break&#10;        except Exception:&#10;            pass&#10;        try:&#10;            cur_opp_sp = getattr(getattr(battle,'opponent_active_pokemon',None),'species',None) or getattr(getattr(battle,'opponent_active_pokemon',None),'base_species',None)&#10;            if opp_key and cur_opp_sp and getattr(state.team.opponent.get(opp_key),'species',None) != cur_opp_sp:&#10;                for k,p in getattr(state.team,'opponent',{}).items():&#10;                    if getattr(p,'species',None)==cur_opp_sp and getattr(p,'current_hp',0)&gt;0:&#10;                        opp_key = k; break&#10;        except Exception:&#10;            pass&#10;&#10;        opp_moves_known: List[str] = []&#10;        if opp_key:&#10;            try:&#10;                opp_ps = state.team.opponent.get(opp_key)&#10;                if opp_ps and getattr(opp_ps,'moves',None):&#10;                    opp_moves_known = [m.id for m in opp_ps.moves if getattr(m,'id',None)]&#10;            except Exception: pass&#10;&#10;        moves_eval: List[Dict[str, Any]] = []&#10;        switches_eval: List[Dict[str, Any]] = []  # ensure defined even if no evaluation block runs&#10;        skip_reason: Optional[str] = None&#10;        if not force_switch and my_key and opp_key:&#10;            opp_ps = state.team.opponent[opp_key]&#10;            opp_hp_frac = _hp_frac(opp_ps)&#10;            opp_max = int(getattr(opp_ps,'max_hp',0) or getattr(opp_ps,'stats',{}).raw.get('hp',1) or 1)&#10;            for mv in legal_moves:&#10;                mid = getattr(mv,'id',None) or getattr(mv,'move_id',None)&#10;                if not mid: continue&#10;                # failure&#10;                try: fail, why = would_fail(str(mid), my_key, opp_key, state, mi)&#10;                except Exception: fail, why = False, None&#10;                if fail:&#10;                    moves_eval.append({'id':mid,'name':getattr(mv,'name',mid),'score':0.0,'expected':0.0,'exp_dmg':0.0,'acc':0.0,'why_blocked':str(why or 'would fail')})&#10;                    continue&#10;                # expected damage&#10;                try: exp_frac, dmg = _expected_damage_fraction(state, my_key, opp_key, str(mid), mi)&#10;                except Exception: exp_frac, dmg = 0.0, {}&#10;                # move meta&#10;                try:&#10;                    raw = mi.get(str(mid))&#10;                    cat = (raw.category or 'Status').lower()&#10;                    pri = int(raw.priority or getattr(mv,'priority',0) or 0)&#10;                    boosts = dict(raw.boosts or {})&#10;                except Exception:&#10;                    raw = None; cat = (getattr(mv,'category','') or 'Status').lower(); pri = int(getattr(mv,'priority',0) or 0); boosts = {}&#10;                acc_p = _acc_to_prob(getattr(mv,'accuracy',1.0))&#10;                eff = float((dmg.get('effectiveness',1.0) or 1.0))&#10;                # order (baseline)&#10;                try:&#10;                    first_prob,details = predict_order_for_ids(state, my_key, str(mid), opp_key, (getattr(opp_ps.moves[0],'id',None) if getattr(opp_ps,'moves',None) else 'tackle'), mi)&#10;                    base_me_spe = float(details.get('user_effective_speed', 1.0) or 1.0)&#10;                    base_opp_spe = float(details.get('opp_effective_speed', 1.0) or 1.0)&#10;                except Exception:&#10;                    first_prob = 0.5; base_me_spe = 1.0; base_opp_spe = 1.0&#10;                # KO chance if we hit&#10;                rolls = (dmg.get('rolls') or [])&#10;                thr_abs = int(round(opp_hp_frac * opp_max))&#10;                ko_rolls = sum(1 for r in rolls if int(r) &gt;= max(1,thr_abs))&#10;                p_ko_if_hit = (ko_rolls / max(1,len(rolls))) if rolls else 0.0&#10;                p_ko_first = acc_p * p_ko_if_hit * first_prob&#10;                # incoming expectation (worst move * chance opp acts)&#10;                try: incoming_best = _opp_best_on_target(state, opp_key, my_key, mi)&#10;                except Exception: incoming_best = 0.0&#10;                p_opp_acts = (1-first_prob) + first_prob * (1 - p_ko_if_hit * acc_p)&#10;                opp_counter_ev = incoming_best * p_opp_acts&#10;                effective_exp = exp_frac * acc_p&#10;                W=self._W&#10;                score = (W['expected_mult']*effective_exp&#10;                         - W['opp_dmg_penalty']*opp_counter_ev&#10;                         + W['go_first_bonus']*first_prob&#10;                         + W['effectiveness_mult']*eff&#10;                         + W['accuracy_mult']*acc_p&#10;                         + W['ko_bonus']*p_ko_first)&#10;                # Breakdown&#10;                moves_eval.append({&#10;                    'id':mid,'name':getattr(mv,'name',mid),'score':float(score),&#10;                    'score_depth':float(score),'future_proj':0.0,'depth_used':1,&#10;                    'expected':float(exp_frac),'exp_dmg':float(exp_frac),&#10;                    'acc':float(acc_p),'effectiveness':float(eff),'first_prob':float(first_prob),&#10;                    'p_ko_if_hit':float(p_ko_if_hit),'p_ko_first':float(p_ko_first),&#10;                    'opp_counter_ev':float(opp_counter_ev),'incoming_frac':float(incoming_best),&#10;                    # meta for boost-aware tree&#10;                    'priority': pri,&#10;                    'category': cat,&#10;                    'is_status': (cat=='status'),&#10;                    'boosts': boosts,&#10;                    'base_user_speed': base_me_spe,&#10;                    'base_opp_speed': base_opp_spe,&#10;                    'score_breakdown': {}&#10;                })&#10;            moves_eval.sort(key=lambda x: x.get('score_depth', x.get('score',0.0)), reverse=True)&#10;&#10;            # Build switch evaluations EARLY (needed for tree search) if not already built&#10;            # switches_eval already initialized above&#10;            if my_key and opp_key and legal_switches:&#10;                active_species = ''&#10;                try: active_species = str(getattr(state.team.ours.get(my_key),'species','') or '').lower()&#10;                except Exception: pass&#10;                for sw in legal_switches:&#10;                    try:&#10;                        species = str(getattr(sw,'species','') or '')&#10;                        if species.lower() == active_species: continue&#10;                        # locate key&#10;                        cand_key=None&#10;                        for k,ps in state.team.ours.items():&#10;                            if str(getattr(ps,'species','')).lower()==species.lower():&#10;                                cand_key=k; break&#10;                        if not cand_key: continue&#10;                        cand_hp = _hp_frac(state.team.ours[cand_key])&#10;                        try: incoming = _opp_best_on_target(state, opp_key, cand_key, mi)&#10;                        except Exception: incoming=0.0&#10;                        outgoing=0.0&#10;                        try:&#10;                            for mv_obj in getattr(state.team.ours[cand_key],'moves',[]) or []:&#10;                                mid2 = getattr(mv_obj,'id',None)&#10;                                if not mid2: continue&#10;                                bp2 = int(getattr(mv_obj,'base_power',0) or getattr(mv_obj,'basePower',0) or 0)&#10;                                if (getattr(mv_obj,'category','') or '').lower()=='status' or bp2&lt;=0: continue&#10;                                frac2,_ = _expected_damage_fraction(state, cand_key, opp_key, mid2, mi)&#10;                                outgoing = max(outgoing, frac2*_acc_to_prob(getattr(mv_obj,'accuracy',None)))&#10;                        except Exception: pass&#10;                        W=self._W&#10;                        score = W['switch_outgoing_mult']*outgoing - W['switch_incoming_penalty']*incoming&#10;                        switches_eval.append({&#10;                            'species':species,'score':float(score),'base_score':float(score),&#10;                            'outgoing_frac':float(outgoing),'incoming_on_switch':float(incoming),&#10;                            'hazards_frac':0.0,'hp_fraction':float(cand_hp),&#10;                            'score_breakdown': {&#10;                                'switch_outgoing_mult': W['switch_outgoing_mult']*outgoing,&#10;                                'switch_incoming_penalty': - W['switch_incoming_penalty']*incoming,&#10;                            }&#10;                        })&#10;                    except Exception: continue&#10;                switches_eval.sort(key=lambda x: x.get('score',0.0), reverse=True)&#10;&#10;            # depth augmentation (tree search including switches). Depth = number of full future turns (both sides acting) to evaluate (&gt;=1 already evaluated base turn).&#10;            if self._depth &gt; 1 and (moves_eval or switches_eval):&#10;                # Gather opponent damaging moves (limit by branching)&#10;                opp_moves_full = []&#10;                try:&#10;                    if opp_key:&#10;                        opp_ps = state.team.opponent[opp_key]&#10;                        for mv in (getattr(opp_ps,'moves',[]) or []):&#10;                            mid = getattr(mv,'id',None)&#10;                            if not mid: continue&#10;                            if (getattr(mv,'category','') or '').lower()=='status' or (getattr(mv,'base_power',0) or getattr(mv,'basePower',0) or 0) &lt;= 0:&#10;                                # still keep notable boost moves to model priority comparisons minimally&#10;                                try:&#10;                                    raw = mi.get(str(mid)); pri = int(raw.priority or 0); cat = (raw.category or 'Status').lower()&#10;                                except Exception:&#10;                                    pri = int(getattr(mv,'priority',0) or 0); cat = (getattr(mv,'category','') or 'status').lower()&#10;                                opp_moves_full.append({'id': mid, 'name': getattr(mv,'name',mid), 'exp': 0.0, 'acc': 1.0, 'priority': pri, 'category': cat})&#10;                                continue&#10;                            try:&#10;                                exp_frac_o, dmg_o = _expected_damage_fraction(state, opp_key, my_key, mid, mi)&#10;                            except Exception:&#10;                                exp_frac_o, dmg_o = 0.0, {}&#10;                            try:&#10;                                raw = mi.get(str(mid)); pri = int(raw.priority or 0); cat = (raw.category or 'Status').lower()&#10;                            except Exception:&#10;                                pri = int(getattr(mv,'priority',0) or 0); cat = (getattr(mv,'category','') or 'status').lower()&#10;                            opp_moves_full.append({'id': mid, 'name': getattr(mv,'name',mid), 'exp': exp_frac_o, 'acc': _acc_to_prob(getattr(mv,'accuracy',1.0)), 'priority': pri, 'category': cat})&#10;                except Exception:&#10;                    pass&#10;                if not opp_moves_full:&#10;                    try: base_in = _opp_best_on_target(state, opp_key, my_key, mi)&#10;                    except Exception: base_in = 0.0&#10;                    opp_moves_full = [{'id':'_synthetic','name':'(opp_best)','exp': base_in, 'acc':1.0, 'priority': 0, 'category': 'physical'}]&#10;                opp_moves = opp_moves_full[:self._branching]&#10;&#10;                # Baseline HP fractions&#10;                try: my_hp_now = _hp_frac(state.team.ours[my_key])&#10;                except Exception: my_hp_now = 1.0&#10;                try: opp_hp_now = _hp_frac(state.team.opponent[opp_key])&#10;                except Exception: opp_hp_now = 1.0&#10;&#10;                W = self._W&#10;&#10;                # Build our action list&#10;                my_actions: List[Dict[str, Any]] = []&#10;                for mv in moves_eval[:self._branching]:&#10;                    my_actions.append({'kind':'move','ref':mv})&#10;                for sw in switches_eval[:self._branching]:&#10;                    my_actions.append({'kind':'switch','ref':sw})&#10;&#10;                # --- NEW: Precompute per-target expectations for dynamic tree (our moves vs each opponent candidate, opp moves vs our candidates) ---&#10;                # Collect alive opponent keys (active + bench)&#10;                opp_alive_keys: List[str] = []&#10;                try:&#10;                    seen_species = set()&#10;                    for k,ps in state.team.opponent.items():&#10;                        if getattr(ps,'current_hp',0) &gt; 0 and (getattr(ps,'status','') or '').lower()!='fnt':&#10;                            sp = (getattr(ps,'species','') or '').lower()&#10;                            if sp and sp in seen_species:&#10;                                continue&#10;                            seen_species.add(sp)&#10;                            opp_alive_keys.append(k)&#10;                except Exception:&#10;                    opp_alive_keys = [opp_key] if opp_key else []&#10;                if opp_key and opp_key not in opp_alive_keys:&#10;                    opp_alive_keys.append(opp_key)&#10;                # Collect our alive keys&#10;                my_alive_keys: List[str] = []&#10;                try:&#10;                    seen_my_species = set()&#10;                    for k,ps in state.team.ours.items():&#10;                        if getattr(ps,'current_hp',0) &gt; 0 and (getattr(ps,'status','') or '').lower()!='fnt':&#10;                            sp = (getattr(ps,'species','') or '').lower()&#10;                            if sp and sp in seen_my_species:&#10;                                continue&#10;                            seen_my_species.add(sp)&#10;                            my_alive_keys.append(k)&#10;                except Exception:&#10;                    my_alive_keys = [my_key] if my_key else []&#10;                if my_key and my_key not in my_alive_keys:&#10;                    my_alive_keys.append(my_key)&#10;&#10;                # Precompute mapping for our moves: expected damage vs each opponent possible active&#10;                for act in my_actions:&#10;                    if act['kind']!='move':&#10;                        continue&#10;                    ref = act['ref']&#10;                    mv_id = ref.get('id')&#10;                    exp_map = {}&#10;                    for ok in opp_alive_keys:&#10;                        try:&#10;                            frac,_ = _expected_damage_fraction(state, my_key, ok, str(mv_id), mi)&#10;                        except Exception:&#10;                            frac = 0.0&#10;                        exp_map[ok] = float(frac) * float(ref.get('acc',1.0))  # include accuracy&#10;                    ref['exp_by_target'] = exp_map&#10;                # For switches we record no direct damage, but keep placeholder map&#10;                for act in my_actions:&#10;                    if act['kind']=='switch':&#10;                        act['ref']['exp_by_target'] = {ok:0.0 for ok in opp_alive_keys}&#10;&#10;                # Precompute opponent moves vs each of our possible actives (for when we have switched previously in tree)&#10;                for o in opp_moves_full:&#10;                    exp_map_my = {}&#10;                    for mk in my_alive_keys:&#10;                        try:&#10;                            frac,_ = _expected_damage_fraction(state, opp_key, mk, str(o['id']), mi)&#10;                        except Exception:&#10;                            frac = 0.0&#10;                        exp_map_my[mk] = float(frac) * float(o.get('acc',1.0))&#10;                    o['exp_by_target_my'] = exp_map_my&#10;&#10;                # Opponent potential switches (bench keys excluding current active)&#10;                opp_switch_candidates: List[Dict[str, Any]] = []&#10;                try:&#10;                    for k in opp_alive_keys:&#10;                        if k == opp_key:&#10;                            continue&#10;                        ps = state.team.opponent.get(k)&#10;                        if not ps: continue&#10;                        opp_switch_candidates.append({'to_key':k, 'hp_frac': _hp_frac(ps)})&#10;                except Exception:&#10;                    pass&#10;&#10;                W = self._W&#10;                temp_soft = self._softmin_temp&#10;                branching_cap = self._branching&#10;&#10;                # Dynamic recursion with active keys and HP remaining&#10;                from functools import lru_cache&#10;&#10;                @lru_cache(maxsize=8192)&#10;                def recurse(active_my: str, active_opp: str, my_rem: float, opp_rem: float, turns_left: int,&#10;                            my_atk: int=0, my_def: int=0, my_spa: int=0, my_spd: int=0, my_spe: int=0,&#10;                            opp_atk: int=0, opp_def: int=0, opp_spa: int=0, opp_spd: int=0, opp_spe: int=0) -&gt; float:&#10;                    if turns_left &lt;= 0 or my_rem &lt;= 0 or opp_rem &lt;= 0:&#10;                        if tree_trace_enabled:&#10;                            tree_trace.append(f&quot;[TREE][BASE] tl={turns_left} my={my_rem:.3f} opp={opp_rem:.3f} act_my={active_my} act_opp={active_opp} -&gt; 0.000&quot;)&#10;                        return 0.0&#10;                    best_val = None&#10;                    # Assemble actions (moves + switches)&#10;                    current_actions: List[Dict[str, Any]] = []&#10;                    move_count = 0; switch_count = 0&#10;                    for act in my_actions:&#10;                        if act['kind']=='move':&#10;                            if move_count &lt; branching_cap:&#10;                                current_actions.append(act); move_count += 1&#10;                        else:&#10;                            if switch_count &lt; branching_cap:&#10;                                current_actions.append(act); switch_count += 1&#10;                    # Opponent replies&#10;                    opp_reply_moves = opp_moves_full[:branching_cap]&#10;                    opp_reply_switches = opp_switch_candidates[:branching_cap]&#10;&#10;                    for act in current_actions:&#10;                        kind = act['kind']; ref = act['ref']&#10;                        # Determine our expected damage vs current opponent using per-target exp map + stage multipliers&#10;                        exp_map = ref.get('exp_by_target') or {}&#10;                        base_exp_vs_current = float(exp_map.get(active_opp, 0.0)) if kind=='move' else 0.0&#10;                        cat = (ref.get('category') or 'status').lower() if kind=='move' else 'status'&#10;                        pri_user = int(ref.get('priority',0)) if kind=='move' else 0&#10;                        # Adjust by stages&#10;                        if cat == 'physical':&#10;                            our_exp_vs_current = base_exp_vs_current * (_stage_mult(my_atk) / max(1e-6,_stage_mult(opp_def)))&#10;                        elif cat == 'special':&#10;                            our_exp_vs_current = base_exp_vs_current * (_stage_mult(my_spa) / max(1e-6,_stage_mult(opp_spd)))&#10;                        else:&#10;                            our_exp_vs_current = 0.0  # status deals no direct damage&#10;                        # First prob heuristic (priority-aware; speed boost nudges)&#10;                        first_prob = float(ref.get('first_prob',0.5)) if kind=='move' else 0.0&#10;                        if tree_trace_enabled:&#10;                            ident = ref.get('id') if kind=='move' else ref.get('species')&#10;                            tree_trace.append(f&quot;[TREE][ACT] tl={turns_left} my={my_rem:.3f} opp={opp_rem:.3f} kind={kind} ident={ident} our_exp={our_exp_vs_current:.3f} first={first_prob:.3f}&quot;)&#10;                        reply_vals: List[float] = []&#10;                        # 1. Opponent move replies&#10;                        for o in opp_reply_moves:&#10;                            opp_exp_map = o.get('exp_by_target_my') or {}&#10;                            opp_base = float(opp_exp_map.get(active_my, 0.0))&#10;                            cat_o = (o.get('category') or 'physical').lower()&#10;                            pri_opp = int(o.get('priority',0) or 0)&#10;                            # If equal priority, speed order may flip with boosts; apply a simple nudge&#10;                            # If our priority outranks, we go first; if theirs outranks, we go second&#10;                            fp = first_prob&#10;                            if kind=='move':&#10;                                if pri_user &gt; pri_opp:&#10;                                    fp = 1.0&#10;                                elif pri_user &lt; pri_opp:&#10;                                    fp = 0.0&#10;                                else:&#10;                                    # use base speeds seen on this move if present, scaled by our/my_spe boosts&#10;                                    me_base = float(ref.get('base_user_speed', 1.0) or 1.0)&#10;                                    op_base = float(ref.get('base_opp_speed', 1.0) or 1.0)&#10;                                    me_eff = me_base * _stage_mult(my_spe)&#10;                                    op_eff = op_base * _stage_mult(opp_spe)&#10;                                    fp = 1.0 if me_eff &gt; op_eff else 0.0&#10;                            # Incoming adjustment by our defensive boosts (apply if we act first and the move is executed after our boost this turn)&#10;                            if cat_o == 'physical':&#10;                                opp_effective_hit = opp_base / max(1e-6,_stage_mult(my_def if fp&gt;=0.999 and kind=='move' and ref.get('is_status') and ref.get('boosts') else my_def))&#10;                            elif cat_o == 'special':&#10;                                opp_effective_hit = opp_base / max(1e-6,_stage_mult(my_spd if fp&gt;=0.999 and kind=='move' and ref.get('is_status') and ref.get('boosts') else my_spd))&#10;                            else:&#10;                                opp_effective_hit = 0.0&#10;                            if kind=='move':&#10;                                # KO check vs current active opponent&#10;                                ko_if_hit = our_exp_vs_current &gt;= opp_rem - 1e-9&#10;                                opp_effective = opp_effective_hit * ((1-fp) + (fp * (0 if ko_if_hit and our_exp_vs_current&gt;0 else 1)))&#10;                                our_effective = our_exp_vs_current&#10;                                inc = (W['expected_mult']*our_effective - W['opp_dmg_penalty']*opp_effective + W['go_first_bonus']*fp)&#10;                                if ko_if_hit and our_effective&gt;0:&#10;                                    inc += W['ko_bonus']&#10;                                next_my = max(0.0, my_rem - opp_effective)&#10;                                next_opp = max(0.0, opp_rem - our_effective)&#10;                                # Apply stage deltas if this move boosts (after execution)&#10;                                b = ref.get('boosts') or {}&#10;                                n_my_atk = my_atk + int(b.get('atk',0))&#10;                                n_my_def = my_def + int(b.get('def',0))&#10;                                n_my_spa = my_spa + int(b.get('spa',0))&#10;                                n_my_spd = my_spd + int(b.get('spd',0))&#10;                                n_my_spe = my_spe + int(b.get('spe',0))&#10;                                future = recurse(active_my, active_opp, next_my, next_opp, turns_left - 1,&#10;                                                 n_my_atk, n_my_def, n_my_spa, n_my_spd, n_my_spe,&#10;                                                 opp_atk, opp_def, opp_spa, opp_spd, opp_spe) if next_my&gt;0 and next_opp&gt;0 else 0.0&#10;                            else:&#10;                                opp_effective = opp_effective_hit&#10;                                inc = - W['opp_dmg_penalty']*opp_effective&#10;                                our_effective = 0.0&#10;                                next_my = max(0.0, my_rem - opp_effective)&#10;                                next_opp = opp_rem&#10;                                future = recurse(active_my, active_opp, next_my, next_opp, turns_left - 1,&#10;                                                 my_atk, my_def, my_spa, my_spd, my_spe,&#10;                                                 opp_atk, opp_def, opp_spa, opp_spd, opp_spe) if next_my&gt;0 else 0.0&#10;                            total = inc + future&#10;                            reply_vals.append(total)&#10;                            if tree_trace_enabled:&#10;                                tree_trace.append(f&quot;[TREE][RPLY] tl={turns_left} act_kind={kind} opp_mv={o['id']} opp_exp={opp_base:.3f} opp_eff={(opp_effective if kind=='move' else opp_effective):.3f} inc={inc:.3f} future={future:.3f} total={total:.3f} next_my={next_my:.3f} next_opp={next_opp:.3f}&quot;)&#10;                        # 2. Opponent switch replies (unchanged except stage carry)&#10;                        for sw in opp_reply_switches:&#10;                            to_key = sw['to_key']; to_hp_full = float(sw['hp_frac'])&#10;                            if kind=='move':&#10;                                our_exp_vs_new = float(exp_map.get(to_key, 0.0))&#10;                                if cat == 'physical':&#10;                                    our_exp_vs_new *= _stage_mult(my_atk)&#10;                                elif cat == 'special':&#10;                                    our_exp_vs_new *= _stage_mult(my_spa)&#10;                                inc = W['expected_mult']*our_exp_vs_new + W['go_first_bonus']*first_prob&#10;                                ko_if_hit_new = our_exp_vs_new &gt;= to_hp_full - 1e-9&#10;                                if ko_if_hit_new and our_exp_vs_new&gt;0:&#10;                                    inc += W['ko_bonus']&#10;                                next_my = my_rem&#10;                                next_opp = max(0.0, to_hp_full - our_exp_vs_new)&#10;                                b = ref.get('boosts') or {}&#10;                                n_my_atk = my_atk + int(b.get('atk',0)); n_my_def = my_def + int(b.get('def',0))&#10;                                n_my_spa = my_spa + int(b.get('spa',0)); n_my_spd = my_spd + int(b.get('spd',0))&#10;                                n_my_spe = my_spe + int(b.get('spe',0))&#10;                                future = recurse(active_my, to_key, next_my, next_opp, turns_left - 1,&#10;                                                 n_my_atk, n_my_def, n_my_spa, n_my_spd, n_my_spe,&#10;                                                 opp_atk, opp_def, opp_spa, opp_spd, opp_spe) if next_opp&gt;0 else 0.0&#10;                            else:&#10;                                inc = 0.0&#10;                                next_my = my_rem&#10;                                next_opp = to_hp_full&#10;                                future = recurse(active_my, to_key, next_my, next_opp, turns_left - 1,&#10;                                                 my_atk, my_def, my_spa, my_spd, my_spe,&#10;                                                 opp_atk, opp_def, opp_spa, opp_spd, opp_spe)&#10;                            total = inc + future&#10;                            reply_vals.append(total)&#10;                            if tree_trace_enabled:&#10;                                tree_trace.append(f&quot;[TREE][RPLY] tl={turns_left} act_kind={kind} opp_switch={to_key} inc={inc:.3f} future={future:.3f} total={total:.3f} next_my={next_my:.3f} next_opp={next_opp:.3f}&quot;)&#10;                        if not reply_vals:&#10;                            continue&#10;                        if temp_soft&gt;0:&#10;                            import math&#10;                            weights = [math.exp(-x/temp_soft) for x in reply_vals]&#10;                            Z = sum(weights) or 1.0&#10;                            agg_val = sum(w*x for w,x in zip(weights, reply_vals))/Z&#10;                            agg_type = 'softmin'&#10;                        else:&#10;                            agg_val = min(reply_vals)&#10;                            agg_type = 'min'&#10;                        if best_val is None or agg_val&gt;best_val:&#10;                            best_val = agg_val&#10;                        if tree_trace_enabled:&#10;                            ident = ref.get('id') if kind=='move' else ref.get('species')&#10;                            tree_trace.append(f&quot;[TREE][EVAL] tl={turns_left} kind={kind} ident={ident} agg={agg_type} val={agg_val:.3f} best={best_val:.3f}&quot;)&#10;                    final_val = best_val if best_val is not None else 0.0&#10;                    if tree_trace_enabled:&#10;                        tree_trace.append(f&quot;[TREE][RET] tl={turns_left} my={my_rem:.3f} opp={opp_rem:.3f} act_my={active_my} act_opp={active_opp} -&gt; {final_val:.3f}&quot;)&#10;                    return final_val&#10;&#10;                # Apply recursion to refine score_depth &amp; future_proj (root actives)&#10;                turns_left = self._depth - 1&#10;                for act in my_actions:&#10;                    ref = act['ref']&#10;                    base_score = float(ref.get('score',0.0))&#10;                    val = recurse(my_key, opp_key, my_hp_now, opp_hp_now, turns_left)&#10;                    if val is not None:&#10;                        ref['score_depth'] = val&#10;                        ref['future_proj'] = val - base_score&#10;                        ref['depth_used'] = self._depth&#10;                        ref.setdefault('tree_minimax','maximin')&#10;                        if self._softmin_temp &gt; 0:&#10;                            ref.setdefault('tree_opponent_response','softmin')&#10;                            ref.setdefault('softmin_temp', self._softmin_temp)&#10;                        if act['kind']=='move':&#10;                            ref.setdefault('tree_includes_switches', True)&#10;                # Resort&#10;                moves_eval.sort(key=lambda x: x.get('score_depth', x.get('score',0.0)), reverse=True)&#10;                switches_eval.sort(key=lambda x: x.get('score_depth', x.get('score', x.get('base_score',0.0))), reverse=True)&#10;&#10;        # NEW: If not a forced switch and we have legal moves but couldn't resolve opponent, build a simple fallback move ranking to avoid random switching&#10;        elif not force_switch and my_key and legal_moves:&#10;            skip_reason = 'opp_key=None'&#10;            try:&#10;                me = state.team.ours.get(my_key)&#10;            except Exception:&#10;                me = None&#10;            my_types = set(getattr(me, 'types', []) or []) if me else set()&#10;            for mv in legal_moves:&#10;                mid = getattr(mv,'id',None) or getattr(mv,'move_id',None)&#10;                if not mid: continue&#10;                raw = mi.get(str(mid))&#10;                cat = (raw.category or 'Status').lower()&#10;                bp = int(raw.base_power or 0)&#10;                acc = _acc_to_prob(raw.accuracy)&#10;                mv_type = (raw.type or '').lower()&#10;                stab = 1.5 if (mv_type in my_types and mv_type) and cat in {'physical','special'} else 1.0&#10;                # status moves score low; damaging moves scale with power, STAB and accuracy (normalized)&#10;                base = 0.0&#10;                if cat in {'physical','special'} and bp &gt; 0:&#10;                    base = (bp/100.0) * stab * acc&#10;                moves_eval.append({&#10;                    'id': str(mid), 'name': getattr(mv,'name', mid),&#10;                    'score': float(base), 'score_depth': float(base), 'future_proj': 0.0, 'depth_used': 1,&#10;                    'expected': 0.0, 'exp_dmg': 0.0, 'acc': float(acc), 'effectiveness': 1.0,&#10;                    'first_prob': 0.5, 'p_ko_if_hit': 0.0, 'p_ko_first': 0.0,&#10;                    'opp_counter_ev': 0.0, 'incoming_frac': 0.0,&#10;                    'score_breakdown': {&#10;                        'expected': base,&#10;                        'opp_dmg_penalty': 0.0,&#10;                        'go_first_bonus': 0.0,&#10;                        'effectiveness_mult': 0.0,&#10;                        'accuracy_mult': 0.0,&#10;                        'ko_bonus': 0.0,&#10;                    }&#10;                })&#10;            moves_eval.sort(key=lambda x: x.get('score_depth', x.get('score',0.0)), reverse=True)&#10;            # When we don't know the opponent, avoid considering switches (prevents pointless cycling)&#10;            switches_eval = []&#10;&#10;        # If we are in a force switch situation (or move eval skipped) we may still need switch evaluations&#10;        if not switches_eval and legal_switches:&#10;            try:&#10;                active_species_lower = ''&#10;                if my_key and my_key in state.team.ours and getattr(state.team.ours[my_key],'current_hp',0)&gt;0:&#10;                    active_species_lower = (getattr(state.team.ours[my_key], 'species', '') or '').lower()&#10;                for sw in legal_switches:&#10;                    species = str(getattr(sw,'species','') or '')&#10;                    species_lower = species.lower()&#10;                    if species_lower == active_species_lower:&#10;                        continue  # do not switch to same&#10;                    cand_key=None&#10;                    for k,ps in state.team.ours.items():&#10;                        if str(getattr(ps,'species','')).lower()==species_lower:&#10;                            cand_key=k; break&#10;                    if not cand_key:&#10;                        continue&#10;                    cand_hp = _hp_frac(state.team.ours[cand_key])&#10;                    # Incoming damage expectation (if opponent active known)&#10;                    try:&#10;                        incoming = _opp_best_on_target(state, opp_key, cand_key, mi) if opp_key else 0.0&#10;                    except Exception:&#10;                        incoming = 0.0&#10;                    outgoing = 0.0&#10;                    if opp_key:&#10;                        try:&#10;                            for mv_obj in getattr(state.team.ours[cand_key], 'moves', []) or []:&#10;                                mid2 = getattr(mv_obj,'id',None)&#10;                                if not mid2: continue&#10;                                bp2 = int(getattr(mv_obj,'base_power',0) or getattr(mv_obj,'basePower',0) or 0)&#10;                                if (getattr(mv_obj,'category','') or '').lower()=='status' or bp2&lt;=0: continue&#10;                                frac2,_ = _expected_damage_fraction(state, cand_key, opp_key, mid2, mi)&#10;                                outgoing = max(outgoing, frac2*_acc_to_prob(getattr(mv_obj,'accuracy',None)))&#10;                        except Exception:&#10;                            pass&#10;                    W=self._W&#10;                    score = W['switch_outgoing_mult']*outgoing - W['switch_incoming_penalty']*incoming&#10;                    switches_eval.append({&#10;                        'species':species,'score':float(score),'base_score':float(score),&#10;                        'outgoing_frac':float(outgoing),'incoming_on_switch':float(incoming),&#10;                        'hazards_frac':0.0,'hp_fraction':float(cand_hp),&#10;                        'score_breakdown': {&#10;                            'switch_outgoing_mult': W['switch_outgoing_mult']*outgoing,&#10;                            'switch_incoming_penalty': - W['switch_incoming_penalty']*incoming,&#10;                        }&#10;                    })&#10;                switches_eval.sort(key=lambda x: x.get('score',0.0), reverse=True)&#10;            except Exception:&#10;                pass&#10;            if force_switch and not switches_eval:&#10;                skip_reason = (skip_reason or '') + '|force_switch_no_candidates_after_synth'&#10;&#10;        # Simplified switch evaluation&#10;        # (Removed duplicate; switches_eval already built earlier for tree search or fallback above)&#10;        # --- Lethal / last-mon heuristics ---&#10;        active_hp_frac=None; predicted_incoming_frac=None; lethal_before_action=False; lethal_risk=0.0&#10;        if my_key and opp_key:&#10;            try: active_hp_frac = _hp_frac(state.team.ours[my_key])&#10;            except Exception: active_hp_frac = None&#10;            try: predicted_incoming_frac = _opp_best_on_target(state, opp_key, my_key, mi)&#10;            except Exception: predicted_incoming_frac = None&#10;            if active_hp_frac is not None and predicted_incoming_frac is not None and predicted_incoming_frac &gt;= active_hp_frac - 1e-6:&#10;                lethal_before_action = True&#10;        our_remaining = 0; opp_remaining = 0&#10;        try: our_remaining = sum(1 for ps in state.team.ours.values() if getattr(ps,'current_hp',0)&gt;0)&#10;        except Exception: pass&#10;        try: opp_remaining = sum(1 for ps in state.team.opponent.values() if getattr(ps,'current_hp',0)&gt;0)&#10;        except Exception: pass&#10;        best_move = moves_eval[0] if moves_eval else None&#10;        best_switch = switches_eval[0] if switches_eval else None&#10;        if lethal_before_action and best_move and active_hp_frac:&#10;            first_prob = float(best_move.get('first_prob',0.5) or 0.5)&#10;            p_ko_if_hit_by_opp = 0.0&#10;            if predicted_incoming_frac is not None and active_hp_frac&gt;0:&#10;                p_ko_if_hit_by_opp = min(1.0, predicted_incoming_frac/active_hp_frac)&#10;            lethal_risk = p_ko_if_hit_by_opp * (1-first_prob)&#10;            can_switch = our_remaining&gt;1 and bool(switches_eval)&#10;            if lethal_risk &gt;= 0.6 and first_prob &lt; 0.5 and can_switch:&#10;                # Penalize non-priority non-KO move&#10;                if best_move.get('p_ko_first',0.0) &lt; 0.9:&#10;                    best_move['score_depth'] = -999.0&#10;                    best_move['score'] = -999.0&#10;                    best_move.setdefault('heuristics',{})['lethal_risk_penalty'] = lethal_risk&#10;                    moves_eval.sort(key=lambda x: x.get('score_depth', x.get('score',0.0)), reverse=True)&#10;                    best_move = moves_eval[0]&#10;            # prefer survivable switch&#10;            if can_switch and best_switch and first_prob &lt; 0.5:&#10;                if best_switch.get('incoming_on_switch',1.0) &lt; (active_hp_frac or 1.0):&#10;                    best_switch['score'] = max(best_switch['score'], (best_move.get('score_depth', best_move.get('score',0.0)) or 0.0)+0.01)&#10;                    best_switch.setdefault('heuristics',{})['lethal_switch_preference']=True&#10;        # last mon aggression&#10;        if our_remaining &lt;= 1 and moves_eval:&#10;            moves_eval.sort(key=lambda x: (x.get('expected',0.0)*x.get('acc',1.0)), reverse=True)&#10;            best_move = moves_eval[0]&#10;&#10;        snap = snapshot_battle(battle)&#10;&#10;        def _debug_base():&#10;            return {&#10;                'candidates': moves_eval,&#10;                'switches': switches_eval,&#10;                'switch_meta': {},&#10;                'snapshot': snap,&#10;                'active_hp_frac': active_hp_frac,&#10;                'predicted_incoming_frac': predicted_incoming_frac,&#10;                'lethal_before_action': lethal_before_action,&#10;                'lethal_risk': lethal_risk,&#10;                'our_remaining': our_remaining,&#10;                'opp_remaining': opp_remaining,&#10;                'depth': self._depth,&#10;                'branching': self._branching,&#10;                'softmin_temp': self._softmin_temp,&#10;                'tree_trace': tree_trace[:5000],  # cap to avoid runaway size&#10;            }&#10;&#10;        # Forced switch&#10;        # Ensure local vars exist even if earlier evaluation failed&#10;        if 'best_move' not in locals():&#10;            best_move = None  # type: ignore&#10;        if 'best_switch' not in locals():&#10;            best_switch = None  # type: ignore&#10;        if force_switch and best_switch:&#10;            dbg = _debug_base(); dbg['picked']={'kind':'switch', **best_switch}&#10;            decision = ChosenAction(kind='switch', switch_species=best_switch['species'], debug=dbg)&#10;        else:&#10;            # Choose move vs switch (margin)&#10;            MARGIN = 0.05&#10;            if best_move and (not best_switch or best_move.get('score_depth', best_move.get('score',0.0)) &gt;= best_switch.get('score',0.0)+MARGIN):&#10;                dbg = _debug_base();&#10;                dbg['picked']={'kind':'move', **best_move};&#10;                dbg['order']={'p_user_first': float(best_move.get('first_prob',0.5))}&#10;                decision = ChosenAction(kind='move', move_id=str(best_move['id']), debug=dbg)&#10;            elif best_switch:&#10;                dbg = _debug_base(); dbg['picked']={'kind':'switch', **best_switch}&#10;                decision = ChosenAction(kind='switch', switch_species=best_switch['species'], debug=dbg)&#10;            else:&#10;                # Fallbacks&#10;                if legal_moves:&#10;                    dbg = _debug_base(); dbg['fallback']=True&#10;                    decision = ChosenAction(kind='move', move_id=str(getattr(legal_moves[0],'id','')), debug=dbg)&#10;                elif legal_switches:&#10;                    dbg = _debug_base(); dbg['fallback']=True&#10;                    decision = ChosenAction(kind='switch', switch_species=str(getattr(legal_switches[0],'species','')), debug=dbg)&#10;                else:&#10;                    dbg = _debug_base(); dbg['fallback']=True&#10;                    decision = ChosenAction(kind='move', move_id='struggle', debug=dbg)&#10;&#10;        # ---- Instrumentation logging ----&#10;        try:&#10;            top_moves = []&#10;            for m in (moves_eval[:3] if moves_eval else []):&#10;                top_moves.append({&#10;                    'id': m.get('id'), 'score': round(float(m.get('score_depth', m.get('score',0.0))),4),&#10;                    'exp': round(float(m.get('expected',0.0)),4),&#10;                    'first': round(float(m.get('first_prob',0.0)),3),&#10;                    'p_ko_first': round(float(m.get('p_ko_first',0.0)),3),&#10;                    'opp_ev': round(float(m.get('opp_counter_ev',0.0)),4)&#10;                })&#10;            top_switches = []&#10;            for s in (switches_eval[:2] if switches_eval else []):&#10;                top_switches.append({&#10;                    'species': s.get('species'), 'score': round(float(s.get('score',0.0)),4),&#10;                    'out': round(float(s.get('outgoing_frac', s.get('outgoing',0.0))),4),&#10;                    'in': round(float(s.get('incoming_on_switch', s.get('incoming_frac',0.0))),4),&#10;                })&#10;            picked = decision.debug.get('picked') if isinstance(decision.debug, dict) else None&#10;            _dec_log.update({&#10;                'active_hp_frac': decision.debug.get('active_hp_frac') if isinstance(decision.debug, dict) else None,&#10;                'predicted_incoming_frac': decision.debug.get('predicted_incoming_frac') if isinstance(decision.debug, dict) else None,&#10;                'lethal_before_action': decision.debug.get('lethal_before_action') if isinstance(decision.debug, dict) else None,&#10;                'lethal_risk': decision.debug.get('lethal_risk') if isinstance(decision.debug, dict) else None,&#10;                'our_remaining': decision.debug.get('our_remaining') if isinstance(decision.debug, dict) else None,&#10;                'opp_remaining': decision.debug.get('opp_remaining') if isinstance(decision.debug, dict) else None,&#10;                'top_moves': top_moves,&#10;                'top_switches': top_switches,&#10;                'chosen': {'kind': decision.kind, 'move_id': decision.move_id, 'switch': decision.switch_species, 'picked': picked},&#10;            })&#10;            logging.getLogger('Decision').info('DECISION turn=%s payload=%s', _dec_log.get('turn'), json.dumps(_dec_log, default=str))&#10;        except Exception:&#10;            pass&#10;        # Verbose terminal debugging of the full think process&#10;        if getattr(self, '_verbose', False):&#10;            try:&#10;                # Re-check env each call so user can toggle externally mid-run&#10;                import os as _os&#10;                if not self._verbose and _os.environ.get('POKECHAD_THINK_DEBUG') in ('1','true','TRUE','True'):&#10;                    self._verbose = True&#10;                turn = getattr(battle,'turn', None)&#10;                tag = getattr(battle,'battle_tag', getattr(battle,'room_id', ''))&#10;                header = f&quot;[THINK][Turn {turn}][{tag}] Depth={self._depth} Branching={self._branching}&quot;&#10;                lines = [&quot;&quot;, header]&#10;                if moves_eval:&#10;                    lines.append(&quot; Moves (sorted):&quot;)&#10;                    for mv in moves_eval:&#10;                        bd = mv.get('score_breakdown', {})&#10;                        comp_str = ' '.join(f&quot;{k}={v:+.3f}&quot; for k,v in bd.items())&#10;                        future = mv.get('future_proj',0.0)&#10;                        depth_score = mv.get('score_depth', mv.get('score'))&#10;                        lines.append((&quot;  - {name:&lt;18} id={id:&lt;12} S={s:+.3f} DS={ds:+.3f} Fut={fut:+.3f} Exp={exp:.3f} Acc={acc:.2f} Eff={eff:.2f} First={first:.2f} KOFirst={kof:.3f} OppEV={opp:.3f} -&gt; {comp}&quot; )&#10;                                      .format(name=str(mv.get('name',''))[:18], id=str(mv.get('id',''))[:12], s=float(mv.get('score',0.0)), ds=float(depth_score), fut=float(future), exp=float(mv.get('expected',0.0)), acc=float(mv.get('acc',0.0)), eff=float(mv.get('effectiveness',0.0)), first=float(mv.get('first_prob',0.0)), kof=float(mv.get('p_ko_first',0.0)), opp=float(mv.get('opp_counter_ev',0.0)), comp=comp_str))&#10;                else:&#10;                    # Build a more specific reason string&#10;                    if not skip_reason:&#10;                        if force_switch: skip_reason = f&quot;force_switch={force_switch}&quot;&#10;                        elif not my_key: skip_reason = &quot;my_key=None&quot;&#10;                        elif not opp_key: skip_reason = &quot;opp_key=None&quot;&#10;                        elif legal_moves: skip_reason = &quot;eval_guard_failed&quot;&#10;                        else: skip_reason = &quot;no legal moves&quot;&#10;                    lines.append(f&quot; No move candidates ({skip_reason})&quot;)&#10;                    if legal_moves:&#10;                        lines.append(f&quot;  DEBUG flags: force_switch={force_switch} my_key={my_key} opp_key={opp_key} #legal_moves={len(legal_moves)} #legal_switches={len(legal_switches)}&quot;)&#10;                if switches_eval:&#10;                    lines.append(&quot; Switch candidates:&quot;)&#10;                    for sw in switches_eval:&#10;                        bd = sw.get('score_breakdown', {})&#10;                        comp_str = ' '.join(f&quot;{k}={v:+.3f}&quot; for k,v in bd.items())&#10;                        lines.append((&quot;  - {sp:&lt;18} S={s:+.3f} Out={out:.3f} In={inn:.3f} HP={hp:.2f} Haz={haz:.3f} -&gt; {comp}&quot;)&#10;                                      .format(sp=str(sw.get('species',''))[:18], s=float(sw.get('score',0.0)), out=float(sw.get('outgoing_frac',0.0)), inn=float(sw.get('incoming_on_switch',0.0)), hp=float(sw.get('hp_fraction',0.0)), haz=float(sw.get('hazards_frac',0.0)), comp=comp_str))&#10;                else:&#10;                    lines.append(&quot; No switch candidates&quot;)&#10;                # Tree trace printing (requires both verbose and env POKECHAD_TREE_TRACE=1)&#10;                try:&#10;                    tree_trace_env = os.environ.get('POKECHAD_TREE_TRACE','0')&#10;                except Exception:&#10;                    tree_trace_env = '0'&#10;                if str(tree_trace_env) in ('1','true','TRUE','True'):&#10;                    trace_list = decision.debug.get('tree_trace') if isinstance(decision.debug, dict) else None&#10;                    if trace_list:&#10;                        try:&#10;                            max_lines = int(os.environ.get('POKECHAD_TREE_TRACE_MAX','300'))&#10;                        except Exception:&#10;                            max_lines = 300&#10;                        lines.append(f&quot; Tree trace (showing up to {max_lines} of {len(trace_list)} lines):&quot;)&#10;                        for tl in trace_list[:max_lines]:&#10;                            lines.append(&quot;   &quot; + tl)&#10;                        if len(trace_list) &gt; max_lines:&#10;                            lines.append(f&quot;   ... ({len(trace_list)-max_lines} more lines truncated)&quot;)&#10;                pk = decision.debug.get('picked') if isinstance(decision.debug, dict) else {}&#10;                if pk:&#10;                    if pk.get('kind')=='move':&#10;                        lines.append(f&quot; -&gt; PICK MOVE {pk.get('name')} (id={pk.get('id')}) score={pk.get('score')} depth_score={pk.get('score_depth', pk.get('score'))}&quot;)&#10;                    else:&#10;                        lines.append(f&quot; -&gt; PICK SWITCH {pk.get('species')} score={pk.get('score')}&quot;)&#10;                if decision.debug.get('lethal_before_action'):&#10;                    lines.append(f&quot;  Lethal risk detected: risk={decision.debug.get('lethal_risk'):.3f}&quot;)&#10;                # Emit via print (flush) and logging so UI log tab captures it&#10;                logger = logging.getLogger('ThinkVerbose')&#10;                for ln in lines:&#10;                    print(ln, flush=True)&#10;                    try: logger.info(ln)&#10;                    except Exception: pass&#10;            except Exception:&#10;                pass&#10;        return decision&#10;&#10;def _stage_mult(stage: int) -&gt; float:&#10;    &quot;&quot;&quot;Pokemon stage multiplier for Atk/Def/SpA/SpD/Spe.&#10;    stage in [-6, +6]. Returns the standard (2+s)/2 for s&gt;=0 else 2/(2-s).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        s = int(stage)&#10;    except Exception:&#10;        s = 0&#10;    if s &gt;= 0:&#10;        return (2 + s) / 2&#10;    return 2 / (2 - s)&#10;&#10;# -------------- Poke-env Player wrapper ----------------&#10;try:&#10;    from poke_env.player.player import Player  # type: ignore&#10;except Exception:&#10;    Player = object  # fallback&#10;&#10;class StockfishPokeEnvPlayer(Player):  # type: ignore[misc]&#10;    def __init__(self, *args, **kwargs):&#10;        self.on_think_hook = kwargs.pop('on_think', None)&#10;        engine_depth = kwargs.pop('engine_depth', None)&#10;        self.engine = kwargs.pop('engine', None) or StockfishModel(kwargs.get('battle_format','gen9ou'))&#10;        try: self.engine.set_depth(int(engine_depth))&#10;        except Exception: pass&#10;        self._request_cache = {}&#10;        super().__init__(*args, **kwargs)&#10;&#10;    def _build_request_signature(self, battle) -&gt; tuple:&#10;        try:&#10;            turn = getattr(battle,'turn',None)&#10;            force_switch = bool(getattr(battle,'force_switch',False))&#10;            moves = [(getattr(m,'id',None), getattr(m,'pp',None)) for m in (getattr(battle,'available_moves',[]) or [])]&#10;            switches = [getattr(p,'species',None) for p in (getattr(battle,'available_switches',[]) or [])]&#10;            active = getattr(getattr(battle,'active_pokemon',None),'species',None)&#10;            return (turn, force_switch, active, tuple(moves), tuple(switches))&#10;        except Exception:&#10;            return (None,)&#10;&#10;    def choose_move(self, battle):&#10;        tag = getattr(battle,'battle_tag', getattr(battle,'room_id',None))&#10;        sig = self._build_request_signature(battle)&#10;        cached = self._request_cache.get(tag)&#10;        if cached and cached[0]==sig:&#10;            try: return cached[1]&#10;            except Exception: pass&#10;        decision = self.engine.choose_action(battle)&#10;        # think hook logging&#10;        try:&#10;            if self.on_think_hook and isinstance(decision.debug, dict):&#10;                dd = dict(decision.debug)&#10;                dd.setdefault('snapshot', snapshot_battle(battle))&#10;                dd['battle_tag']=tag; dd['turn']=getattr(battle,'turn',None)&#10;                import logging as _lg, json as _json&#10;                _lg.getLogger('Think').info('UI_THINK turn=%s payload=%s', getattr(battle,'turn',None), _json.dumps(dd, default=str))&#10;                self.on_think_hook(battle, dd)&#10;        except Exception: pass&#10;        try:&#10;            if decision.kind=='move' and decision.move_id:&#10;                for m in (getattr(battle,'available_moves',[]) or []):&#10;                    if str(getattr(m,'id','')) == str(decision.move_id):&#10;                        order = self.create_order(m); self._request_cache[tag]=(sig, order); return order&#10;                order = self.create_order((getattr(battle,'available_moves',[]) or [None])[0]) or self.choose_random_move(battle)&#10;                self._request_cache[tag]=(sig, order); return order&#10;            elif decision.kind=='switch' and decision.switch_species:&#10;                cursp=''&#10;                try: cursp=(getattr(getattr(battle,'active_pokemon',None),'species',None) or '').lower()&#10;                except Exception: pass&#10;                for p in (getattr(battle,'available_switches',[]) or []):&#10;                    sp = (str(getattr(p,'species','')).lower())&#10;                    if sp==cursp: continue&#10;                    if sp == str(decision.switch_species).lower():&#10;                        order = self.create_order(p); self._request_cache[tag]=(sig, order); return order&#10;                for p in (getattr(battle,'available_switches',[]) or []):&#10;                    if (str(getattr(p,'species','')).lower()) != cursp:&#10;                        order = self.create_order(p); self._request_cache[tag]=(sig, order); return order&#10;                order = self.choose_random_move(battle); self._request_cache[tag]=(sig, order); return order&#10;            order = self.choose_random_move(battle); self._request_cache[tag]=(sig, order); return order&#10;        except Exception:&#10;            order = self.choose_random_move(battle); self._request_cache[tag]=(sig, order); return order&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/GPT_UI.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/GPT_UI.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;User interface for GPT-based Pokemon battle AI&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox, scrolledtext&#10;import threading&#10;from typing import Dict, List, Optional&#10;&#10;# Third-party imports&#10;# import matplotlib.pyplot as plt&#10;# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;&#10;# Local imports&#10;# from Models.GPT_Model import GPTModel&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;&#10;class GPT_UI:&#10;    &quot;&quot;&quot;User interface for GPT model interactions&quot;&quot;&quot;&#10;    &#10;    def __init__(self, root):&#10;        self.root = root&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/RL_UI.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/RL_UI.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;User interface for Reinforcement Learning Pokemon battle AI&#10;&quot;&quot;&quot;&#10;&#10;# Standard library imports&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox, scrolledtext&#10;import threading&#10;import time&#10;from typing import Dict, List, Optional&#10;&#10;# Third-party imports&#10;# import matplotlib.pyplot as plt&#10;# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg&#10;# import numpy as np&#10;&#10;# Local imports&#10;# from Models.RL_Model import RLModel&#10;# from Data.poke_env_battle_environment import PokeEnvBattleEnvironment&#10;&#10;class RL_UI:&#10;    &quot;&quot;&quot;User interface for RL model interactions&quot;&quot;&quot;&#10;&#10;    def __init__(self, root):&#10;        self.root = root&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/tk_main_menu.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/tk_main_menu.py" />
              <option name="originalContent" value="# UI/tk_main_menu.py&#10;&quot;&quot;&quot;&#10;Simple launcher for Stockfish model with Tkinter.&#10;&#10;- Lets the user enter Showdown credentials, pick server and format.&#10;- Launches the Stockfish window.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;&#10;# --- injected by fix_type_effectiveness.py (safe no-op if repeated) ---&#10;try:&#10;    from utils.type_effectiveness import install_logging_hook, init_typecalc&#10;    from pathlib import Path&#10;    import os&#10;    install_logging_hook()&#10;    # Dynamic showdown data dir discovery&#10;    _root = Path(__file__).resolve().parent.parent&#10;    _cands = [&#10;        Path(os.getenv('POKECHAD_SHOWDOWN_DIR', '')),&#10;        _root / 'tools' / 'Data' / 'showdown',&#10;        _root / 'showdown',&#10;        _root / 'tools' / 'showdown',&#10;        _root / 'Resources' / 'showdown',&#10;    ]&#10;    _chosen = None&#10;    for _c in _cands:&#10;        if _c and ( (_c / 'moves.json').exists() or (_c / 'pokedex.json').exists() ):&#10;            _chosen = _c; break&#10;    if _chosen is None:&#10;        _chosen = _cands[1]&#10;    init_typecalc(_chosen)&#10;except Exception as _typecalc_e:&#10;    import logging&#10;    logging.getLogger('typecalc').warning('Could not install typecalc logging: %s', _typecalc_e)&#10;# --- end injection ---&#10;import os&#10;import sys&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox&#10;import json&#10;from pathlib import Path&#10;import time&#10;import threading&#10;&#10;from UI.tk_stockfish_model_ui import launch_stockfish_window, KNOWN_FORMATS  # type: ignore&#10;&#10;class MainMenu(tk.Tk):&#10;    CONFIG_PATH = Path.home() / '.pokechad_ui_settings.json'&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.title(&quot;PokeCHAD — Main Menu&quot;)&#10;        self.geometry(&quot;520x320&quot;)&#10;        self._loaded_settings = self._load_settings()&#10;        self.protocol(&quot;WM_DELETE_WINDOW&quot;, self._on_close)&#10;        self._build(self._loaded_settings)&#10;&#10;    def _load_settings(self) -&gt; dict:&#10;        try:&#10;            if self.CONFIG_PATH.exists():&#10;                with open(self.CONFIG_PATH, 'r', encoding='utf-8') as f:&#10;                    data = json.load(f)&#10;                if isinstance(data, dict):&#10;                    return data&#10;        except Exception:&#10;            pass&#10;        return {}&#10;&#10;    def _save_settings(self):&#10;        try:&#10;            data = {&#10;                'username': self.username.get().strip() if hasattr(self, 'username') else None,&#10;                'password': self.password.get() if hasattr(self, 'password') else None,&#10;                'server_mode': self.server_mode.get() if hasattr(self, 'server_mode') else None,&#10;                'custom_ws': self.custom_ws.get().strip() if hasattr(self, 'custom_ws') else None,&#10;                'format': self.format_var.get().strip() if hasattr(self, 'format_var') else None,&#10;            }&#10;            with open(self.CONFIG_PATH, 'w', encoding='utf-8') as f:&#10;                json.dump(data, f, indent=2)&#10;        except Exception:&#10;            pass&#10;&#10;    def _build(self, settings: dict):&#10;        frame = ttk.Frame(self)&#10;        frame.pack(fill=tk.BOTH, expand=True, padx=14, pady=14)&#10;&#10;        ttk.Label(frame, text=&quot;Username&quot;).grid(row=0, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.username = tk.StringVar(value=settings.get('username') or os.environ.get(&quot;PS_USERNAME&quot;, &quot;Containedo3mini&quot;))&#10;        ttk.Entry(frame, textvariable=self.username, width=28).grid(row=0, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Password (optional)&quot;).grid(row=1, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.password = tk.StringVar(value=settings.get('password') or os.environ.get(&quot;PS_PASSWORD&quot;, &quot;Kodbe4-gobpot-bujmoh&quot;))&#10;        ttk.Entry(frame, textvariable=self.password, width=28, show=&quot;*&quot;).grid(row=1, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Server&quot;).grid(row=2, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.server_mode = tk.StringVar(value=settings.get('server_mode') or &quot;Showdown&quot;)&#10;        ttk.Combobox(frame, textvariable=self.server_mode, values=[&quot;Showdown&quot;, &quot;Localhost&quot;], width=24, state=&quot;readonly&quot;).grid(row=2, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Custom WS URL&quot;).grid(row=3, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.custom_ws = tk.StringVar(value=settings.get('custom_ws') or &quot;&quot;)&#10;        ttk.Entry(frame, textvariable=self.custom_ws, width=28).grid(row=3, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Format&quot;).grid(row=4, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.format_var = tk.StringVar(value=settings.get('format') or &quot;gen9randombattle&quot;)&#10;        ttk.Combobox(frame, textvariable=self.format_var, values=KNOWN_FORMATS, width=24, state=&quot;readonly&quot;).grid(row=4, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        def go():&#10;            self._save_settings()&#10;            launch_stockfish_window(self, username=self.username.get().strip(),&#10;                                    password=(self.password.get().strip() or None),&#10;                                    server_mode=self.server_mode.get(),&#10;                                    custom_ws=(self.custom_ws.get().strip() or None),&#10;                                    battle_format=self.format_var.get().strip())&#10;&#10;        ttk.Button(frame, text=&quot;Launch Stockfish Model&quot;, command=go).grid(row=5, column=0, columnspan=2, pady=(18,4))&#10;&#10;        # Weight tuner button&#10;        ttk.Button(frame, text=&quot;Run Weight Tuner&quot;, command=self._open_tuner_dialog).grid(row=6, column=0, columnspan=2, pady=(6,8))&#10;&#10;    # --- Weight Tuner Dialog ---&#10;    def _open_tuner_dialog(self):&#10;        dlg = tk.Toplevel(self); dlg.title(&quot;Weight Tuner&quot;)&#10;        dlg.geometry(&quot;960x560&quot;)  # widen a bit more for extra controls&#10;&#10;        # Params frame&#10;        params = ttk.LabelFrame(dlg, text='Parameters'); params.grid(row=0, column=0, columnspan=3, sticky='ew', padx=6, pady=6)&#10;        for i in range(16): params.columnconfigure(i, weight=0)  # extended to include new columns&#10;        ttk.Label(params, text=&quot;Format&quot;).grid(row=0, column=0, sticky='e', padx=4, pady=4)&#10;        fmt_var = tk.StringVar(value=self.format_var.get())&#10;        ttk.Combobox(params, textvariable=fmt_var, values=KNOWN_FORMATS, width=22, state='readonly').grid(row=0, column=1, sticky='w', padx=4, pady=4)&#10;        def _intvar(default): return tk.IntVar(value=default)&#10;        def _dblvar(default): return tk.DoubleVar(value=default)&#10;        pop_var = _intvar(16); gen_var = _intvar(10); seeds_var = _intvar(16)&#10;        sigma_var = _dblvar(1.0); promote_diff_var = _dblvar(0.02); patience_var = _intvar(10)&#10;        online_var = tk.BooleanVar(value=False)&#10;        ttk.Label(params, text=&quot;Population&quot;).grid(row=0, column=2, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=pop_var, width=6).grid(row=0, column=3, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Generations&quot;).grid(row=0, column=4, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=gen_var, width=6).grid(row=0, column=5, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Seeds&quot;).grid(row=0, column=6, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=seeds_var, width=6).grid(row=0, column=7, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Sigma&quot;).grid(row=0, column=8, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=sigma_var, width=6).grid(row=0, column=9, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;PromoteΔ&quot;).grid(row=0, column=10, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=promote_diff_var, width=6).grid(row=0, column=11, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Patience&quot;).grid(row=0, column=12, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=patience_var, width=6).grid(row=0, column=13, sticky='w', padx=2, pady=4)&#10;        ttk.Checkbutton(params, text=&quot;Online&quot;, variable=online_var).grid(row=0, column=14, sticky='w', padx=8, pady=4)&#10;        reset_hist_var = tk.BooleanVar(value=True)&#10;        ttk.Checkbutton(params, text=&quot;ResetHist&quot;, variable=reset_hist_var).grid(row=0, column=15, sticky='w', padx=4, pady=4)&#10;        # Candidates tree&#10;        cand_frame = ttk.LabelFrame(dlg, text='Current Generation Candidates')&#10;        cand_frame.grid(row=2, column=0, sticky='nsew', padx=6, pady=6)&#10;        dlg.rowconfigure(2, weight=1)&#10;        columns = ('idx','wr','wins','games','diff','sigma')&#10;        cand_tree = ttk.Treeview(cand_frame, columns=columns, show='headings', height=10)&#10;        headers = {'idx':'IDX','wr':'WR','wins':'W','games':'G','diff':'ΔChampion','sigma':'σ'}&#10;        widths = {'idx':40,'wr':60,'wins':50,'games':50,'diff':90,'sigma':60}&#10;        for c in columns:&#10;            cand_tree.heading(c, text=headers.get(c,c))&#10;            cand_tree.column(c, width=widths.get(c,80), anchor=tk.CENTER)&#10;        cand_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        cand_scroll = ttk.Scrollbar(cand_frame, orient='vertical', command=cand_tree.yview)&#10;        cand_scroll.pack(side=tk.RIGHT, fill=tk.Y)&#10;        cand_tree.configure(yscrollcommand=cand_scroll.set)&#10;&#10;        # Champion weights&#10;        champ_frame = ttk.LabelFrame(dlg, text='Champion Weights')&#10;        champ_frame.grid(row=2, column=1, sticky='nsew', padx=6, pady=6)&#10;        dlg.rowconfigure(2, weight=1)&#10;        champ_text = tk.Text(champ_frame, height=14, width=34)&#10;        champ_text.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;&#10;        # History panel&#10;        history_frame = ttk.LabelFrame(dlg, text='Champion History')&#10;        history_frame.grid(row=2, column=2, rowspan=2, sticky='nsew', padx=6, pady=6)&#10;        dlg.columnconfigure(2, weight=1)&#10;        history_list = tk.Listbox(history_frame, height=16)&#10;        history_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(4,0), pady=4)&#10;        hist_scroll = ttk.Scrollbar(history_frame, orient='vertical', command=history_list.yview)&#10;        hist_scroll.pack(side=tk.RIGHT, fill=tk.Y)&#10;        history_list.configure(yscrollcommand=hist_scroll.set)&#10;        hist_btn_frame = ttk.Frame(history_frame); hist_btn_frame.pack(fill=tk.X, padx=4, pady=(0,4))&#10;        refresh_hist_btn = ttk.Button(hist_btn_frame, text='Refresh History')&#10;        refresh_hist_btn.pack(side=tk.LEFT, padx=(0,4))&#10;        export_hist_btn = ttk.Button(hist_btn_frame, text='Export Selected')&#10;        export_hist_btn.pack(side=tk.LEFT, padx=(0,4))&#10;        load_hist_btn = ttk.Button(hist_btn_frame, text='Load Selected')&#10;        load_hist_btn.pack(side=tk.LEFT, padx=(0,4))&#10;&#10;        # Adjust placement of log frame (row 3 instead of 4 to accommodate resized layout)&#10;        # Log box&#10;        dlg.rowconfigure(3, weight=1)&#10;        log_box = tk.Text(log_frame, height=8)&#10;        log_box.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;        btn_frame = ttk.Frame(dlg); btn_frame.grid(row=5, column=0, columnspan=3, sticky='ew', padx=6, pady=(0,6))&#10;        start_btn = ttk.Button(btn_frame, text='Start')&#10;        start_btn.pack(side=tk.LEFT, padx=(0,6))&#10;        close_btn = ttk.Button(btn_frame, text='Close', command=dlg.destroy)&#10;        close_btn.pack(side=tk.LEFT)&#10;        reload_btn = ttk.Button(btn_frame, text='Reload champion from file')&#10;        reload_btn.pack(side=tk.RIGHT)&#10;&#10;        # Shared state&#10;        state = {&#10;            'current_gen': 0,&#10;            'champion_wr': 0.5,&#10;            'champion': {},&#10;            'sigma': None,&#10;            'candidates': [],  # list of dicts&#10;            'champion_wr_at_gen_start': 0.5,&#10;            'stop': False,&#10;            'log_pos': 0,&#10;            'log_path': Path('logs')/ 'weight_tuning.jsonl',&#10;            'run_proc': None,&#10;            'expected_generations': lambda: gen_var.get(),&#10;            'history': [],  # list of dicts {gen, wr, time, weights, sigma}&#10;            'selected_history': None,&#10;            'monitor_active': False,&#10;            'param_refs': {&#10;                'population': pop_var,&#10;                'generations': gen_var,&#10;                'seeds': seeds_var,&#10;                'sigma': sigma_var,&#10;                'promote_diff': promote_diff_var,&#10;                'patience': patience_var,&#10;                'online': online_var,&#10;                'reset_hist': reset_hist_var,&#10;            }&#10;        }&#10;        lock = threading.Lock()&#10;&#10;        def append_log(msg: str):&#10;            try:&#10;                log_box.insert(tk.END, msg + '\n'); log_box.see(tk.END)&#10;            except Exception: pass&#10;&#10;            if state['stop'] or not dlg.winfo_exists():&#10;                return&#10;            with lock:&#10;            except Exception: pass&#10;                gen_progress['value'] = state['current_gen']&#10;                    sigma_val = state.get('sigma')&#10;                    if sigma_val is None:&#10;                        sigma_str = '?'&#10;            except Exception: pass&#10;                gen_progress['value'] = state['current_gen']&#10;                    status_var.set(f&quot;Gen {state['current_gen']} σ=?&quot;)&#10;                    if sigma_val is None:&#10;                        sigma_str = '?'&#10;            except Exception: pass&#10;                gen_progress['value'] = state['current_gen']&#10;                    for iid in cand_tree.get_children(): cand_tree.delete(iid)&#10;                    base_wr = state.get('champion_wr_at_gen_start', 0.5) or 0.0&#10;                    if sigma_val is None:&#10;                        sigma_str = '?'&#10;                # Update progress bar&#10;                gen_progress.configure(maximum=state['expected_generations']())&#10;                gen_progress['value'] = state['current_gen']&#10;                        diff = c.get('win_rate',0) - base_wr&#10;                    for iid in cand_tree.get_children(): cand_tree.delete(iid)&#10;                # Champion weights (preserve if viewing history vs live)&#10;                    if sigma_val is None:&#10;                        sigma_str = '?'&#10;                    else:&#10;                        try:&#10;                            sigma_str = f&quot;{float(sigma_val):.3f}&quot;&#10;                        except Exception:&#10;                            sigma_str = str(sigma_val)&#10;            # Schedule next update&#10;                    for iid in cand_tree.get_children(): cand_tree.delete(iid)&#10;                    base_wr = state.get('champion_wr_at_gen_start', 0.5) or 0.0&#10;                    for c in sorted(state['candidates'], key=lambda d: d.get('win_rate',0), reverse=True):&#10;                        diff = c.get('win_rate',0) - base_wr&#10;                    for iid in cand_tree.get_children(): cand_tree.delete(iid)&#10;                # Champion weights (preserve if viewing history vs live)&#10;                    for c in sorted(state['candidates'], key=lambda d: d.get('win_rate',0), reverse=True):&#10;                        diff = c.get('win_rate',0) - base_wr&#10;                        cand_tree.insert('', tk.END, values=(c.get('idx'), f&quot;{c.get('win_rate',0):.3f}&quot;, c.get('wins'), c.get('games'), f&quot;{diff:.3f}&quot;, f&quot;{c.get('sigma',0):.2f}&quot;))&#10;                except Exception: pass&#10;                # Champion weights (preserve if viewing history vs live)&#10;            # Schedule next update&#10;                                continue&#10;                            try:&#10;                    for k,v in sorted(src_weights.items()):&#10;                        champ_text.insert(tk.END, f&quot;{k}: {v:.3f}\n&quot;)&#10;                except Exception: pass&#10;            # Schedule next update&#10;                            if et == 'init':&#10;                                if not init_seen:&#10;        # ---------------- History helpers ----------------&#10;                                        'gen': 0,&#10;                                        'wr': 0.5,&#10;                                        'sigma': evt.get('sigma'),&#10;                            if et == 'init':&#10;                                if not init_seen:&#10;                                    hist.append({&#10;                                        'gen': 0,&#10;                                        'wr': 0.5,&#10;                                        'sigma': evt.get('sigma'),&#10;                            if et == 'init':&#10;                                if not init_seen:&#10;                                    hist.append({&#10;                                        'gen': 0,&#10;                                        'wr': 0.5,&#10;                                        'sigma': evt.get('sigma'),&#10;                            if et == 'init':&#10;                                if not init_seen:&#10;                                    hist.append({&#10;                                        'gen': 0,&#10;                                        'wr': 0.5,&#10;                                        'sigma': evt.get('sigma'),&#10;                                        'weights': evt.get('champion') or {},&#10;                                        'time': None,&#10;                                    })&#10;                                    })&#10;                                    })&#10;                                hist.append({&#10;                                    'gen': evt.get('generation'),&#10;                                    'wr': evt.get('champion_wr'),&#10;                                    'sigma': evt.get('sigma'),&#10;                                    'weights': evt.get('new_champion') or {},&#10;                                    'time': evt.get('gen_seconds'),&#10;                                })&#10;                                hist.append({&#10;                                hist.append({&#10;                                    'gen': evt.get('generations'),&#10;                                    'wr': evt.get('champion_wr'),&#10;                                    'sigma': None,&#10;                                    'weights': evt.get('final_champion') or {},&#10;                                    'time': None,&#10;                                })&#10;                                    'wr': evt.get('champion_wr'),&#10;                                    'sigma': evt.get('sigma'),&#10;            # de-duplicate by generation keep last&#10;                                    'time': evt.get('gen_seconds'),&#10;                                })&#10;                                hist.append({&#10;                                hist.append({&#10;                                    'gen': evt.get('generations'),&#10;                                    'wr': evt.get('champion_wr'),&#10;                                    'sigma': None,&#10;                                    'weights': evt.get('final_champion') or {},&#10;                    history_list.insert(tk.END, f&quot;G{h['gen']} WR={h['wr']:.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                                })&#10;                                    'wr': evt.get('champion_wr'),&#10;            # If we have an initial champion (gen 0) and no current champion loaded, set it&#10;            if out and not state.get('champion'):&#10;                first = out[0]&#10;                if first.get('gen') == 0:&#10;                    state['champion'] = first.get('weights') or {}&#10;                                    'time': evt.get('gen_seconds'),&#10;                                })&#10;                                hist.append({&#10;                                hist.append({&#10;                if not sel: state['selected_history']=None; return&#10;                                    'sigma': None,&#10;                                    'weights': evt.get('final_champion') or {},&#10;                    history_list.insert(tk.END, f&quot;G{h['gen']} WR={h['wr']:.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                                })&#10;                state['selected_history']=None&#10;            # If we have an initial champion (gen 0) and no current champion loaded, set it&#10;            if out and not state.get('champion'):&#10;                first = out[0]&#10;                if first.get('gen') == 0:&#10;                    state['champion'] = first.get('weights') or {}&#10;                append_log('[warn] no history selection to export')&#10;                return&#10;                                })&#10;                            elif et == 'done':&#10;                append_log('[warn] selected history has no weights')&#10;                return&#10;                if not sel: state['selected_history']=None; return&#10;                                    'sigma': None,&#10;                                    'weights': evt.get('final_champion') or {},&#10;                    history_list.insert(tk.END, f&quot;G{h['gen']} WR={h['wr']:.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                                })&#10;                state['selected_history']=None&#10;            # If we have an initial champion (gen 0) and no current champion loaded, set it&#10;            if out and not state.get('champion'):&#10;                first = out[0]&#10;                if first.get('gen') == 0:&#10;                    state['champion'] = first.get('weights') or {}&#10;                append_log('[warn] no history selection to export')&#10;&#10;                dedup[h['gen']] = h&#10;                append_log('[warn] selected history has no weights')&#10;                return&#10;                append_log('[warn] no history selection to load')&#10;                return&#10;            for h in out:&#10;                try:&#10;&#10;        refresh_hist_btn.configure(command=build_history_from_log)&#10;        export_hist_btn.configure(command=export_selected)&#10;                    history_list.insert(tk.END, f&quot;G{h['gen']} WR={h['wr']:.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                except Exception:&#10;        # auto-populate history initially (but do NOT auto-start tuner)&#10;        build_history_from_log()&#10;&#10;        # Update history on promotions inside monitor&#10;        # (We will extend existing monitor logic later when parsing events)&#10;&#10;        # ---------------- Modified monitor_log to also update history live ----------------&#10;            # If we have an initial champion (gen 0) and no current champion loaded, set it&#10;            if out and not state.get('champion'):&#10;                first = out[0]&#10;                if first.get('gen') == 0:&#10;                    state['champion'] = first.get('weights') or {}&#10;                append_log('[warn] no history selection to export')&#10;&#10;            try:&#10;                append_log('[warn] selected history has no weights')&#10;                return&#10;                append_log('[warn] no history selection to load')&#10;                return&#10;                idx = sel[0]&#10;                if 0 &lt;= idx &lt; len(state['history']):&#10;&#10;        refresh_hist_btn.configure(command=build_history_from_log)&#10;        export_hist_btn.configure(command=export_selected)&#10;                    state['selected_history'] = state['history'][idx]&#10;            except Exception:&#10;        # auto-populate history initially (but do NOT auto-start tuner)&#10;        build_history_from_log()&#10;&#10;        # Update history on promotions inside monitor&#10;        # (We will extend existing monitor logic later when parsing events)&#10;&#10;        # ---------------- Modified monitor_log to also update history live ----------------&#10;        history_list.bind('&lt;&lt;ListboxSelect&gt;&gt;', on_history_select)&#10;&#10;        def export_selected():&#10;            h = state.get('selected_history')&#10;            if not h:&#10;                append_log('[warn] no history selection to export')&#10;&#10;            if not weights:&#10;                append_log('[warn] selected history has no weights')&#10;                return&#10;                append_log('[warn] no history selection to load')&#10;                return&#10;                models_dir = Path('Models'); models_dir.mkdir(exist_ok=True)&#10;                target = models_dir / 'weights.json'&#10;&#10;        refresh_hist_btn.configure(command=build_history_from_log)&#10;        export_hist_btn.configure(command=export_selected)&#10;                if target.exists():&#10;                    backup = target.with_name(f&quot;weights.json.bak.{int(time.time())}&quot;)&#10;        # auto-populate history initially (but do NOT auto-start tuner)&#10;        build_history_from_log()&#10;&#10;        # Update history on promotions inside monitor&#10;        # (We will extend existing monitor logic later when parsing events)&#10;&#10;        # ---------------- Modified monitor_log to also update history live ----------------&#10;                    except Exception: pass&#10;                with open(target,'w',encoding='utf-8') as f:&#10;                    json.dump(weights, f, indent=2)&#10;                append_log('[export] wrote selected champion to Models/weights.json')&#10;            except Exception as e:&#10;                append_log(f'[error] export failed: {e}')&#10;&#10;        def load_selected():&#10;            h = state.get('selected_history')&#10;            if not h:&#10;                append_log('[warn] no history selection to load')&#10;                return&#10;            state['champion'] = h.get('weights') or state['champion']&#10;            append_log(f&quot;[load] loaded history G{h.get('gen')} into champion view (not saved yet)&quot;)&#10;&#10;        refresh_hist_btn.configure(command=build_history_from_log)&#10;        export_hist_btn.configure(command=export_selected)&#10;                                        already = False&#10;                                        for h in state['history']:&#10;                                            if h.get('gen') == final_gen:&#10;                                                already = True; break&#10;&#10;        # auto-populate history initially (but do NOT auto-start tuner)&#10;                                    # Refresh history list after any mutation events&#10;        build_history_from_log()&#10;                                        seen = {}&#10;                                        for h in state['history']:&#10;                                            seen[h['gen']] = h&#10;        # Update history on promotions inside monitor&#10;        # (We will extend existing monitor logic later when parsing events)&#10;&#10;        # ---------------- Modified monitor_log to also update history live ----------------&#10;        def monitor_log():&#10;            last_size = 0&#10;            last_error_ts = 0.0&#10;            state['monitor_active'] = True&#10;            while not state['stop']:&#10;                path = state['log_path']&#10;                if path.exists():&#10;                    try:&#10;                        cur_size = path.stat().st_size&#10;                        if cur_size &lt; last_size:&#10;                            last_size = 0&#10;                        with open(path, 'r', encoding='utf-8') as f:&#10;                            if last_size:&#10;                                try:&#10;                                    f.seek(last_size)&#10;                                except Exception:&#10;                                    last_size = 0; f.seek(0)&#10;            monitor_thread = threading.Thread(target=monitor_log, daemon=True)&#10;            monitor_thread.start()&#10;                                        for h in state['history']:&#10;        # Removed automatic monitor start to avoid appearing to auto-run tuner&#10;        # build initial history from any existing log without attaching live monitor yet&#10;        build_history_from_log()&#10;&#10;        # Implement reload champion button&#10;                                                already = True; break&#10;                                line = f.readline()&#10;                                if not line:&#10;                                    # Refresh history list after any mutation events&#10;                                    break&#10;                                        seen = {}&#10;                                        for h in state['history']:&#10;                                            seen[h['gen']] = h&#10;                                try:&#10;                                    last_size = f.tell()&#10;                                except Exception:&#10;                                    pass&#10;                                if not line:&#10;                                    continue&#10;                                try:&#10;                                    evt = json.loads(line)&#10;        # Shared state&#10;        state = {&#10;            'current_gen': 0,&#10;            'champion_wr': 0.5,&#10;            'champion': {},&#10;            'sigma': None,&#10;            'candidates': [],  # list of dicts&#10;            'champion_wr_at_gen_start': 0.5,&#10;            'stop': False,&#10;            'log_pos': 0,&#10;            'log_path': Path('logs')/ 'weight_tuning.jsonl',&#10;            'run_proc': None,&#10;            'expected_generations': lambda: gen_var.get(),&#10;            'history': [],  # list of dicts {gen, wr, time, weights, sigma}&#10;            'selected_history': None,&#10;            'monitor_active': False,&#10;            'param_refs': {&#10;                'population': pop_var,&#10;                'generations': gen_var,&#10;                'seeds': seeds_var,&#10;                'sigma': sigma_var,&#10;                'promote_diff': promote_diff_var,&#10;                'patience': patience_var,&#10;                'online': online_var,&#10;                'reset_hist': reset_hist_var,&#10;            }&#10;        }&#10;        lock = threading.Lock()&#10;                                        state['current_gen'] = int(evt.get('generation', state['current_gen']))&#10;                                        state['champion_wr'] = float(evt.get('champion_wr', state['champion_wr']))&#10;                                        state['champion_wr_at_gen_start'] = state['champion_wr']&#10;                                        state['champion'] = evt.get('champion') or state['champion']&#10;                                        state['sigma'] = evt.get('sigma', state.get('sigma'))&#10;                                        state['candidates'] = []&#10;                                    elif et == 'candidate':&#10;                                        state['candidates'].append({'idx': evt.get('idx'), 'win_rate': evt.get('win_rate'), 'wins': evt.get('wins'), 'games': evt.get('games'), 'sigma': evt.get('sigma')})&#10;            monitor_thread = threading.Thread(target=monitor_log, daemon=True)&#10;            monitor_thread.start()&#10;                                        for h in state['history']:&#10;        # Removed automatic monitor start to avoid appearing to auto-run tuner&#10;        # build initial history from any existing log without attaching live monitor yet&#10;        build_history_from_log()&#10;&#10;        # Implement reload champion button&#10;                                                already = True; break&#10;                                        state['champion'] = evt.get('new_champion') or state['champion']&#10;                                        state['champion_wr'] = float(evt.get('champion_wr', state['champion_wr']))&#10;                                    # Refresh history list after any mutation events&#10;                                        state['sigma'] = evt.get('sigma', state.get('sigma'))&#10;                                        seen = {}&#10;                                        for h in state['history']:&#10;                                            seen[h['gen']] = h&#10;                                    elif et == 'no_improve':&#10;                                        state['sigma'] = evt.get('sigma', state.get('sigma'))&#10;                                    elif et == 'init':&#10;                                        state['champion'] = evt.get('champion') or state['champion']&#10;                                        # add initial champion to history if missing gen 0&#10;                                        need_init = True&#10;                                        for h in state['history']:&#10;                                            if h.get('gen') == 0:&#10;        # Shared state&#10;                # Load current champion from file at run start (so weights carry over)&#10;                try:&#10;                    weights_path = Path('Models') / 'weights.json'&#10;                    if weights_path.exists():&#10;                        with open(weights_path,'r',encoding='utf-8') as f:&#10;                            data = json.load(f)&#10;                        if isinstance(data, dict):&#10;                            state['champion'] = data&#10;                except Exception:&#10;                    pass&#10;            'candidates': [],  # list of dicts&#10;                log_box.delete('1.0', tk.END)&#10;            except Exception:&#10;                pass&#10;        lock = threading.Lock()&#10;                                        final_gen = evt.get('generations')&#10;                                        final_entry = {&#10;                                            'gen': final_gen,&#10;                                            'wr': evt.get('champion_wr'),&#10;                                            'sigma': None,&#10;                                            'weights': evt.get('final_champion') or state.get('champion', {}),&#10;                                            'time': None,&#10;                                        }&#10;            monitor_thread = threading.Thread(target=monitor_log, daemon=True)&#10;            monitor_thread.start()&#10;                                        for h in state['history']:&#10;        # Removed automatic monitor start to avoid appearing to auto-run tuner&#10;        # build initial history from any existing log without attaching live monitor yet&#10;        build_history_from_log()&#10;&#10;        # Implement reload champion button&#10;                                                already = True; break&#10;                                        if not already:&#10;                                            state['history'].append(final_entry)&#10;                                    # Refresh history list after any mutation events&#10;                                    if et in ('promote','done','init'):&#10;                                        seen = {}&#10;                                        for h in state['history']:&#10;                                            seen[h['gen']] = h&#10;                                        state['history'] = list(sorted(seen.values(), key=lambda d: d['gen']))&#10;                                        history_list.delete(0, tk.END)&#10;                                        for h in state['history']:&#10;                                            try:&#10;                                                history_list.insert(tk.END, f&quot;G{h['gen']} WR={h['wr']:.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                                            except Exception:&#10;                                                pass&#10;                                append_log(line)&#10;        # Shared state&#10;                # Load current champion from file at run start (so weights carry over)&#10;                try:&#10;                    weights_path = Path('Models') / 'weights.json'&#10;                    if weights_path.exists():&#10;                        with open(weights_path,'r',encoding='utf-8') as f:&#10;                            data = json.load(f)&#10;                        if isinstance(data, dict):&#10;                            state['champion'] = data&#10;                except Exception:&#10;                    pass&#10;        state = {&#10;            'current_gen': 0,&#10;            'champion_wr': 0.5,&#10;            'champion': {},&#10;        lock = threading.Lock()&#10;                            last_error_ts = now&#10;                import time as _time&#10;                _time.sleep(0.5)&#10;&#10;        def start_monitor():&#10;            if state.get('monitor_active'):&#10;                return&#10;            state['stop'] = False&#10;            monitor_thread = threading.Thread(target=monitor_log, daemon=True)&#10;            monitor_thread.start()&#10;&#10;        # Removed automatic monitor start to avoid appearing to auto-run tuner&#10;        # build initial history from any existing log without attaching live monitor yet&#10;        build_history_from_log()&#10;&#10;        # Implement reload champion button&#10;        def reload_champion():&#10;            try:&#10;                weights_path = Path('Models') / 'weights.json'&#10;                if weights_path.exists():&#10;                    with open(weights_path,'r',encoding='utf-8') as f:&#10;                        data = json.load(f)&#10;                    if isinstance(data, dict):&#10;                        with lock:&#10;                            state['champion'] = data&#10;                        append_log('[reload] loaded champion weights from Models/weights.json')&#10;                else:&#10;                    append_log('[reload] Models/weights.json not found')&#10;            except Exception as e:&#10;                append_log(f'[reload-error] {e}')&#10;        reload_btn.configure(command=reload_champion)&#10;&#10;        # Shared state&#10;                # Load current champion from file at run start (so weights carry over)&#10;                try:&#10;                    weights_path = Path('Models') / 'weights.json'&#10;                    if weights_path.exists():&#10;                        with open(weights_path,'r',encoding='utf-8') as f:&#10;                            data = json.load(f)&#10;                        if isinstance(data, dict):&#10;                            state['champion'] = data&#10;                except Exception:&#10;                    pass&#10;            'candidates': [],  # list of dicts&#10;                log_box.delete('1.0', tk.END)&#10;            except Exception:&#10;                pass&#10;        lock = threading.Lock()&#10;&#10;        # ---------------- Generation variable trace for progress bar ----------------&#10;        def _on_gen_change(*_):&#10;            try: gen_progress.configure(maximum=int(gen_var.get()))&#10;            except Exception: pass&#10;        gen_var.trace_add('write', _on_gen_change)&#10;&#10;        # Modify start_run to include new CLI flags and clear previous run state&#10;        def start_run():&#10;            if state.get('run_proc') is not None:&#10;                append_log('[warn] tuner already running')&#10;                return&#10;            # Start monitor thread now (first time user actually runs tuner)&#10;            start_monitor()&#10;            if reset_hist_var.get():&#10;                # rotate log &amp; clear history list for fresh run&#10;                try:&#10;                    log_path = state['log_path']&#10;                    if log_path.exists():&#10;                        bak = log_path.with_name(f&quot;weight_tuning.jsonl.bak.{int(time.time())}&quot;)&#10;                        log_path.replace(bak)&#10;                        append_log(f&quot;[reset] previous log rotated to {bak.name}&quot;)&#10;                except Exception as e:&#10;                    append_log(f&quot;[reset] log rotate failed: {e}&quot;)&#10;                with lock:&#10;                    state['history'].clear(); state['selected_history']=None&#10;                try:&#10;                    history_list.delete(0, tk.END)&#10;                except Exception:&#10;                    pass&#10;            # Clear UI / state for fresh run&#10;            with lock:&#10;                state['current_gen']=0; state['candidates'].clear(); state['champion_wr']=0.5; state['champion_wr_at_gen_start']=0.5; state['sigma']=None; state['selected_history']=None&#10;                # Load current champion from file at run start (so weights carry over)&#10;                try:&#10;                    weights_path = Path('Models') / 'weights.json'&#10;                    if weights_path.exists():&#10;                        with open(weights_path,'r',encoding='utf-8') as f:&#10;                            data = json.load(f)&#10;                        if isinstance(data, dict):&#10;                            state['champion'] = data&#10;                except Exception:&#10;                    pass&#10;            try:&#10;                log_box.delete('1.0', tk.END)&#10;            except Exception:&#10;                pass&#10;            fmt = fmt_var.get().strip() or 'gen9randombattle'&#10;            pop = max(2, int(pop_var.get()))&#10;            gens = max(1, int(gen_var.get()))&#10;            seeds = max(2, int(seeds_var.get()))&#10;            sigma = float(sigma_var.get())&#10;            promote_delta = float(promote_diff_var.get())&#10;            patience = max(1, int(patience_var.get()))&#10;            args = [sys.executable, str(Path(__file__).resolve().parent.parent / 'tools' / 'weight_tuner.py'), '--format', fmt, '--population', str(pop), '--generations', str(gens), '--seeds', str(seeds), '--sigma', f&quot;{sigma}&quot;, '--min-promote-diff', f&quot;{promote_delta}&quot;, '--patience', str(patience)]&#10;            if online_var.get():&#10;                args.append('--online')&#10;            append_log('[run] ' + ' '.join(args))&#10;            status_var.set('Running')&#10;            def worker():&#10;                import subprocess&#10;                try:&#10;                    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)&#10;                    state['run_proc'] = proc&#10;                    for line in proc.stdout:  # type: ignore&#10;                        append_log(line.rstrip())&#10;                    proc.wait()&#10;                    code = proc.returncode&#10;                    if code == 0:&#10;                        append_log('[done] tuner finished.')&#10;                        status_var.set('Finished')&#10;                    else:&#10;                        append_log(f'[error] exit code {code}')&#10;                        status_var.set(f'Error {code}')&#10;                except Exception as e:&#10;                    append_log(f'[error] {e}')&#10;                    status_var.set('Error')&#10;                finally:&#10;                    state['run_proc'] = None&#10;            threading.Thread(target=worker, daemon=True).start()&#10;        start_btn.configure(command=start_run)&#10;&#10;        # Implement stop button&#10;        def stop_run():&#10;            proc = state.get('run_proc')&#10;            if not proc:&#10;                append_log('[info] no active run to stop')&#10;                return&#10;            try:&#10;                proc.terminate()&#10;                append_log('[stop] sent terminate to tuner process')&#10;                status_var.set('Stopping...')&#10;            except Exception as e:&#10;                append_log(f'[error] stop failed: {e}')&#10;        stop_btn.configure(command=stop_run)&#10;&#10;        def on_close_dialog():&#10;            state['stop'] = True&#10;            dlg.destroy()&#10;        dlg.protocol('WM_DELETE_WINDOW', on_close_dialog)&#10;&#10;        # Kick off UI refresh loop&#10;        refresh_ui()&#10;&#10;    def _on_close(self):&#10;        self._save_settings()&#10;        try: self.destroy()&#10;        except Exception: pass&#10;&#10;    def run(self):&#10;        self.mainloop()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    MainMenu().run()&#10;" />
              <option name="updatedContent" value="# UI/tk_main_menu.py&#10;&quot;&quot;&quot;&#10;Simple launcher for Stockfish model with Tkinter.&#10;&#10;- Lets the user enter Showdown credentials, pick server and format.&#10;- Launches the Stockfish window.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;&#10;# --- injected by fix_type_effectiveness.py (safe no-op if repeated) ---&#10;try:&#10;    from utils.type_effectiveness import install_logging_hook, init_typecalc&#10;    from pathlib import Path&#10;    import os&#10;    install_logging_hook()&#10;    # Dynamic showdown data dir discovery&#10;    _root = Path(__file__).resolve().parent.parent&#10;    _cands = [&#10;        Path(os.getenv('POKECHAD_SHOWDOWN_DIR', '')),&#10;        _root / 'tools' / 'Data' / 'showdown',&#10;        _root / 'showdown',&#10;        _root / 'tools' / 'showdown',&#10;        _root / 'Resources' / 'showdown',&#10;    ]&#10;    _chosen = None&#10;    for _c in _cands:&#10;        if _c and ( (_c / 'moves.json').exists() or (_c / 'pokedex.json').exists() ):&#10;            _chosen = _c; break&#10;    if _chosen is None:&#10;        _chosen = _cands[1]&#10;    init_typecalc(_chosen)&#10;except Exception as _typecalc_e:&#10;    import logging&#10;    logging.getLogger('typecalc').warning('Could not install typecalc logging: %s', _typecalc_e)&#10;# --- end injection ---&#10;import os&#10;import sys&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox&#10;import json&#10;from pathlib import Path&#10;import time&#10;import threading&#10;&#10;from UI.tk_stockfish_model_ui import launch_stockfish_window, KNOWN_FORMATS  # type: ignore&#10;&#10;class MainMenu(tk.Tk):&#10;    CONFIG_PATH = Path.home() / '.pokechad_ui_settings.json'&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.title(&quot;PokeCHAD — Main Menu&quot;)&#10;        self.geometry(&quot;520x320&quot;)&#10;        self._loaded_settings = self._load_settings()&#10;        self.protocol(&quot;WM_DELETE_WINDOW&quot;, self._on_close)&#10;        self._build(self._loaded_settings)&#10;&#10;    def _load_settings(self) -&gt; dict:&#10;        try:&#10;            if self.CONFIG_PATH.exists():&#10;                with open(self.CONFIG_PATH, 'r', encoding='utf-8') as f:&#10;                    data = json.load(f)&#10;                if isinstance(data, dict):&#10;                    return data&#10;        except Exception:&#10;            pass&#10;        return {}&#10;&#10;    def _save_settings(self):&#10;        try:&#10;            data = {&#10;                'username': self.username.get().strip() if hasattr(self, 'username') else None,&#10;                'password': self.password.get() if hasattr(self, 'password') else None,&#10;                'server_mode': self.server_mode.get() if hasattr(self, 'server_mode') else None,&#10;                'custom_ws': self.custom_ws.get().strip() if hasattr(self, 'custom_ws') else None,&#10;                'format': self.format_var.get().strip() if hasattr(self, 'format_var') else None,&#10;            }&#10;            with open(self.CONFIG_PATH, 'w', encoding='utf-8') as f:&#10;                json.dump(data, f, indent=2)&#10;        except Exception:&#10;            pass&#10;&#10;    def _build(self, settings: dict):&#10;        frame = ttk.Frame(self)&#10;        frame.pack(fill=tk.BOTH, expand=True, padx=14, pady=14)&#10;&#10;        ttk.Label(frame, text=&quot;Username&quot;).grid(row=0, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.username = tk.StringVar(value=settings.get('username') or os.environ.get(&quot;PS_USERNAME&quot;, &quot;Containedo3mini&quot;))&#10;        ttk.Entry(frame, textvariable=self.username, width=28).grid(row=0, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Password (optional)&quot;).grid(row=1, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.password = tk.StringVar(value=settings.get('password') or os.environ.get(&quot;PS_PASSWORD&quot;, &quot;&quot;))&#10;        ttk.Entry(frame, textvariable=self.password, width=28, show=&quot;*&quot;).grid(row=1, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Server&quot;).grid(row=2, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.server_mode = tk.StringVar(value=settings.get('server_mode') or &quot;Showdown&quot;)&#10;        ttk.Combobox(frame, textvariable=self.server_mode, values=[&quot;Showdown&quot;, &quot;Localhost&quot;], width=24, state=&quot;readonly&quot;).grid(row=2, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Custom WS URL&quot;).grid(row=3, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.custom_ws = tk.StringVar(value=settings.get('custom_ws') or &quot;&quot;)&#10;        ttk.Entry(frame, textvariable=self.custom_ws, width=28).grid(row=3, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        ttk.Label(frame, text=&quot;Format&quot;).grid(row=4, column=0, sticky=&quot;e&quot;, padx=6, pady=6)&#10;        self.format_var = tk.StringVar(value=settings.get('format') or &quot;gen9randombattle&quot;)&#10;        ttk.Combobox(frame, textvariable=self.format_var, values=KNOWN_FORMATS, width=24, state=&quot;readonly&quot;).grid(row=4, column=1, sticky=&quot;w&quot;, padx=6, pady=6)&#10;&#10;        def go():&#10;            self._save_settings()&#10;            launch_stockfish_window(self, username=self.username.get().strip(),&#10;                                    password=(self.password.get().strip() or None),&#10;                                    server_mode=self.server_mode.get(),&#10;                                    custom_ws=(self.custom_ws.get().strip() or None),&#10;                                    battle_format=self.format_var.get().strip())&#10;&#10;        ttk.Button(frame, text=&quot;Launch Stockfish Model&quot;, command=go).grid(row=5, column=0, columnspan=2, pady=(18,4))&#10;&#10;        # Weight tuner button&#10;        ttk.Button(frame, text=&quot;Run Weight Tuner&quot;, command=self._open_tuner_dialog).grid(row=6, column=0, columnspan=2, pady=(6,8))&#10;&#10;    # --- Weight Tuner Dialog ---&#10;    def _open_tuner_dialog(self):&#10;        dlg = tk.Toplevel(self); dlg.title(&quot;Weight Tuner&quot;)&#10;        dlg.geometry(&quot;960x560&quot;)  # widen a bit more for extra controls&#10;&#10;        # Params frame&#10;        params = ttk.LabelFrame(dlg, text='Parameters'); params.grid(row=0, column=0, columnspan=3, sticky='ew', padx=6, pady=6)&#10;        for i in range(16): params.columnconfigure(i, weight=0)  # extended to include new columns&#10;        ttk.Label(params, text=&quot;Format&quot;).grid(row=0, column=0, sticky='e', padx=4, pady=4)&#10;        fmt_var = tk.StringVar(value=self.format_var.get())&#10;        ttk.Combobox(params, textvariable=fmt_var, values=KNOWN_FORMATS, width=22, state='readonly').grid(row=0, column=1, sticky='w', padx=4, pady=4)&#10;        def _intvar(default): return tk.IntVar(value=default)&#10;        def _dblvar(default): return tk.DoubleVar(value=default)&#10;        pop_var = _intvar(16); gen_var = _intvar(10); seeds_var = _intvar(16)&#10;        sigma_var = _dblvar(1.0); promote_diff_var = _dblvar(0.02); patience_var = _intvar(10)&#10;        online_var = tk.BooleanVar(value=False)&#10;        ttk.Label(params, text=&quot;Population&quot;).grid(row=0, column=2, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=pop_var, width=6).grid(row=0, column=3, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Generations&quot;).grid(row=0, column=4, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=gen_var, width=6).grid(row=0, column=5, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Seeds&quot;).grid(row=0, column=6, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=seeds_var, width=6).grid(row=0, column=7, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Sigma&quot;).grid(row=0, column=8, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=sigma_var, width=6).grid(row=0, column=9, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;PromoteΔ&quot;).grid(row=0, column=10, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=promote_diff_var, width=6).grid(row=0, column=11, sticky='w', padx=2, pady=4)&#10;        ttk.Label(params, text=&quot;Patience&quot;).grid(row=0, column=12, sticky='e', padx=4, pady=4)&#10;        ttk.Entry(params, textvariable=patience_var, width=6).grid(row=0, column=13, sticky='w', padx=2, pady=4)&#10;        ttk.Checkbutton(params, text=&quot;Online&quot;, variable=online_var).grid(row=0, column=14, sticky='w', padx=8, pady=4)&#10;        reset_hist_var = tk.BooleanVar(value=True)&#10;        ttk.Checkbutton(params, text=&quot;ResetHist&quot;, variable=reset_hist_var).grid(row=0, column=15, sticky='w', padx=4, pady=4)&#10;        prime_var = tk.BooleanVar(value=True)&#10;        # add prime baseline on next row to keep layout tidy&#10;        ttk.Checkbutton(params, text=&quot;Prime baseline from latest champion&quot;, variable=prime_var).grid(row=1, column=0, columnspan=6, sticky='w', padx=8, pady=(0,4))&#10;&#10;        # Progress bar + status&#10;        prog_frame = ttk.Frame(dlg); prog_frame.grid(row=1, column=0, columnspan=3, sticky='ew', padx=6, pady=(0,6))&#10;        ttk.Label(prog_frame, text='Generation Progress:').pack(side=tk.LEFT, padx=(0,6))&#10;        gen_progress = ttk.Progressbar(prog_frame, orient='horizontal', mode='determinate', maximum=gen_var.get())&#10;        gen_progress.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0,6))&#10;        status_var = tk.StringVar(value='Idle')&#10;        ttk.Label(prog_frame, textvariable=status_var).pack(side=tk.LEFT)&#10;&#10;        # Candidates tree&#10;        cand_frame = ttk.LabelFrame(dlg, text='Current Generation Candidates')&#10;        cand_frame.grid(row=2, column=0, sticky='nsew', padx=6, pady=6)&#10;        dlg.rowconfigure(2, weight=1)&#10;        columns = ('idx','wr','wins','games','diff','sigma')&#10;        cand_tree = ttk.Treeview(cand_frame, columns=columns, show='headings', height=10)&#10;        headers = {'idx':'IDX','wr':'WR','wins':'W','games':'G','diff':'ΔChampion','sigma':'σ'}&#10;        widths = {'idx':40,'wr':60,'wins':50,'games':50,'diff':90,'sigma':60}&#10;        for c in columns:&#10;            cand_tree.heading(c, text=headers.get(c,c))&#10;            cand_tree.column(c, width=widths.get(c,80), anchor=tk.CENTER)&#10;        cand_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        cand_scroll = ttk.Scrollbar(cand_frame, orient='vertical', command=cand_tree.yview)&#10;        cand_scroll.pack(side=tk.RIGHT, fill=tk.Y)&#10;        cand_tree.configure(yscrollcommand=cand_scroll.set)&#10;&#10;        # Champion weights&#10;        champ_frame = ttk.LabelFrame(dlg, text='Champion Weights')&#10;        champ_frame.grid(row=2, column=1, sticky='nsew', padx=6, pady=6)&#10;        dlg.rowconfigure(2, weight=1)&#10;        champ_text = tk.Text(champ_frame, height=14, width=34)&#10;        champ_text.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;&#10;        # History panel&#10;        history_frame = ttk.LabelFrame(dlg, text='Champion History')&#10;        history_frame.grid(row=2, column=2, rowspan=2, sticky='nsew', padx=6, pady=6)&#10;        dlg.columnconfigure(2, weight=1)&#10;        history_list = tk.Listbox(history_frame, height=16)&#10;        history_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(4,0), pady=4)&#10;        hist_scroll = ttk.Scrollbar(history_frame, orient='vertical', command=history_list.yview)&#10;        hist_scroll.pack(side=tk.RIGHT, fill=tk.Y)&#10;        history_list.configure(yscrollcommand=hist_scroll.set)&#10;        hist_btn_frame = ttk.Frame(history_frame); hist_btn_frame.pack(fill=tk.X, padx=4, pady=(0,4))&#10;        refresh_hist_btn = ttk.Button(hist_btn_frame, text='Refresh History')&#10;        refresh_hist_btn.pack(side=tk.LEFT, padx=(0,4))&#10;        export_hist_btn = ttk.Button(hist_btn_frame, text='Export Selected')&#10;        export_hist_btn.pack(side=tk.LEFT, padx=(0,4))&#10;        load_hist_btn = ttk.Button(hist_btn_frame, text='Load Selected')&#10;        load_hist_btn.pack(side=tk.LEFT, padx=(0,4))&#10;        use_latest_btn = ttk.Button(hist_btn_frame, text='Use Latest Champion')&#10;        use_latest_btn.pack(side=tk.RIGHT)&#10;&#10;        # Adjust placement of log frame (row 3 instead of 4 to accommodate resized layout)&#10;        # Log box&#10;        log_frame = ttk.LabelFrame(dlg, text='Raw Log')&#10;        log_frame.grid(row=3, column=0, columnspan=3, sticky='nsew', padx=6, pady=6)&#10;        dlg.rowconfigure(3, weight=1)&#10;        log_box = tk.Text(log_frame, height=8)&#10;        log_box.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;&#10;        # Control buttons (add Stop button)&#10;        btn_frame = ttk.Frame(dlg); btn_frame.grid(row=5, column=0, columnspan=3, sticky='ew', padx=6, pady=(0,6))&#10;        start_btn = ttk.Button(btn_frame, text='Start')&#10;        start_btn.pack(side=tk.LEFT, padx=(0,6))&#10;        stop_btn = ttk.Button(btn_frame, text='Stop')&#10;        stop_btn.pack(side=tk.LEFT, padx=(0,6))&#10;        close_btn = ttk.Button(btn_frame, text='Close', command=dlg.destroy)&#10;        close_btn.pack(side=tk.LEFT)&#10;        reload_btn = ttk.Button(btn_frame, text='Reload champion from file')&#10;        reload_btn.pack(side=tk.RIGHT)&#10;&#10;        # Shared state&#10;        state = {&#10;            'current_gen': 0,&#10;            'champion_wr': 0.5,&#10;            'champion': {},&#10;            'sigma': None,&#10;            'candidates': [],  # list of dicts&#10;            'champion_wr_at_gen_start': 0.5,&#10;            'stop': False,&#10;            'log_pos': 0,&#10;            'log_path': Path('logs')/ 'weight_tuning.jsonl',&#10;            'run_proc': None,&#10;            'expected_generations': lambda: gen_var.get(),&#10;            'history': [],  # list of dicts {gen, wr, time, weights, sigma}&#10;            'selected_history': None,&#10;            'monitor_active': False,&#10;            'param_refs': {&#10;                'population': pop_var,&#10;                'generations': gen_var,&#10;                'seeds': seeds_var,&#10;                'sigma': sigma_var,&#10;                'promote_diff': promote_diff_var,&#10;                'patience': patience_var,&#10;                'online': online_var,&#10;                'reset_hist': reset_hist_var,&#10;            }&#10;        }&#10;        lock = threading.Lock()&#10;&#10;        # Logging helper&#10;        def append_log(msg: str):&#10;            try:&#10;                log_box.insert(tk.END, msg + '\n'); log_box.see(tk.END)&#10;            except Exception:&#10;                pass&#10;&#10;        # Periodic UI refresh&#10;        def refresh_ui():&#10;            if state['stop'] or not dlg.winfo_exists():&#10;                return&#10;            with lock:&#10;                try:&#10;                    gen_progress.configure(maximum=state['expected_generations']())&#10;                    gen_progress['value'] = state['current_gen']&#10;                except Exception:&#10;                    pass&#10;                # Status&#10;                try:&#10;                    sigma_val = state.get('sigma')&#10;                    sigma_str = '?' if sigma_val is None else f&quot;{float(sigma_val):.3f}&quot;&#10;                    status_var.set(f&quot;Gen {state['current_gen']} σ={sigma_str}&quot;)&#10;                except Exception:&#10;                    status_var.set(f&quot;Gen {state['current_gen']} σ=?&quot;)&#10;                # Candidates tree&#10;                try:&#10;                    for iid in cand_tree.get_children():&#10;                        cand_tree.delete(iid)&#10;                    base_wr = state.get('champion_wr_at_gen_start', 0.5) or 0.0&#10;                    for c in sorted(state['candidates'], key=lambda d: d.get('win_rate',0) or 0, reverse=True):&#10;                        diff = (c.get('win_rate',0) or 0) - base_wr&#10;                        cand_tree.insert('', tk.END, values=(c.get('idx'), f&quot;{(c.get('win_rate',0) or 0):.3f}&quot;, c.get('wins'), c.get('games'), f&quot;{diff:.3f}&quot;, f&quot;{(c.get('sigma',0) or 0):.2f}&quot;))&#10;                except Exception:&#10;                    pass&#10;                # Champion weights text&#10;                try:&#10;                    champ_text.delete('1.0', tk.END)&#10;                    src_weights = state['selected_history']['weights'] if state.get('selected_history') else state['champion']&#10;                    for k, v in sorted((src_weights or {}).items()):&#10;                        champ_text.insert(tk.END, f&quot;{k}: {float(v):.3f}\n&quot;)&#10;                except Exception:&#10;                    pass&#10;            dlg.after(1000, refresh_ui)&#10;&#10;        # Build history from log file and populate list&#10;        def build_history_from_log():&#10;            path = state['log_path']&#10;            hist = []&#10;            init_seen = False&#10;            if path.exists():&#10;                try:&#10;                    with open(path,'r',encoding='utf-8') as f:&#10;                        for line in f:&#10;                            if not line.strip():&#10;                                continue&#10;                            try:&#10;                                evt = json.loads(line)&#10;                            except Exception:&#10;                                continue&#10;                            et = evt.get('event')&#10;                            if et == 'init' and not init_seen:&#10;                                hist.append({'gen': 0, 'wr': 0.5, 'sigma': evt.get('sigma'), 'weights': evt.get('champion') or {}, 'time': None})&#10;                                init_seen = True&#10;                            elif et == 'promote':&#10;                                hist.append({'gen': evt.get('generation'), 'wr': evt.get('champion_wr'), 'sigma': evt.get('sigma'), 'weights': evt.get('new_champion') or {}, 'time': evt.get('gen_seconds')})&#10;                            elif et == 'done':&#10;                                hist.append({'gen': evt.get('generations'), 'wr': evt.get('champion_wr'), 'sigma': None, 'weights': evt.get('final_champion') or {}, 'time': None})&#10;                except Exception:&#10;                    pass&#10;            # de-dup keep last per gen&#10;            dedup = {}&#10;            for h in hist:&#10;                dedup[h['gen']] = h&#10;            out = list(sorted(dedup.values(), key=lambda d: d['gen']))&#10;            state['history'] = out&#10;            history_list.delete(0, tk.END)&#10;            for h in out:&#10;                try:&#10;                    history_list.insert(tk.END, f&quot;G{h['gen']} WR={float(h['wr'] or 0):.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                except Exception:&#10;                    pass&#10;            if out and not state.get('champion') and out[0].get('gen') == 0:&#10;                state['champion'] = out[0].get('weights') or {}&#10;&#10;        def on_history_select(event=None):&#10;            try:&#10;                sel = history_list.curselection()&#10;                if not sel:&#10;                    state['selected_history'] = None; return&#10;                idx = sel[0]&#10;                if 0 &lt;= idx &lt; len(state['history']):&#10;                    state['selected_history'] = state['history'][idx]&#10;            except Exception:&#10;                state['selected_history'] = None&#10;        history_list.bind('&lt;&lt;ListboxSelect&gt;&gt;', on_history_select)&#10;&#10;        def export_selected():&#10;            h = state.get('selected_history')&#10;            if not h:&#10;                append_log('[warn] no history selection to export'); return&#10;            weights = h.get('weights') or {}&#10;            if not weights:&#10;                append_log('[warn] selected history has no weights'); return&#10;            try:&#10;                models_dir = Path('Models'); models_dir.mkdir(exist_ok=True)&#10;                target = models_dir / 'weights.json'&#10;                if target.exists():&#10;                    backup = target.with_name(f&quot;weights.json.bak.{int(time.time())}&quot;)&#10;                    try: target.replace(backup)&#10;                    except Exception: pass&#10;                with open(target,'w',encoding='utf-8') as f:&#10;                    json.dump(weights, f, indent=2)&#10;                append_log('[export] wrote selected champion to Models/weights.json')&#10;            except Exception as e:&#10;                append_log(f'[error] export failed: {e}')&#10;        refresh_hist_btn.configure(command=build_history_from_log)&#10;        export_hist_btn.configure(command=export_selected)&#10;        def load_selected():&#10;            h = state.get('selected_history')&#10;            if not h:&#10;                append_log('[warn] no history selection to load'); return&#10;            state['champion'] = h.get('weights') or state['champion']&#10;            append_log(f&quot;[load] loaded history G{h.get('gen')} into champion view (not saved yet)&quot;)&#10;        load_hist_btn.configure(command=load_selected)&#10;&#10;        # Monitoring thread: tail logs/weight_tuning.jsonl and update UI state&#10;        def monitor_log():&#10;            last_size = 0&#10;            last_error_ts = 0.0&#10;            state['monitor_active'] = True&#10;            while not state['stop']:&#10;                path = state['log_path']&#10;                if path.exists():&#10;                    try:&#10;                        cur_size = path.stat().st_size&#10;                        if cur_size &lt; last_size:&#10;                            last_size = 0&#10;                        with open(path, 'r', encoding='utf-8') as f:&#10;                            if last_size:&#10;                                try:&#10;                                    f.seek(last_size)&#10;                                except Exception:&#10;                                    last_size = 0; f.seek(0)&#10;                            while True:&#10;                                line = f.readline()&#10;                                if not line:&#10;                                    break&#10;                                line = line.strip()&#10;                                try:&#10;                                    last_size = f.tell()&#10;                                except Exception:&#10;                                    pass&#10;                                if not line:&#10;                                    continue&#10;                                try:&#10;                                    evt = json.loads(line)&#10;                                except Exception:&#10;                                    append_log(line); continue&#10;                                et = evt.get('event')&#10;                                with lock:&#10;                                    if et == 'gen_start':&#10;                                        state['current_gen'] = int(evt.get('generation', state['current_gen']))&#10;                                        state['champion_wr'] = float(evt.get('champion_wr', state['champion_wr']))&#10;                                        state['champion_wr_at_gen_start'] = state['champion_wr']&#10;                                        state['champion'] = evt.get('champion') or state['champion']&#10;                                        state['sigma'] = evt.get('sigma', state.get('sigma'))&#10;                                        state['candidates'] = []&#10;                                    elif et == 'candidate':&#10;                                        state['candidates'].append({'idx': evt.get('idx'), 'win_rate': evt.get('win_rate'), 'wins': evt.get('wins'), 'games': evt.get('games'), 'sigma': evt.get('sigma')})&#10;                                    elif et == 'promote':&#10;                                        state['champion'] = evt.get('new_champion') or state['champion']&#10;                                        state['champion_wr'] = float(evt.get('champion_wr', state['champion_wr']))&#10;                                        state['sigma'] = evt.get('sigma', state.get('sigma'))&#10;                                        state['history'].append({'gen': evt.get('generation'), 'wr': evt.get('champion_wr'), 'sigma': evt.get('sigma'), 'weights': evt.get('new_champion') or {}, 'time': evt.get('gen_seconds')})&#10;                                    elif et == 'no_improve':&#10;                                        state['sigma'] = evt.get('sigma', state.get('sigma'))&#10;                                    elif et == 'init':&#10;                                        state['champion'] = evt.get('champion') or state['champion']&#10;                                        # add initial champion to history if missing gen 0&#10;                                        need_init = True&#10;                                        for h in state['history']:&#10;                                            if h.get('gen') == 0:&#10;                                                need_init = False; break&#10;                                        if need_init:&#10;                                            state['history'].append({'gen': 0, 'wr': 0.5, 'sigma': evt.get('sigma'), 'weights': evt.get('champion') or {}, 'time': None})&#10;                                    elif et == 'done':&#10;                                        state['current_gen'] = int(evt.get('generations', state['current_gen']))&#10;                                        final_gen = evt.get('generations')&#10;                                        final_entry = {&#10;                                            'gen': final_gen,&#10;                                            'wr': evt.get('champion_wr'),&#10;                                            'sigma': None,&#10;                                            'weights': evt.get('final_champion') or state.get('champion', {}),&#10;                                            'time': None,&#10;                                        }&#10;                                        already = any(h.get('gen') == final_gen for h in state['history'])&#10;                                        if not already:&#10;                                            state['history'].append(final_entry)&#10;                                    if et in ('promote','done','init'):&#10;                                        seen = {h['gen']: h for h in state['history']}&#10;                                        state['history'] = list(sorted(seen.values(), key=lambda d: d['gen']))&#10;                                        history_list.delete(0, tk.END)&#10;                                        for h in state['history']:&#10;                                            try:&#10;                                                history_list.insert(tk.END, f&quot;G{h['gen']} WR={h['wr']:.3f} σ={h['sigma'] if h['sigma'] is not None else '-'}&quot;)&#10;                                            except Exception:&#10;                                                pass&#10;                                append_log(line)&#10;                    except Exception as e:&#10;                        import time as _time&#10;                        now = _time.time()&#10;                        if now - last_error_ts &gt; 2.0:&#10;                            append_log(f&quot;[monitor-error] {e}&quot;)&#10;                            last_error_ts = now&#10;                import time as _time&#10;                _time.sleep(0.5)&#10;&#10;        def start_monitor():&#10;            if state.get('monitor_active'):&#10;                return&#10;            state['stop'] = False&#10;            threading.Thread(target=monitor_log, daemon=True).start()&#10;&#10;        # Configure reload button to reload current champion from file&#10;        def reload_champion():&#10;            try:&#10;                weights_path = Path('Models') / 'weights.json'&#10;                if weights_path.exists():&#10;                    with open(weights_path,'r',encoding='utf-8') as f:&#10;                        data = json.load(f)&#10;                    if isinstance(data, dict):&#10;                        with lock:&#10;                            state['champion'] = data&#10;                        append_log('[reload] loaded champion weights from Models/weights.json')&#10;                else:&#10;                    append_log('[reload] Models/weights.json not found')&#10;            except Exception as e:&#10;                append_log(f'[reload-error] {e}')&#10;        reload_btn.configure(command=reload_champion)&#10;&#10;        # Build initial history list from existing log (no monitor yet)&#10;        try:&#10;            build_history_from_log()&#10;        except Exception:&#10;            pass&#10;&#10;        # ---------------- Generation variable trace for progress bar ----------------&#10;        def _on_gen_change(*_):&#10;            try: gen_progress.configure(maximum=int(gen_var.get()))&#10;            except Exception: pass&#10;        gen_var.trace_add('write', _on_gen_change)&#10;&#10;        # Modify start_run to include new CLI flags and clear previous run state&#10;        def start_run():&#10;            if state.get('run_proc') is not None:&#10;                append_log('[warn] tuner already running')&#10;                return&#10;            # Start monitor thread now (first time user actually runs tuner)&#10;            start_monitor()&#10;            if reset_hist_var.get():&#10;                # rotate log &amp; clear history list for fresh run&#10;                try:&#10;                    log_path = state['log_path']&#10;                    if log_path.exists():&#10;                        bak = log_path.with_name(f&quot;weight_tuning.jsonl.bak.{int(time.time())}&quot;)&#10;                        log_path.replace(bak)&#10;                        append_log(f&quot;[reset] previous log rotated to {bak.name}&quot;)&#10;                except Exception as e:&#10;                    append_log(f&quot;[reset] log rotate failed: {e}&quot;)&#10;                with lock:&#10;                    state['history'].clear(); state['selected_history']=None&#10;                try:&#10;                    history_list.delete(0, tk.END)&#10;                except Exception:&#10;                    pass&#10;            # Clear UI / state for fresh run&#10;            with lock:&#10;                state['current_gen']=0; state['candidates'].clear(); state['champion_wr']=0.5; state['champion_wr_at_gen_start']=0.5; state['sigma']=None; state['selected_history']=None&#10;            try:&#10;                log_box.delete('1.0', tk.END)&#10;            except Exception:&#10;                pass&#10;            # Optionally prime baseline by writing latest champion to Models/weights.json&#10;            try:&#10;                if prime_var.get():&#10;                    hist = state.get('history') or []&#10;                    if hist:&#10;                        latest = hist[-1]&#10;                        weights = latest.get('weights') or {}&#10;                        if weights:&#10;                            models_dir = Path('Models'); models_dir.mkdir(exist_ok=True)&#10;                            target = models_dir / 'weights.json'&#10;                            if target.exists():&#10;                                backup = target.with_name(f&quot;weights.json.bak.{int(time.time())}&quot;)&#10;                                try: target.replace(backup)&#10;                                except Exception: pass&#10;                            with open(target,'w',encoding='utf-8') as f:&#10;                                json.dump(weights, f, indent=2)&#10;                            append_log(f&quot;[prime] baseline set to latest champion (G{latest.get('gen')}) in Models/weights.json&quot;)&#10;                            with lock:&#10;                                state['champion'] = weights&#10;            except Exception as e:&#10;                append_log(f&quot;[prime-error] {e}&quot;)&#10;            # Read params and launch&#10;            fmt = fmt_var.get().strip() or 'gen9randombattle'&#10;            pop = max(2, int(pop_var.get()))&#10;            gens = max(1, int(gen_var.get()))&#10;            seeds = max(2, int(seeds_var.get()))&#10;            sigma = float(sigma_var.get())&#10;            promote_delta = float(promote_diff_var.get())&#10;            patience = max(1, int(patience_var.get()))&#10;            args = [sys.executable, str(Path(__file__).resolve().parent.parent / 'tools' / 'weight_tuner.py'), '--format', fmt, '--population', str(pop), '--generations', str(gens), '--seeds', str(seeds), '--sigma', f&quot;{sigma}&quot;, '--min-promote-diff', f&quot;{promote_delta}&quot;, '--patience', str(patience)]&#10;            if online_var.get():&#10;                args.append('--online')&#10;            append_log('[run] ' + ' '.join(args))&#10;            status_var.set('Running')&#10;            def worker():&#10;                import subprocess&#10;                try:&#10;                    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)&#10;                    state['run_proc'] = proc&#10;                    for line in proc.stdout:  # type: ignore&#10;                        append_log(line.rstrip())&#10;                    proc.wait()&#10;                    code = proc.returncode&#10;                    if code == 0:&#10;                        append_log('[done] tuner finished.')&#10;                        status_var.set('Finished')&#10;                    else:&#10;                        append_log(f'[error] exit code {code}')&#10;                        status_var.set(f'Error {code}')&#10;                except Exception as e:&#10;                    append_log(f'[error] {e}')&#10;                    status_var.set('Error')&#10;                finally:&#10;                    state['run_proc'] = None&#10;            threading.Thread(target=worker, daemon=True).start()&#10;        start_btn.configure(command=start_run)&#10;&#10;        # Implement stop button&#10;        def stop_run():&#10;            proc = state.get('run_proc')&#10;            if not proc:&#10;                append_log('[info] no active run to stop')&#10;                return&#10;            try:&#10;                proc.terminate()&#10;                append_log('[stop] sent terminate to tuner process')&#10;                status_var.set('Stopping...')&#10;            except Exception as e:&#10;                append_log(f'[error] stop failed: {e}')&#10;        stop_btn.configure(command=stop_run)&#10;&#10;        def on_close_dialog():&#10;            state['stop'] = True&#10;            dlg.destroy()&#10;        dlg.protocol('WM_DELETE_WINDOW', on_close_dialog)&#10;&#10;        # Kick off UI refresh loop&#10;        refresh_ui()&#10;&#10;    def _on_close(self):&#10;        self._save_settings()&#10;        try: self.destroy()&#10;        except Exception: pass&#10;&#10;    def run(self):&#10;        self.mainloop()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    MainMenu().run()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UI/tk_stockfish_model_ui.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/tk_stockfish_model_ui.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;&#10;import asyncio&#10;import json&#10;import logging&#10;import os&#10;import queue&#10;import subprocess&#10;import sys&#10;import threading&#10;from typing import Any, Dict, List, Optional&#10;    &quot;gen9doublesou&quot;,&#10;    &quot;vgc2025regh&quot;,&#10;]&#10;&#10;# --------------------------- Small helpers --------------------------------&#10;class QueueLogHandler(logging.Handler):&#10;    def __init__(self, q: &quot;queue.Queue[str]&quot;):&#10;        super().__init__()&#10;        self.q = q&#10;    def emit(self, record: logging.LogRecord):&#10;        try:&#10;            msg = self.format(record)&#10;            self.q.put_nowait(msg)&#10;        except Exception:&#10;            pass&#10;&#10;def pretty_boosts(boosts: Dict[str, int] | None) -&gt; str:&#10;    if not boosts:&#10;        return &quot;&quot;&#10;    ordered = [&quot;atk&quot;, &quot;def&quot;, &quot;spa&quot;, &quot;spd&quot;, &quot;spe&quot;, &quot;acc&quot;, &quot;evasion&quot;]&#10;    return &quot;, &quot;.join(f&quot;{k}+{v}&quot; if v &gt; 0 else f&quot;{k}{v}&quot; for k, v in ((k, boosts.get(k, 0)) for k in ordered) if v != 0)&#10;&#10;# --------------------------------- Window ---------------------------------&#10;class StockfishWindow(tk.Toplevel):&#10;    def __init__(self, parent: tk.Tk, username: str, password: Optional[str], server_mode: str,&#10;        super().__init__(parent)&#10;        self.geometry(&quot;1180x740&quot;)&#10;&#10;        self.custom_ws = custom_ws&#10;        os.makedirs(&quot;logs&quot;, exist_ok=True)&#10;        self.loop = asyncio.new_event_loop()&#10;        # Player&#10;        self.log_queue: &quot;queue.Queue[str]&quot; = queue.Queue()&#10;        # UI State&#10;        self._last_fallback_turn: Optional[int] = None&#10;        self._active_battle_id: Optional[str] = None&#10;&#10;        future = asyncio.run_coroutine_threadsafe(coro, self.loop)&#10;                self.after(100, handle_result)&#10;        self.after(100, handle_result)&#10;        return self.after(delay_ms, fn)&#10;&#10;        logs_tab = ttk.Frame(nb); nb.add(logs_tab, text=&quot;Logs&quot;)&#10;                    server = type(&quot;CustomServerConf&quot;, (tuple,), {})((self.custom_ws, ShowdownServerConfiguration[1]))&#10;            pass&#10;    async def _timer_all(self, on: bool):&#10;        if self.player:&#10;                cmd = [sys.executable, &quot;../tools/train_launcher.py&quot;]&#10;                fut = f&quot;{float(future):.2f}&quot; if future is not None else &quot;&quot;&#10;            for iid in tree.get_children():&#10;                    pass&#10;            except Exception: pass&#10;        self._scheduled_tasks.clear()&#10;" />
              <option name="updatedContent" value="from __future__ import annotations&#10;&#10;import asyncio&#10;import json&#10;import logging&#10;import os&#10;import queue&#10;import subprocess&#10;import sys&#10;import threading&#10;from typing import Any, Dict, List, Optional&#10;from pathlib import Path&#10;&#10;import tkinter as tk&#10;from tkinter import ttk, messagebox&#10;&#10;# Ensure repo root is on sys.path so `Data` and `Models` can be imported&#10;_HERE = os.path.dirname(__file__)&#10;_ROOT = os.path.abspath(os.path.join(_HERE, os.pardir))&#10;if _ROOT not in sys.path:&#10;    sys.path.insert(0, _ROOT)&#10;&#10;# -- Optional runtime patch to the model (accept on_think, set engine_depth, robust forfeit)&#10;try:&#10;    from UI.ui_think_patch import patch_stockfish_player  # noqa: F401&#10;except Exception:  # patch file might not be present yet&#10;    patch_stockfish_player = None  # type: ignore&#10;&#10;from Models.stockfish_model import StockfishPokeEnvPlayer  # type: ignore&#10;from Data.poke_env_battle_environment import snapshot as snapshot_battle  # type: ignore&#10;from poke_env.ps_client.account_configuration import AccountConfiguration  # type: ignore&#10;from poke_env.ps_client.server_configuration import (  # type: ignore&#10;    ShowdownServerConfiguration,&#10;    LocalhostServerConfiguration,&#10;)&#10;&#10;# ----------------------- Formats dropdown ---------------------------------&#10;KNOWN_FORMATS = [&#10;    &quot;gen9randombattle&quot;,&#10;    &quot;gen9unratedrandombattle&quot;,&#10;    &quot;gen9randomdoublesbattle&quot;,&#10;    &quot;gen9hackmonscup&quot;,&#10;    &quot;gen9ou&quot;, &quot;gen9ubers&quot;, &quot;gen9uu&quot;, &quot;gen9ru&quot;, &quot;gen9nu&quot;, &quot;gen9pu&quot;, &quot;gen9lc&quot;, &quot;gen9monotype&quot;,&#10;    &quot;gen9doublesou&quot;,&#10;    &quot;vgc2025regh&quot;,&#10;]&#10;&#10;# --------------------------- Small helpers --------------------------------&#10;class QueueLogHandler(logging.Handler):&#10;    def __init__(self, q: &quot;queue.Queue[str]&quot;):&#10;        super().__init__()&#10;        self.q = q&#10;    def emit(self, record: logging.LogRecord):&#10;        try:&#10;            msg = self.format(record)&#10;            self.q.put_nowait(msg)&#10;        except Exception:&#10;            pass&#10;&#10;def pretty_boosts(boosts: Dict[str, int] | None) -&gt; str:&#10;    if not boosts:&#10;        return &quot;&quot;&#10;    ordered = [&quot;atk&quot;, &quot;def&quot;, &quot;spa&quot;, &quot;spd&quot;, &quot;spe&quot;, &quot;acc&quot;, &quot;evasion&quot;]&#10;    return &quot;, &quot;.join(f&quot;{k}+{v}&quot; if v &gt; 0 else f&quot;{k}{v}&quot; for k, v in ((k, boosts.get(k, 0)) for k in ordered) if v != 0)&#10;&#10;# --------------------------------- Window ---------------------------------&#10;class StockfishWindow(tk.Toplevel):&#10;    CONFIG_PATH = Path.home() / '.pokechad_ui_settings.json'&#10;    def __init__(self, parent: tk.Tk, username: str, password: Optional[str], server_mode: str,&#10;                 custom_ws: Optional[str], battle_format: str):&#10;        super().__init__(parent)&#10;        self.title(&quot;PokeCHAD — Stockfish Model&quot;)&#10;        self.geometry(&quot;1180x740&quot;)&#10;        self.protocol(&quot;WM_DELETE_WINDOW&quot;, self._on_close)&#10;        # Load persisted prefs early&#10;        self._prefs = self._load_prefs()&#10;&#10;        self.username = username&#10;        self.password = password&#10;        self.server_mode = server_mode&#10;        self.custom_ws = custom_ws&#10;        self.battle_format = battle_format or self._prefs.get('stockfish_ui', {}).get('format') or battle_format&#10;&#10;        # Telemetry file&#10;        os.makedirs(&quot;logs&quot;, exist_ok=True)&#10;        self._telemetry_path = os.path.join(&quot;logs&quot;, f&quot;telemetry_{os.getpid()}.jsonl&quot;)&#10;&#10;        # Async loop thread&#10;        self.loop = asyncio.new_event_loop()&#10;        self._loop_thread = threading.Thread(target=self.loop.run_forever, daemon=True)&#10;        self._loop_thread.start()&#10;&#10;        # Player&#10;        self.player: Optional[StockfishPokeEnvPlayer] = None&#10;&#10;        # Logging pane &amp; handler&#10;        self.log_queue: &quot;queue.Queue[str]&quot; = queue.Queue()&#10;        self.log_handler = QueueLogHandler(self.log_queue)&#10;        self.log_handler.setFormatter(logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;))&#10;&#10;        # UI State&#10;        self._scheduled_tasks: List[str] = []&#10;        self._latest_think: Dict[str, Any] = {}&#10;        self._latest_snapshot: Dict[str, Any] = {}&#10;        self._last_fallback_turn: Optional[int] = None&#10;        self._last_real_think_turn: Optional[int] = None&#10;        self._root_log_handler_attached = False&#10;        self._finished_battles: set[str] = set()&#10;        self._active_battle_id: Optional[str] = None&#10;&#10;        self._build_ui()&#10;        self._apply_loaded_prefs()  # set widget values from prefs after UI built&#10;        self._pump_logs()&#10;&#10;        # Bootstrap: connect immediately&#10;        self._submit(self._async_connect())&#10;&#10;    def _submit(self, coro: &quot;asyncio.coroutines.Coroutine[Any, Any, Any]&quot;):&#10;        future = asyncio.run_coroutine_threadsafe(coro, self.loop)&#10;        def handle_result():&#10;            try:&#10;                future.result(timeout=0.1)&#10;            except asyncio.TimeoutError:&#10;                self.after(100, handle_result)&#10;            except Exception as e:&#10;                error_msg = f&quot;Action failed: {e}&quot;&#10;                self._append_log(error_msg)&#10;                messagebox.showerror(&quot;Error&quot;, error_msg)&#10;        self.after(100, handle_result)&#10;&#10;    def _call_on_main(self, fn, delay_ms: int = 0):&#10;        if delay_ms &lt;= 0:&#10;            return self.after(0, fn)&#10;        return self.after(delay_ms, fn)&#10;&#10;    # ---------- UI construction ----------&#10;    def _load_prefs(self) -&gt; dict:&#10;        try:&#10;            if self.CONFIG_PATH.exists():&#10;                with open(self.CONFIG_PATH, 'r', encoding='utf-8') as f:&#10;                    data = json.load(f)&#10;                if isinstance(data, dict):&#10;                    return data&#10;        except Exception:&#10;            pass&#10;        return {}&#10;&#10;    def _save_prefs(self):&#10;        try:&#10;            base = {}&#10;            if self.CONFIG_PATH.exists():&#10;                try:&#10;                    with open(self.CONFIG_PATH, 'r', encoding='utf-8') as f:&#10;                        base = json.load(f) or {}&#10;                        if not isinstance(base, dict):&#10;                            base = {}&#10;                except Exception:&#10;                    base = {}&#10;            ui = base.get('stockfish_ui', {}) if isinstance(base.get('stockfish_ui'), dict) else {}&#10;            ui.update({&#10;                'depth': int(self.depth_var.get()) if hasattr(self, 'depth_var') else None,&#10;                'branching': int(self.branch_var.get()) if hasattr(self, 'branch_var') else None,&#10;                'softmin_temp': float(self.softmin_temp_var.get()) if hasattr(self, 'softmin_temp_var') else None,&#10;                'verbose': bool(self.verbose_var.get()) if hasattr(self, 'verbose_var') else None,&#10;                'tree_trace': bool(self.tree_trace_var.get()) if hasattr(self, 'tree_trace_var') else None,&#10;                'format': self.format_var.get().strip() if hasattr(self, 'format_var') else None,&#10;            })&#10;            base['stockfish_ui'] = ui&#10;            with open(self.CONFIG_PATH, 'w', encoding='utf-8') as f:&#10;                json.dump(base, f, indent=2)&#10;        except Exception:&#10;            pass&#10;&#10;    def _apply_loaded_prefs(self):&#10;        ui = self._prefs.get('stockfish_ui', {}) if isinstance(self._prefs.get('stockfish_ui'), dict) else {}&#10;        try:&#10;            if ui.get('format') and hasattr(self, 'format_var'):&#10;                self.format_var.set(ui.get('format'))&#10;            if ui.get('depth') and hasattr(self, 'depth_var'):&#10;                self.depth_var.set(int(ui.get('depth')))&#10;            if ui.get('branching') and hasattr(self, 'branch_var'):&#10;                self.branch_var.set(int(ui.get('branching')))&#10;            if ui.get('softmin_temp') is not None and hasattr(self, 'softmin_temp_var'):&#10;                self.softmin_temp_var.set(float(ui.get('softmin_temp')))&#10;            if ui.get('verbose') is not None and hasattr(self, 'verbose_var'):&#10;                self.verbose_var.set(bool(ui.get('verbose')))&#10;            if ui.get('tree_trace') is not None and hasattr(self, 'tree_trace_var'):&#10;                self.tree_trace_var.set(bool(ui.get('tree_trace')))&#10;        except Exception:&#10;            pass&#10;&#10;    def _build_ui(self):&#10;        nb = ttk.Notebook(self); nb.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # --- Dashboard tab&#10;        dash = ttk.Frame(nb); nb.add(dash, text=&quot;Dashboard&quot;)&#10;        controls = ttk.LabelFrame(dash, text=&quot;Controls&quot;); controls.pack(side=tk.TOP, fill=tk.X, padx=8, pady=6)&#10;        ttk.Label(controls, text=f&quot;User: {self.username}&quot;).pack(side=tk.LEFT, padx=4)&#10;        ttk.Label(controls, text=&quot;Format:&quot;).pack(side=tk.LEFT, padx=(14, 2))&#10;        self.format_var = tk.StringVar(value=self.battle_format)&#10;        self.format_combo = ttk.Combobox(controls, textvariable=self.format_var, values=KNOWN_FORMATS, width=26, state=&quot;readonly&quot;)&#10;        self.format_combo.pack(side=tk.LEFT, padx=4)&#10;&#10;        ttk.Label(controls, text=&quot;Depth:&quot;).pack(side=tk.LEFT, padx=(14, 2))&#10;        self.depth_var = tk.IntVar(value=self._prefs.get('stockfish_ui', {}).get('depth', 1))&#10;        self.depth_spin = ttk.Spinbox(controls, from_=1, to=10, textvariable=self.depth_var, width=4, command=self._on_depth_changed)&#10;        self.depth_spin.pack(side=tk.LEFT, padx=4)&#10;        # Branching width spinner (top-K moves considered in depth projection)&#10;        ttk.Label(controls, text=&quot;Branch:&quot;).pack(side=tk.LEFT, padx=(14, 2))&#10;        self.branch_var = tk.IntVar(value=self._prefs.get('stockfish_ui', {}).get('branching', 3))&#10;        self.branch_spin = ttk.Spinbox(controls, from_=1, to=10, textvariable=self.branch_var, width=4, command=self._on_branch_changed)&#10;        self.branch_spin.pack(side=tk.LEFT, padx=4)&#10;        # Softmin temperature spinner&#10;        ttk.Label(controls, text=&quot;Softmin T:&quot;).pack(side=tk.LEFT, padx=(14,2))&#10;        self.softmin_temp_var = tk.DoubleVar(value=self._prefs.get('stockfish_ui', {}).get('softmin_temp', 0.0))&#10;        self.softmin_spin = ttk.Spinbox(controls, from_=0.0, to=5.0, increment=0.1, textvariable=self.softmin_temp_var, width=5, command=self._on_softmin_changed)&#10;        self.softmin_spin.pack(side=tk.LEFT, padx=4)&#10;        self.softmin_spin.bind('&lt;Return&gt;', lambda e: self._on_softmin_changed())&#10;        # Verbose think checkbox&#10;        self.verbose_var = tk.BooleanVar(value=self._prefs.get('stockfish_ui', {}).get('verbose', bool(int(os.environ.get('POKECHAD_THINK_DEBUG','0')))))&#10;        self.verbose_chk = ttk.Checkbutton(controls, text=&quot;Verbose Think&quot;, variable=self.verbose_var, command=self._on_verbose_toggle)&#10;        self.verbose_chk.pack(side=tk.LEFT, padx=(14,4))&#10;        # Tree trace checkbox (detailed minimax branch logging)&#10;        self.tree_trace_var = tk.BooleanVar(value=self._prefs.get('stockfish_ui', {}).get('tree_trace', bool(int(os.environ.get('POKECHAD_TREE_TRACE','0')))))&#10;        self.tree_trace_chk = ttk.Checkbutton(controls, text=&quot;Tree Trace&quot;, variable=self.tree_trace_var, command=self._on_tree_trace_toggle)&#10;        self.tree_trace_chk.pack(side=tk.LEFT, padx=(4,4))&#10;&#10;        ttk.Button(controls, text=&quot;Ladder 1&quot;, command=lambda: self._submit(self._ladder(1))).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Challenge…&quot;, command=self._challenge_dialog).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Accept 1&quot;, command=lambda: self._submit(self._accept(1))).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Start Timer&quot;, command=lambda: self._submit(self._timer_all(True))).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Forfeit&quot;, command=lambda: self._submit(self._forfeit_all())).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Train Weights&quot;, command=self._train_weights).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Reload Weights&quot;, command=self._reload_weights).pack(side=tk.LEFT, padx=4)&#10;        ttk.Button(controls, text=&quot;Reset UI&quot;, command=self._reset_ui).pack(side=tk.LEFT, padx=(14,4))&#10;        # Battle selector (multi-game support)&#10;        ttk.Label(controls, text=&quot;Battle:&quot;).pack(side=tk.LEFT, padx=(14,2))&#10;        self.battle_choice_var = tk.StringVar(value=&quot;&quot;)&#10;        self.battle_combo = ttk.Combobox(controls, textvariable=self.battle_choice_var, values=[], width=24, state=&quot;readonly&quot;)&#10;        self.battle_combo.pack(side=tk.LEFT, padx=4)&#10;        self.battle_combo.bind('&lt;&lt;ComboboxSelected&gt;&gt;', lambda e: self._on_battle_select())&#10;&#10;        # Team panes&#10;        teams = ttk.Frame(dash); teams.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=8, pady=(4, 8))&#10;        self.team_tree = self._make_team_tree(teams, &quot;Your team&quot;)&#10;        self.opp_tree = self._make_team_tree(teams, &quot;Opponent team&quot;)&#10;&#10;        # --- Thinking tab&#10;        think_tab = ttk.Frame(nb); nb.add(think_tab, text=&quot;Thinking&quot;)&#10;        self.cand_tree = self._make_cand_tree(think_tab, &quot;Move candidates&quot;)&#10;        self.switch_tree = self._make_switch_tree(think_tab, &quot;Switch candidates&quot;)&#10;&#10;        # --- Logs tab&#10;        logs_tab = ttk.Frame(nb); nb.add(logs_tab, text=&quot;Logs&quot;)&#10;        self.logs_text = tk.Text(logs_tab, height=20, wrap=&quot;word&quot;)&#10;        self.logs_text.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)&#10;&#10;    def _make_team_tree(self, parent, title: str) -&gt; ttk.Treeview:&#10;        frame = ttk.LabelFrame(parent, text=title)&#10;        frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=6, pady=6)&#10;        # Added 'active' column&#10;        cols = (&quot;slot&quot;, &quot;active&quot;, &quot;species&quot;, &quot;hp&quot;, &quot;status&quot;, &quot;boosts&quot;)&#10;        tree = ttk.Treeview(frame, columns=cols, show=&quot;headings&quot;, height=12)&#10;        headers = (&quot;SLOT&quot;, &quot;ACT&quot;, &quot;SPECIES&quot;, &quot;HP&quot;, &quot;STATUS&quot;, &quot;BOOSTS&quot;)&#10;        widths = (60, 40, 160, 60, 80, 220)&#10;        for c, h, w in zip(cols, headers, widths):&#10;            tree.heading(c, text=h)&#10;            tree.column(c, width=w, anchor=tk.W)&#10;        tree.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;        return tree&#10;&#10;    def _make_cand_tree(self, parent, title: str) -&gt; ttk.Treeview:&#10;        frame = ttk.LabelFrame(parent, text=title); frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=6, pady=6)&#10;        # Added depth-adjusted score (DSCORE) and future projection (FUT) columns&#10;        cols = (&quot;move&quot;, &quot;score&quot;, &quot;dscore&quot;, &quot;future&quot;, &quot;exp_dmg&quot;, &quot;acc&quot;, &quot;eff&quot;, &quot;first&quot;, &quot;opp&quot;, &quot;note&quot;)&#10;        tree = ttk.Treeview(frame, columns=cols, show=&quot;headings&quot;, height=12)&#10;        hdrs = (&quot;MOVE&quot;, &quot;SCORE&quot;, &quot;DSCORE&quot;, &quot;FUT&quot;, &quot;EXP&quot;, &quot;ACC&quot;, &quot;EFF&quot;, &quot;FIRST&quot;, &quot;OPP&quot;, &quot;WHY/NOTE&quot;)&#10;        widths = (180, 70, 70, 60, 60, 50, 50, 60, 60, 240)&#10;        for c, h, w in zip(cols, hdrs, widths):&#10;            tree.heading(c, text=h)&#10;            tree.column(c, width=w, anchor=tk.W)&#10;        tree.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;        return tree&#10;&#10;    def _make_switch_tree(self, parent, title: str) -&gt; ttk.Treeview:&#10;        frame = ttk.LabelFrame(parent, text=title); frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=6, pady=6)&#10;        cols = (&quot;species&quot;, &quot;score&quot;, &quot;base&quot;, &quot;out&quot;, &quot;in&quot;, &quot;haz&quot;, &quot;hp&quot;)&#10;        tree = ttk.Treeview(frame, columns=cols, show=&quot;headings&quot;, height=8)&#10;        headers = (&quot;SPECIES&quot;, &quot;SCORE&quot;, &quot;BASE&quot;, &quot;OUT&quot;, &quot;IN&quot;, &quot;HAZ&quot;, &quot;HP&quot;)&#10;        widths = (140, 70, 70, 60, 60, 50, 60)&#10;        for c, h, w in zip(cols, headers, widths):&#10;            tree.heading(c, text=h)&#10;            tree.column(c, width=w, anchor=tk.W)&#10;        tree.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)&#10;        return tree&#10;&#10;    # ---------- Connect ----------&#10;    async def _async_connect(self):&#10;        try:&#10;            if patch_stockfish_player:&#10;                patch_stockfish_player()&#10;        except Exception as e:&#10;            self._append_log(f&quot;Model patch failed (non-fatal): {e}&quot;)&#10;&#10;        account = AccountConfiguration(self.username, self.password)&#10;        if self.server_mode == &quot;Showdown&quot;:&#10;            server = ShowdownServerConfiguration&#10;        elif self.server_mode == &quot;Localhost&quot;:&#10;            server = LocalhostServerConfiguration&#10;        else:&#10;            server = ShowdownServerConfiguration&#10;            if self.custom_ws:&#10;                try:&#10;                    server = type(&quot;CustomServerConf&quot;, (tuple,), {})((self.custom_ws, ShowdownServerConfiguration[1]))&#10;                except Exception:&#10;                    server = ShowdownServerConfiguration&#10;&#10;        common = dict(&#10;            account_configuration=account,&#10;            server_configuration=server,&#10;            battle_format=self.battle_format,&#10;            log_level=logging.INFO,&#10;        )&#10;&#10;        try:&#10;            depth_val = int(self.depth_var.get())&#10;        except Exception:&#10;            depth_val = None&#10;&#10;        player = None; last_error = None&#10;        sigs = [&#10;            dict(on_think=self._on_think, engine_depth=depth_val, start_listening=True),&#10;            dict(on_think=self._on_think, engine_depth=depth_val),&#10;            dict(on_think=self._on_think),&#10;            dict(engine_depth=depth_val, start_listening=True),&#10;            dict(engine_depth=depth_val),&#10;            dict(),&#10;        ]&#10;        for extra in sigs:&#10;            try:&#10;                kv = {k: v for k, v in extra.items() if v is not None}&#10;                player = StockfishPokeEnvPlayer(**common, **kv); break&#10;            except TypeError as e:&#10;                last_error = e; continue&#10;        if player is None:&#10;            self._append_log(f&quot;Failed to construct player with extended kwargs; retrying minimal. Last error: {last_error}&quot;)&#10;            player = StockfishPokeEnvPlayer(**common)&#10;&#10;        self.player = player&#10;&#10;        # Apply verbose flag if set in UI/env&#10;        try:&#10;            if bool(self.verbose_var.get()) and getattr(self.player, 'engine', None):&#10;                self.player.engine.set_verbose(True)&#10;            # apply initial softmin temp&#10;            if getattr(self.player, 'engine', None) and hasattr(self.player.engine, 'set_softmin_temperature'):&#10;                try: self.player.engine.set_softmin_temperature(float(self.softmin_temp_var.get()))&#10;                except Exception: pass&#10;        except Exception:&#10;            pass&#10;&#10;        try:&#10;            self.player.logger.addHandler(self.log_handler)&#10;            self.player.logger.setLevel(logging.INFO)&#10;        except Exception:&#10;            pass&#10;        try:&#10;            # Also capture ThinkVerbose logger output&#10;            tv = logging.getLogger('ThinkVerbose')&#10;            tv.addHandler(self.log_handler)&#10;            if tv.level &gt; logging.INFO:&#10;                tv.setLevel(logging.INFO)&#10;        except Exception:&#10;            pass&#10;&#10;        await self.player.ps_client.wait_for_login()&#10;        self._append_log(&quot;Login confirmed. Ready.&quot;)&#10;        self._call_on_main(self._poll_battle)&#10;&#10;    # ---------- Actions ----------&#10;    async def _ladder(self, n: int):&#10;        if not self.player: return&#10;        if getattr(self.player, &quot;format&quot;, None) != self.format_var.get():&#10;            try: self.player.format = self.format_var.get()&#10;            except Exception: pass&#10;        self._append_log(f&quot;Starting ladder: {n} game(s)…&quot;)&#10;        await self.player.ladder(n)&#10;&#10;    async def _accept(self, n: int):&#10;        if not self.player: return&#10;        self._append_log(f&quot;Accepting {n} challenge(s)…&quot;)&#10;        await self.player.accept_challenges(opponent=None, n_challenges=n)&#10;&#10;    def _challenge_dialog(self):&#10;        if not self.player: return&#10;        dlg = tk.Toplevel(self); dlg.title(&quot;Challenge a user&quot;)&#10;        ttk.Label(dlg, text=&quot;Opponent username:&quot;).pack(side=tk.TOP, padx=8, pady=8)&#10;        name_var = tk.StringVar(); ttk.Entry(dlg, textvariable=name_var, width=28).pack(side=tk.TOP, padx=8, pady=(0, 8))&#10;        def go():&#10;            opp = name_var.get().strip()&#10;            if opp: self._submit(self.player.send_challenges(opp, n_challenges=1))&#10;            dlg.destroy()&#10;        ttk.Button(dlg, text=&quot;Challenge&quot;, command=go).pack(side=tk.TOP, padx=8, pady=8)&#10;&#10;    async def _forfeit_all(self):&#10;        p = self.player&#10;        if not p: return&#10;        try:&#10;            m = getattr(p, &quot;forfeit_all&quot;, None)&#10;            if callable(m):&#10;                await m(); self._append_log(&quot;Called player.forfeit_all().&quot;); return&#10;        except Exception as e:&#10;            self._append_log(f&quot;player.forfeit_all() failed: {e} — falling back to direct /forfeit.&quot;)&#10;        try:&#10;            client = getattr(p, &quot;ps_client&quot;, None) or getattr(p, &quot;_client&quot;, None)&#10;            if not client: raise RuntimeError(&quot;PSClient missing on player&quot;)&#10;            battles = getattr(p, &quot;battles&quot;, {}) or {}&#10;            rooms: List[str] = []&#10;            for key, battle in list(battles.items()):&#10;                room_id = getattr(battle, &quot;battle_tag&quot;, None) or getattr(battle, &quot;room_id&quot;, None) or str(key)&#10;                if room_id: rooms.append(room_id)&#10;            if not rooms:&#10;                self._append_log(&quot;No active battle rooms found for /forfeit.&quot;); return&#10;            sent = 0&#10;            for r in rooms:&#10;                try:&#10;                    await client.send_message(&quot;/forfeit&quot;, room=r); sent += 1&#10;                except Exception as e2:&#10;                    self._append_log(f&quot;Failed to send /forfeit to {r}: {e2}&quot;)&#10;            self._append_log(f&quot;Sent /forfeit to {sent} room(s).&quot;)&#10;        except Exception as e:&#10;            self._append_log(f&quot;Forfeit fallback failed: {e}&quot;)&#10;&#10;    async def _timer_all(self, on: bool):&#10;        p = self.player&#10;        if not p:&#10;            return&#10;        # Try native player method first&#10;        try:&#10;            m = getattr(p, &quot;timer_all&quot;, None)&#10;            if callable(m):&#10;                await m(on)&#10;                self._append_log(f&quot;Called player.timer_all({on}).&quot;)&#10;                return&#10;        except Exception as e:&#10;            self._append_log(f&quot;player.timer_all({on}) failed: {e} — falling back to direct /timer command.&quot;)&#10;        # Fallback: manually send /timer on|off to all battle rooms&#10;        try:&#10;            client = getattr(p, &quot;ps_client&quot;, None) or getattr(p, &quot;_client&quot;, None)&#10;            if not client:&#10;                raise RuntimeError(&quot;PSClient missing on player&quot;)&#10;            battles = getattr(p, &quot;battles&quot;, {}) or {}&#10;            rooms: List[str] = []&#10;            for key, battle in list(battles.items()):&#10;                room_id = getattr(battle, &quot;battle_tag&quot;, None) or getattr(battle, &quot;room_id&quot;, None) or str(key)&#10;                if room_id:&#10;                    rooms.append(room_id)&#10;            if not rooms:&#10;                self._append_log(&quot;No active battle rooms found for /timer.&quot;)&#10;                return&#10;            cmd = &quot;/timer on&quot; if on else &quot;/timer off&quot;&#10;            sent = 0&#10;            for r in rooms:&#10;                try:&#10;                    await client.send_message(cmd, room=r)&#10;                    sent += 1&#10;                except Exception as e2:&#10;                    self._append_log(f&quot;Failed to send {cmd} to {r}: {e2}&quot;)&#10;            self._append_log(f&quot;Sent {cmd} to {sent} room(s).&quot;)&#10;        except Exception as e:&#10;            self._append_log(f&quot;Timer fallback failed: {e}&quot;)&#10;&#10;    def _on_depth_changed(self):&#10;        if self.player:&#10;            try:&#10;                eng = getattr(self.player, &quot;engine&quot;, None)&#10;                if eng and hasattr(eng, &quot;set_depth&quot;):&#10;                    eng.set_depth(int(self.depth_var.get()))&#10;                elif hasattr(self.player, &quot;set_depth&quot;):&#10;                    self.player.set_depth(int(self.depth_var.get()))&#10;            except Exception:&#10;                pass&#10;        self._save_prefs()&#10;&#10;    def _on_branch_changed(self):&#10;        if self.player:&#10;            try:&#10;                eng = getattr(self.player, &quot;engine&quot;, None)&#10;                if eng and hasattr(eng, &quot;set_branching&quot;):&#10;                    eng.set_branching(int(self.branch_var.get()))&#10;            except Exception:&#10;                pass&#10;        self._save_prefs()&#10;&#10;    def _on_softmin_changed(self):&#10;        if self.player:&#10;            try:&#10;                eng = getattr(self.player, 'engine', None)&#10;                if eng and hasattr(eng, 'set_softmin_temperature'):&#10;                    eng.set_softmin_temperature(float(self.softmin_temp_var.get()))&#10;            except Exception:&#10;                pass&#10;        self._save_prefs()&#10;&#10;    def _on_battle_select(self):&#10;        # User manually picked a battle; update active battle id and refresh snapshot&#10;        bid = self.battle_choice_var.get().strip()&#10;        if not bid or not self.player: return&#10;        self._active_battle_id = bid&#10;        try:&#10;            battle = self.player.battles.get(bid)&#10;            if battle:&#10;                from Data.poke_env_battle_environment import snapshot as snapshot_battle  # local import to avoid cycle&#10;                try: self._latest_snapshot = snapshot_battle(battle)&#10;                except Exception: pass&#10;                self._refresh_teams(); self._refresh_thinking()&#10;        except Exception: pass&#10;&#10;    def _on_verbose_toggle(self):&#10;        v = bool(self.verbose_var.get())&#10;        try:&#10;            if self.player and getattr(self.player, 'engine', None):&#10;                try: self.player.engine.set_verbose(v)&#10;                except Exception: pass&#10;        except Exception: pass&#10;        try: os.environ['POKECHAD_THINK_DEBUG'] = '1' if v else '0'&#10;        except Exception: pass&#10;        self._append_log(f&quot;Verbose think {'ENABLED' if v else 'DISABLED'}&quot;)&#10;        self._save_prefs()&#10;&#10;    def _on_tree_trace_toggle(self):&#10;        t = bool(self.tree_trace_var.get())&#10;        try: os.environ['POKECHAD_TREE_TRACE'] = '1' if t else '0'&#10;        except Exception: pass&#10;        self._append_log(f&quot;Tree trace {'ENABLED' if t else 'DISABLED'} (takes effect next think cycle)&quot;)&#10;        self._save_prefs()&#10;&#10;    def _reset_ui(self):&#10;        &quot;&quot;&quot;Clear UI state so next battle starts with a clean slate.&quot;&quot;&quot;&#10;        try:&#10;            self._latest_think = {}&#10;            self._latest_snapshot = {}&#10;            self._last_fallback_turn = None&#10;            self._last_real_think_turn = None&#10;            # Clear trees&#10;            for tree in (self.cand_tree, self.switch_tree, self.team_tree, self.opp_tree):&#10;                try: self._reload_tree(tree)&#10;                except Exception: pass&#10;            # Clear logs text (keep telemetry file)&#10;            try:&#10;                self.logs_text.delete('1.0', tk.END)&#10;            except Exception: pass&#10;            self._append_log(&quot;[reset] UI state cleared; ready for next battle.&quot;)&#10;        except Exception as e:&#10;            self._append_log(f&quot;[reset] Failed: {e}&quot;)&#10;&#10;    # ---------- Train / Reload ----------&#10;    def _train_weights(self):&#10;        def run():&#10;            try:&#10;                cmd = [sys.executable, &quot;../tools/train_launcher.py&quot;]&#10;                self._append_log(&quot;[run] &quot; + &quot; &quot;.join(cmd))&#10;                proc = subprocess.run(cmd, capture_output=True, text=True)&#10;                if proc.stdout: self._append_log(proc.stdout.strip())&#10;                if proc.returncode != 0:&#10;                    if proc.stderr: self._append_log(proc.stderr.strip())&#10;                    messagebox.showerror(&quot;Training failed&quot;, proc.stderr or &quot;trainer returned non-zero&quot;)&#10;                else:&#10;                    self._append_log(&quot;[ok] Training finished.&quot;)&#10;            except Exception as e:&#10;                self._append_log(f&quot;Training failed: {e}&quot;)&#10;        threading.Thread(target=run, daemon=True).start()&#10;&#10;    def _reload_weights(self):&#10;        try:&#10;            eng = getattr(self.player, &quot;engine&quot;, None)&#10;            if eng and hasattr(eng, &quot;reload_weights&quot;):&#10;                eng.reload_weights()&#10;                messagebox.showinfo(&quot;Weights&quot;, &quot;Weights reloaded from Models/weights.json&quot;)&#10;            else:&#10;                messagebox.showwarning(&quot;Weights&quot;, &quot;Engine does not expose reload_weights()&quot;)&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;Weights&quot;, f&quot;Reload failed: {e}&quot;)&#10;&#10;    # ---------- Think data from model ----------&#10;    def _on_think(self, battle, think: Dict[str, Any]):&#10;        self._latest_think = think or {}&#10;        try: snap = think.get(&quot;snapshot&quot;)&#10;        except Exception: snap = None&#10;        self._latest_snapshot = snap or snapshot_battle(battle)&#10;        try:&#10;            self._last_real_think_turn = int(self._latest_snapshot.get(&quot;turn&quot;)) if self._latest_snapshot else None&#10;        except Exception:&#10;            pass&#10;        # write JSONL telemetry if there is a picked decision&#10;        try:&#10;            if think.get(&quot;picked&quot;):&#10;                entry = {&#10;                    &quot;battle_tag&quot;: think.get(&quot;battle_tag&quot;) or getattr(battle, &quot;battle_tag&quot;, None) or getattr(battle, &quot;room_id&quot;, None),&#10;                    &quot;turn&quot;: think.get(&quot;turn&quot;) or self._latest_snapshot.get(&quot;turn&quot;),&#10;                    &quot;picked&quot;: think.get(&quot;picked&quot;),&#10;                    &quot;order&quot;: think.get(&quot;order&quot;),&#10;                    &quot;switch_meta&quot;: think.get(&quot;switch_meta&quot;),  # added for switch weight training&#10;                    &quot;snapshot&quot;: self._latest_snapshot,&#10;                }&#10;                with open(self._telemetry_path, &quot;a&quot;, encoding=&quot;utf-8&quot;) as f:&#10;                    f.write(json.dumps(entry) + &quot;\n&quot;)&#10;        except Exception as e:&#10;            self._append_log(f&quot;telemetry write failed: {e}&quot;)&#10;&#10;        self._call_on_main(self._refresh_thinking)&#10;        self._call_on_main(self._refresh_teams)&#10;&#10;    def _refresh_thinking(self):&#10;        if not self.winfo_exists(): return&#10;        # Candidates&#10;        self._reload_tree(self.cand_tree)&#10;        for d in self._latest_think.get(&quot;candidates&quot;, []):&#10;            try:&#10;                move = d.get(&quot;name&quot;) or d.get(&quot;id&quot;) or d.get(&quot;move&quot;) or d.get(&quot;move_id&quot;)&#10;                raw_score = d.get(&quot;score&quot;)&#10;                depth_score = d.get(&quot;score_depth&quot;, raw_score)&#10;                future = d.get(&quot;future_proj&quot;)&#10;                score = f&quot;{float(raw_score):.2f}&quot; if raw_score is not None else &quot;&quot;&#10;                dscore = f&quot;{float(depth_score):.2f}&quot; if depth_score is not None else &quot;&quot;&#10;                fut = f&quot;{float(future):.2f}&quot; if future is not None else &quot;&quot;&#10;                exp = &quot;&quot;;&#10;                for k in (&quot;exp_dmg&quot;, &quot;expected&quot;, &quot;exp&quot;, &quot;expdmg&quot;, &quot;expected_damage&quot;):&#10;                    if d.get(k) is not None:&#10;                        exp = f&quot;{float(d.get(k)):.2f}&quot;; break&#10;                acc = &quot;&quot;;&#10;                for k in (&quot;acc&quot;, &quot;acc_mult&quot;, &quot;accuracy&quot;, &quot;hit_chance&quot;):&#10;                    if d.get(k) is not None:&#10;                        acc = f&quot;{float(d.get(k)):.2f}&quot;; break&#10;                eff = &quot;&quot;;&#10;                for k in (&quot;eff&quot;, &quot;effectiveness&quot;, &quot;type_mult&quot;, &quot;type_effectiveness&quot;):&#10;                    if d.get(k) is not None:&#10;                        eff = f&quot;{float(d.get(k)):.2f}&quot;; break&#10;                first = &quot;&quot;;&#10;                if d.get(&quot;first_prob&quot;) is not None: first = f&quot;{float(d.get('first_prob')):.2f}&quot;&#10;                opp = &quot;&quot;;&#10;                if d.get(&quot;opp_counter_ev&quot;) is not None: opp = f&quot;{float(d.get('opp_counter_ev')):.2f}&quot;&#10;                note = d.get(&quot;why_blocked&quot;) or d.get(&quot;note&quot;) or d.get(&quot;why&quot;) or &quot;&quot;&#10;                self.cand_tree.insert(&quot;&quot;, tk.END, values=(move, score, dscore, fut, exp, acc, eff, first, opp, note))&#10;            except Exception:&#10;                try:&#10;                    self.cand_tree.insert(&quot;&quot;, tk.END, values=(str(d), &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;))&#10;                except Exception:&#10;                    pass&#10;&#10;        # Switches&#10;        self._reload_tree(self.switch_tree)&#10;        for d in self._latest_think.get(&quot;switches&quot;, []):&#10;            try:&#10;                species = d.get(&quot;species&quot;) or d.get(&quot;name&quot;) or d.get(&quot;id&quot;)&#10;                s = d.get(&quot;score&quot;); score = f&quot;{float(s):.2f}&quot; if s is not None else &quot;&quot;&#10;                base = d.get(&quot;base_score&quot;); base_s = f&quot;{float(base):.2f}&quot; if base is not None else &quot;&quot;&#10;                out = d.get(&quot;outgoing_frac&quot;); out_s = f&quot;{float(out):.2f}&quot; if out is not None else &quot;&quot;&#10;                incoming = d.get(&quot;incoming_on_switch&quot;); in_s = f&quot;{float(incoming):.2f}&quot; if incoming is not None else &quot;&quot;&#10;                haz = d.get(&quot;hazards_frac&quot;); haz_s = f&quot;{float(haz):.2f}&quot; if haz is not None else &quot;&quot;&#10;                hp = d.get(&quot;hp_fraction&quot;); hp_s = f&quot;{int(round(float(hp) * 100))}%&quot; if isinstance(hp, (int, float)) else &quot;&quot;&#10;                self.switch_tree.insert(&quot;&quot;, tk.END, values=(species, score, base_s, out_s, in_s, haz_s, hp_s))&#10;            except Exception:&#10;                try:&#10;                    species = d.get(&quot;species&quot;) or str(d)&#10;                    score = f&quot;{float(d.get('score', 0)):.2f}&quot; if d.get('score') is not None else &quot;0.00&quot;&#10;                    self.switch_tree.insert(&quot;&quot;, tk.END, values=(species, score, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;))&#10;                except Exception:&#10;                    pass&#10;&#10;    def _refresh_teams(self):&#10;        if not self.winfo_exists(): return&#10;        snap = self._latest_snapshot or {}&#10;        self._reload_tree(self.team_tree)&#10;        for sid, p in (snap.get(&quot;my_team&quot;) or {}).items():&#10;            boosts = pretty_boosts(p.get(&quot;boosts&quot;))&#10;            hp = p.get(&quot;hp_fraction&quot;)&#10;            hp_s = f&quot;{int(round(hp * 100))}%&quot; if isinstance(hp, (int, float)) else &quot;&quot;&#10;            active_flag = &quot;*&quot; if p.get(&quot;is_active&quot;) else &quot;&quot;&#10;            self.team_tree.insert(&quot;&quot;, tk.END, values=(sid, active_flag, p.get(&quot;species&quot;), hp_s, str(p.get(&quot;status&quot;) or &quot;&quot;), boosts))&#10;        self._reload_tree(self.opp_tree)&#10;        for sid, p in (snap.get(&quot;opp_team&quot;) or {}).items():&#10;            boosts = pretty_boosts(p.get(&quot;boosts&quot;))&#10;            hp = p.get(&quot;hp_fraction&quot;)&#10;            hp_s = f&quot;{int(round(hp * 100))}%&quot; if isinstance(hp, (int, float)) else &quot;&quot;&#10;            active_flag = &quot;*&quot; if p.get(&quot;is_active&quot;) else &quot;&quot;&#10;            self.opp_tree.insert(&quot;&quot;, tk.END, values=(sid, active_flag, p.get(&quot;species&quot;), hp_s, str(p.get(&quot;status&quot;) or &quot;&quot;), boosts))&#10;&#10;    def _reload_tree(self, tree: ttk.Treeview):&#10;        try:&#10;            for iid in tree.get_children():&#10;                tree.delete(iid)&#10;        except tk.TclError:&#10;            pass&#10;&#10;    # ---------- Polling ----------&#10;    def _find_active_battle(self):&#10;        p = getattr(self, &quot;player&quot;, None)&#10;        if not p: return None&#10;        battles = getattr(p, &quot;battles&quot;, None)&#10;        if not isinstance(battles, dict) or not battles:&#10;            return None&#10;        # Update selector list with current battles&#10;        ids = list(battles.keys())&#10;        try:&#10;            self.battle_combo.configure(values=ids)&#10;            # Preserve selection; if none selected or selection gone, pick first unfinished&#10;            if not self._active_battle_id or self._active_battle_id not in ids:&#10;                # prefer unfinished battle&#10;                for bid, b in battles.items():&#10;                    if not getattr(b, 'finished', False):&#10;                        self._active_battle_id = bid; break&#10;                else:&#10;                    # fallback last id&#10;                    self._active_battle_id = ids[-1]&#10;                self.battle_choice_var.set(self._active_battle_id)&#10;        except Exception: pass&#10;        # Choose the active battle respecting user override&#10;        battle = battles.get(self._active_battle_id)&#10;        # If chosen battle finished and there is another unfinished, switch automatically&#10;        if battle and getattr(battle,'finished', False):&#10;            for bid,b in battles.items():&#10;                if not getattr(b,'finished', False):&#10;                    self._active_battle_id = bid&#10;                    self.battle_choice_var.set(bid)&#10;                    battle = b&#10;                    break&#10;        return battle&#10;&#10;    def _poll_battle(self):&#10;        try:&#10;            if not self.winfo_exists(): return&#10;            b = self._find_active_battle()&#10;            if b is not None:&#10;                # Detect battle finished transition&#10;                finished = bool(getattr(b,'finished', False))&#10;                bid = getattr(b,'battle_tag', getattr(b,'room_id', None))&#10;                if finished and bid and bid not in self._finished_battles:&#10;                    self._finished_battles.add(bid)&#10;                    self._append_log(f&quot;[battle] Finished: {bid} (winner={getattr(b,'won', None)})&quot;)&#10;                if not finished:&#10;                    try:&#10;                        from Data.poke_env_battle_environment import snapshot as snapshot_battle&#10;                        snap = snapshot_battle(b); self._latest_snapshot = snap&#10;                    except Exception: snap = None&#10;                    try: self._refresh_teams()&#10;                    except Exception: pass&#10;                    try:&#10;                        turn = int(snap.get(&quot;turn&quot;)) if snap else None&#10;                    except Exception:&#10;                        turn = None&#10;                    if turn is not None and turn != self._last_fallback_turn and turn != self._last_real_think_turn:&#10;                        self._emit_fallback_think(b, snap); self._last_fallback_turn = turn&#10;                else:&#10;                    # Finished: if there is another unfinished battle, UI will swap next poll; otherwise allow new games without restart&#10;                    pass&#10;            else:&#10;                # No battles active; clear selection state (leave past logs) but enable new games&#10;                if self._active_battle_id is not None:&#10;                    self._append_log(&quot;[battle] No active battles. Ready for a new game.&quot;)&#10;                self._active_battle_id = None&#10;                self.battle_choice_var.set(&quot;&quot;)&#10;        finally:&#10;            if self.winfo_exists():&#10;                try: h = self.after(500, self._poll_battle); self._scheduled_tasks.append(h)&#10;                except Exception: pass&#10;&#10;    def _emit_fallback_think(self, battle, snap: Optional[Dict[str, Any]]):&#10;        try:&#10;            cands = []&#10;            for m in (getattr(battle, &quot;available_moves&quot;, None) or []):&#10;                try:&#10;                    name = getattr(m, &quot;name&quot;, None) or getattr(m, &quot;id&quot;, None) or str(m)&#10;                    bp = getattr(m, &quot;base_power&quot;, None) or getattr(m, &quot;basePower&quot;, None) or 0&#10;                    acc = getattr(m, &quot;accuracy&quot;, None)&#10;                    if acc is True: acc_val = 1.0&#10;                    elif isinstance(acc, (int, float)): acc_val = float(acc) / (100.0 if acc &gt; 1 else 1.0)&#10;                    else: acc_val = 1.0&#10;                    expected = float(bp or 0) * float(acc_val)&#10;                    cands.append({&quot;name&quot;: name, &quot;score&quot;: expected, &quot;exp_dmg&quot;: expected, &quot;acc&quot;: acc_val, &quot;eff&quot;: &quot;&quot;, &quot;note&quot;: &quot;synthetic&quot;})&#10;                except Exception: pass&#10;&#10;            switches = []&#10;            for pkm in (getattr(battle, &quot;available_switches&quot;, None) or []):&#10;                try:&#10;                    species = getattr(pkm, &quot;species&quot;, None) or getattr(pkm, &quot;name&quot;, None) or str(pkm)&#10;                    hp_frac = getattr(pkm, &quot;hp_fraction&quot;, None) or getattr(pkm, &quot;current_hp_fraction&quot;, None)&#10;                    switches.append({&quot;species&quot;: species, &quot;score&quot;: float(hp_frac or 0.0), &quot;hp_fraction&quot;: float(hp_frac or 0.0)})&#10;                except Exception: pass&#10;&#10;            think = {&quot;candidates&quot;: sorted(cands, key=lambda d: d.get(&quot;score&quot;) or 0.0, reverse=True),&#10;                     &quot;switches&quot;: sorted(switches, key=lambda d: d.get(&quot;score&quot;) or 0.0, reverse=True),&#10;                     &quot;snapshot&quot;: snap or snapshot_battle(battle)}&#10;            self._on_think(battle, think)&#10;        except Exception as e:&#10;            self._append_log(f&quot;Fallback think failed: {e}&quot;)&#10;&#10;    # ---------- Logs ----------&#10;    def _append_log(self, msg: str):&#10;        try:&#10;            self.logs_text.insert(tk.END, msg + &quot;\n&quot;)&#10;            self.logs_text.see(tk.END)&#10;        except Exception:&#10;            pass&#10;&#10;    def _pump_logs(self):&#10;        try:&#10;            while True:&#10;                msg = self.log_queue.get_nowait()&#10;                self._append_log(msg)&#10;        except queue.Empty:&#10;            pass&#10;        if self.winfo_exists():&#10;            h = self.after(200, self._pump_logs)&#10;            self._scheduled_tasks.append(h)&#10;&#10;    # ---------- Shutdown ----------&#10;    def _on_close(self):&#10;        self._save_prefs()&#10;        for h in self._scheduled_tasks:&#10;            try: self.after_cancel(h)&#10;            except Exception: pass&#10;        self._scheduled_tasks.clear()&#10;        try:&#10;            if self.loop.is_running():&#10;                self.loop.call_soon_threadsafe(self.loop.stop)&#10;        except Exception:&#10;            pass&#10;        self.destroy()&#10;&#10;def launch_stockfish_window(root: tk.Tk, username: str, password: Optional[str],&#10;                            server_mode: str, custom_ws: Optional[str], battle_format: str) -&gt; StockfishWindow:&#10;    return StockfishWindow(root, username=username, password=password,&#10;                           server_mode=server_mode, custom_ws=custom_ws, battle_format=battle_format)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apply_all_fixes_typechart_patch.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apply_all_fixes_typechart_patch.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;fix_type_effectiveness.py&#10;- Adds a robust type-effectiveness calculator + loader&#10;- Normalizes IDs (Showdown-style)&#10;- Wires in debug logging so you can inspect why 'effectiveness' ever becomes 1.0&#10;- Optionally nudges UI/tk_main_menu.py to enable the hook&#10;&#10;Usage:&#10;  python fix_type_effectiveness.py --apply [--data-dir tools/Data/showdown]&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;apply_all_fixes_typechart_patch.py&#10;- Adds a robust type-effectiveness calculator + loader&#10;- Normalizes IDs (Showdown-style)&#10;- Wires in debug logging so you can inspect why 'effectiveness' ever becomes 1.0&#10;- Optionally nudges UI/tk_main_menu.py to enable the hook&#10;&#10;Usage:&#10;  python apply_all_fixes_typechart_patch.py --apply [--data-dir &lt;path to showdown data dir&gt;]&#10;&#10;The script will attempt to auto-detect your showdown data folder if --data-dir is&#10;not provided. It looks for (first existing wins):&#10;  tools/Data/showdown&#10;  showdown&#10;  tools/showdown&#10;  Resources/showdown&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;import argparse&#10;import json&#10;import logging&#10;import os&#10;import re&#10;import sys&#10;from pathlib import Path&#10;from typing import Dict, Any, List, Tuple, Optional&#10;&#10;# --- Project / data dir detection -------------------------------------------------&#10;&#10;def _detect_project_root() -&gt; Path:&#10;    here = Path(__file__).resolve().parent&#10;    # Walk upward until we find markers typical for this project&#10;    markers = {&quot;UI&quot;, &quot;Data&quot;, &quot;Models&quot;}&#10;    for parent in [here] + list(here.parents):&#10;        if all((parent / m).exists() for m in [&quot;UI&quot;, &quot;Data&quot;]):&#10;            return parent&#10;        # allow partial marker match&#10;        if sum((parent / m).exists() for m in markers) &gt;= 2:&#10;            return parent&#10;    return here&#10;&#10;def _find_showdown_data_dir(root: Path) -&gt; Path:&#10;    candidates = [&#10;        root / &quot;tools&quot; / &quot;Data&quot; / &quot;showdown&quot;,&#10;        root / &quot;showdown&quot;,&#10;        root / &quot;tools&quot; / &quot;showdown&quot;,&#10;        root / &quot;Resources&quot; / &quot;showdown&quot;,&#10;    ]&#10;    for c in candidates:&#10;        if (c / &quot;moves.json&quot;).exists() or (c / &quot;pokedex.json&quot;).exists():&#10;            return c&#10;    # fallback to first conventional path even if missing&#10;    return candidates[0]&#10;&#10;ROOT = _detect_project_root()&#10;DEFAULT_DATA_DIR = _find_showdown_data_dir(ROOT)&#10;UTILS_DIR = ROOT / &quot;utils&quot;&#10;LOGS_DIR = ROOT / &quot;logs&quot;&#10;UI_MAIN = ROOT / &quot;UI&quot; / &quot;tk_main_menu.py&quot;&#10;&#10;# ---- Helpers ----------------------------------------------------------------&#10;&#10;def to_id(s: str) -&gt; str:&#10;    &quot;&quot;&quot;Showdown-like id normalization (ascii-ish, lower, strip spaces/punct).&quot;&quot;&quot;&#10;    if s is None:&#10;        return &quot;&quot;&#10;    s = s.lower()&#10;    # collapse non-alnum into nothing&#10;    s = re.sub(r&quot;[^a-z0-9]+&quot;, &quot;&quot;, s)&#10;    return s&#10;&#10;def ensure_dir(p: Path) -&gt; None:&#10;    p.mkdir(parents=True, exist_ok=True)&#10;&#10;def find_first(data_dir: Path, name: str) -&gt; Optional[Path]:&#10;    # Accepts like &quot;moves&quot; -&gt; moves.json / moves.*.json&#10;    for pattern in (f&quot;{name}.json&quot;, f&quot;*{name}*.json&quot;):&#10;        found = list(data_dir.glob(pattern))&#10;        if found:&#10;            return found[0]&#10;    return None&#10;&#10;# ---- File writers ------------------------------------------------------------&#10;&#10;SHOWDOWN_LOADER = &quot;&quot;&quot;# Auto-generated by fix_type_effectiveness.py&#10;from __future__ import annotations&#10;import json, logging&#10;from pathlib import Path&#10;from typing import Dict, Any, Optional&#10;&#10;log = logging.getLogger(&quot;typecalc&quot;)&#10;&#10;def _read_json(p: Path) -&gt; Optional[dict]:&#10;    try:&#10;        with p.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            return json.load(f)&#10;    except Exception as e:&#10;        log.warning(&quot;Failed reading JSON %s: %s&quot;, p, e)&#10;        return None&#10;&#10;class ShowdownData:&#10;    def __init__(self, data_dir: Path):&#10;        self.data_dir = Path(data_dir)&#10;        self.moves = {}&#10;        self.pokedex = {}&#10;        self.typechart = {}&#10;        self._load()&#10;&#10;    def _load(self):&#10;        mv = next(iter(self.data_dir.glob('*moves*.json')), None)&#10;        pd = next(iter(self.data_dir.glob('*pokedex*.json')), None)&#10;        tc = next(iter(self.data_dir.glob('*typechart*.json')), None)&#10;        if mv:&#10;            self.moves = _read_json(mv) or {}&#10;        if pd:&#10;            self.pokedex = _read_json(pd) or {}&#10;        if tc:&#10;            self.typechart = _read_json(tc) or {}&#10;&#10;        # Normalize keys to showdown ids&#10;        self.moves = { (k if k == k.lower() else k.lower()): v for k, v in self.moves.items() }&#10;        self.pokedex = { (k if k == k.lower() else k.lower()): v for k, v in self.pokedex.items() }&#10;&#10;        # Some datasets nest under e.g. {&quot;Moves&quot;: {...}} or {&quot;Pokedex&quot;: {...}}&#10;        if 'moves' in self.moves and isinstance(self.moves['moves'], dict):&#10;            self.moves = self.moves['moves']&#10;        if 'pokedex' in self.pokedex and isinstance(self.pokedex['pokedex'], dict):&#10;            self.pokedex = self.pokedex['pokedex']&#10;        if 'typechart' in self.typechart and isinstance(self.typechart['typechart'], dict):&#10;            self.typechart = self.typechart['typechart']&#10;&#10;    def get_move(self, move_id: str) -&gt; dict:&#10;        return self.moves.get(move_id, self.moves.get(move_id.lower(), {}))&#10;&#10;    def get_species(self, species_id: str) -&gt; dict:&#10;        return self.pokedex.get(species_id, self.pokedex.get(species_id.lower(), {}))&#10;&#10;    def get_types_for_species(self, species_id: str) -&gt; list:&#10;        sp = self.get_species(species_id)&#10;        # poke-env &amp; PS style datasets usually have [&quot;types&quot;] or &quot;types&quot;&#10;        t = sp.get(&quot;types&quot;) or sp.get(&quot;type&quot;) or []&#10;        if isinstance(t, str):&#10;            t = [t]&#10;        return t&#10;&quot;&quot;&quot;&#10;&#10;TYPE_EFFECT = r'''# Auto-generated by fix_type_effectiveness.py&#10;from __future__ import annotations&#10;import logging&#10;from pathlib import Path&#10;from typing import Dict, Tuple, List, Optional&#10;from .showdown_loader import ShowdownData&#10;&#10;log = logging.getLogger(&quot;typecalc&quot;)&#10;&#10;# Hard-coded correct Gen 6+ chart (used only if no JSON provided)&#10;# eff[atk][def] = multiplier&#10;# fmt: off&#10;_TYPES = [&quot;Normal&quot;,&quot;Fire&quot;,&quot;Water&quot;,&quot;Electric&quot;,&quot;Grass&quot;,&quot;Ice&quot;,&quot;Fighting&quot;,&quot;Poison&quot;,&quot;Ground&quot;,&quot;Flying&quot;,&quot;Psychic&quot;,&quot;Bug&quot;,&quot;Rock&quot;,&quot;Ghost&quot;,&quot;Dragon&quot;,&quot;Dark&quot;,&quot;Steel&quot;,&quot;Fairy&quot;]&#10;def _matrix() -&gt; Dict[str, Dict[str, float]]:&#10;    n = 1.0; h = 0.5; s = 2.0; z = 0.0&#10;    eff = {t: {u: n for u in _TYPES} for t in _TYPES}&#10;    # Normal&#10;    eff[&quot;Normal&quot;][&quot;Rock&quot;]=h; eff[&quot;Normal&quot;][&quot;Ghost&quot;]=z; eff[&quot;Normal&quot;][&quot;Steel&quot;]=h&#10;    # Fire&#10;    for u in [&quot;Fire&quot;,&quot;Water&quot;,&quot;Rock&quot;,&quot;Dragon&quot;]: eff[&quot;Fire&quot;][u]=h&#10;    for u in [&quot;Grass&quot;,&quot;Ice&quot;,&quot;Bug&quot;,&quot;Steel&quot;]: eff[&quot;Fire&quot;][u]=s&#10;    # Water&#10;    for u in [&quot;Fire&quot;,&quot;Ground&quot;,&quot;Rock&quot;]: eff[&quot;Water&quot;][u]=s&#10;    for u in [&quot;Water&quot;,&quot;Grass&quot;,&quot;Dragon&quot;]: eff[&quot;Water&quot;][u]=h&#10;    # Electric&#10;    for u in [&quot;Water&quot;,&quot;Flying&quot;]: eff[&quot;Electric&quot;][u]=s&#10;    for u in [&quot;Electric&quot;,&quot;Grass&quot;,&quot;Dragon&quot;]: eff[&quot;Electric&quot;][u]=h&#10;    eff[&quot;Electric&quot;][&quot;Ground&quot;]=z&#10;    # Grass&#10;    for u in [&quot;Water&quot;,&quot;Ground&quot;,&quot;Rock&quot;]: eff[&quot;Grass&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Grass&quot;,&quot;Poison&quot;,&quot;Flying&quot;,&quot;Bug&quot;,&quot;Dragon&quot;,&quot;Steel&quot;]: eff[&quot;Grass&quot;][u]=h&#10;    # Ice&#10;    for u in [&quot;Grass&quot;,&quot;Ground&quot;,&quot;Flying&quot;,&quot;Dragon&quot;]: eff[&quot;Ice&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Water&quot;,&quot;Ice&quot;,&quot;Steel&quot;]: eff[&quot;Ice&quot;][u]=h&#10;    # Fighting&#10;    for u in [&quot;Normal&quot;,&quot;Ice&quot;,&quot;Rock&quot;,&quot;Dark&quot;,&quot;Steel&quot;]: eff[&quot;Fighting&quot;][u]=s&#10;    for u in [&quot;Poison&quot;,&quot;Flying&quot;,&quot;Psychic&quot;,&quot;Bug&quot;,&quot;Fairy&quot;]: eff[&quot;Fighting&quot;][u]=h&#10;    eff[&quot;Fighting&quot;][&quot;Ghost&quot;]=z&#10;    # Poison&#10;    eff[&quot;Poison&quot;][&quot;Grass&quot;]=s&#10;    for u in [&quot;Poison&quot;,&quot;Ground&quot;,&quot;Rock&quot;,&quot;Ghost&quot;]: eff[&quot;Poison&quot;][u]=h&#10;    eff[&quot;Poison&quot;][&quot;Steel&quot;]=z&#10;    eff[&quot;Poison&quot;][&quot;Fairy&quot;]=s&#10;    # Ground&#10;    for u in [&quot;Fire&quot;,&quot;Electric&quot;,&quot;Poison&quot;,&quot;Rock&quot;,&quot;Steel&quot;]: eff[&quot;Ground&quot;][u]=s&#10;    for u in [&quot;Grass&quot;,&quot;Bug&quot;]: eff[&quot;Ground&quot;][u]=h&#10;    eff[&quot;Ground&quot;][&quot;Flying&quot;]=z&#10;    # Flying&#10;    for u in [&quot;Grass&quot;,&quot;Fighting&quot;,&quot;Bug&quot;]: eff[&quot;Flying&quot;][u]=s&#10;    for u in [&quot;Electric&quot;,&quot;Rock&quot;,&quot;Steel&quot;]: eff[&quot;Flying&quot;][u]=h&#10;    # Psychic&#10;    for u in [&quot;Fighting&quot;,&quot;Poison&quot;]: eff[&quot;Psychic&quot;][u]=s&#10;    for u in [&quot;Psychic&quot;,&quot;Steel&quot;]: eff[&quot;Psychic&quot;][u]=h&#10;    eff[&quot;Psychic&quot;][&quot;Dark&quot;]=z&#10;    # Bug&#10;    for u in [&quot;Grass&quot;,&quot;Psychic&quot;,&quot;Dark&quot;]: eff[&quot;Bug&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Fighting&quot;,&quot;Poison&quot;,&quot;Flying&quot;,&quot;Ghost&quot;,&quot;Steel&quot;,&quot;Fairy&quot;]: eff[&quot;Bug&quot;][u]=h&#10;    # Rock&#10;    for u in [&quot;Fire&quot;,&quot;Ice&quot;,&quot;Flying&quot;,&quot;Bug&quot;]: eff[&quot;Rock&quot;][u]=s&#10;    for u in [&quot;Fighting&quot;,&quot;Ground&quot;,&quot;Steel&quot;]: eff[&quot;Rock&quot;][u]=h&#10;    # Ghost&#10;    eff[&quot;Ghost&quot;][&quot;Ghost&quot;]=s; eff[&quot;Ghost&quot;][&quot;Psychic&quot;]=s&#10;    eff[&quot;Ghost&quot;][&quot;Dark&quot;]=h; eff[&quot;Ghost&quot;][&quot;Normal&quot;]=z&#10;    # Dragon&#10;    eff[&quot;Dragon&quot;][&quot;Dragon&quot;]=s; eff[&quot;Dragon&quot;][&quot;Steel&quot;]=h; eff[&quot;Dragon&quot;][&quot;Fairy&quot;]=z&#10;    # Dark&#10;    eff[&quot;Dark&quot;][&quot;Psychic&quot;]=s; eff[&quot;Dark&quot;][&quot;Ghost&quot;]=s&#10;    for u in [&quot;Fighting&quot;,&quot;Dark&quot;,&quot;Fairy&quot;]: eff[&quot;Dark&quot;][u]=h&#10;    # Steel&#10;    for u in [&quot;Rock&quot;,&quot;Ice&quot;,&quot;Fairy&quot;]: eff[&quot;Steel&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Water&quot;,&quot;Electric&quot;,&quot;Steel&quot;]: eff[&quot;Steel&quot;][u]=h&#10;    # Fairy&#10;    for u in [&quot;Fighting&quot;,&quot;Dragon&quot;,&quot;Dark&quot;]: eff[&quot;Fairy&quot;][u]=s&#10;    for u in [&quot;Fire&quot;,&quot;Poison&quot;,&quot;Steel&quot;]: eff[&quot;Fairy&quot;][u]=h&#10;    return eff&#10;# fmt: on&#10;&#10;def _title(s: str) -&gt; str:&#10;    return s[:1].upper() + s[1:].lower() if s else s&#10;&#10;class TypeCalc:&#10;    def __init__(self, data: ShowdownData | None):&#10;        self.data = data&#10;        self._fallback = _matrix()&#10;&#10;    def move_type(self, move_id: str, is_terastallized: bool = False, attacker_tera_type: Optional[str] = None) -&gt; Optional[str]:&#10;        mid = move_id.lower()&#10;        mv = self.data.get_move(mid) if self.data else {}&#10;        t = mv.get(&quot;type&quot;)&#10;        # Tera Blast rule: Normal if not terastallized. When Tera is active, it becomes the Tera type.&#10;        if mid == &quot;terablast&quot;:&#10;            if is_terastallized and attacker_tera_type:&#10;                return _title(attacker_tera_type)&#10;            return &quot;Normal&quot;&#10;        return _title(t) if t else None&#10;&#10;    def species_types(self, species_id: str) -&gt; List[str]:&#10;        sid = species_id.lower()&#10;        ts = self.data.get_types_for_species(sid) if self.data else []&#10;        if ts:&#10;            return [_title(x) for x in ts]&#10;        # Unknown species in data -&gt; assume typeless neutral (will behave as 1.0 vs everything)&#10;        return []&#10;&#10;    def type_multiplier(self, atk_type: str, def_types: List[str]) -&gt; Tuple[float, List[str]]:&#10;        if not atk_type:&#10;            return 1.0, [&quot;no-attack-type&quot;]&#10;        reasons = []&#10;        total = 1.0&#10;        src = self.data.typechart if (self.data and self.data.typechart) else self._fallback&#10;        atk_title = _title(atk_type)&#10;        if atk_title not in src:&#10;            return 1.0, [f&quot;missing-atk-type:{atk_title}&quot;]&#10;        for dt in def_types or []:&#10;            dtt = _title(dt)&#10;            mult = src[atk_title].get(dtt)&#10;            if mult is None:&#10;                # If JSON not present, fall back to hard-coded&#10;                mult = self._fallback.get(atk_title, {}).get(dtt, 1.0)&#10;                reasons.append(f&quot;fallback:{atk_title}-&gt;{dtt}={mult}&quot;)&#10;            else:&#10;                reasons.append(f&quot;{atk_title}-&gt;{dtt}={mult}&quot;)&#10;            total *= mult&#10;        return total, reasons&#10;&#10;    def effectiveness(self, move_id: str, attacker_species: Optional[str], defender_species: Optional[str],&#10;                       is_terastallized: bool = False, attacker_tera_type: Optional[str] = None) -&gt; Tuple[float, List[str]]:&#10;        mtype = self.move_type(move_id, is_terastallized, attacker_tera_type)&#10;        dtypes = self.species_types(defender_species) if defender_species else []&#10;        mult, reasons = self.type_multiplier(mtype, dtypes)&#10;        log.debug(&quot;eff: move=%s(%s) atk=%s def=%s types=%s -&gt; %.3f | %s&quot;,&#10;                  move_id, mtype, attacker_species, defender_species, dtypes, mult, &quot;; &quot;.join(reasons))&#10;        return mult, reasons&#10;&#10;# Singleton-ish so UI can just import and use&#10;_instance: Optional[TypeCalc] = None&#10;&#10;def _auto_data_dir() -&gt; Path:&#10;    root = Path(__file__).resolve().parent.parent  # project root (utils/..)&#10;    candidates = [&#10;        root / 'tools' / 'Data' / 'showdown',&#10;        root / 'showdown',&#10;        root / 'tools' / 'showdown',&#10;        root / 'Resources' / 'showdown',&#10;    ]&#10;    env = os.getenv('POKECHAD_SHOWDOWN_DIR')&#10;    if env:&#10;        p = Path(env)&#10;        if (p / 'moves.json').exists() or (p / 'pokedex.json').exists():&#10;            return p&#10;    for c in candidates:&#10;        if (c / 'moves.json').exists() or (c / 'pokedex.json').exists():&#10;            return c&#10;    return candidates[0]&#10;&#10;def init_typecalc(data_dir: Path | str) -&gt; TypeCalc:&#10;    global _instance&#10;    try:&#10;        sd = ShowdownData(Path(data_dir))&#10;    except Exception as e:&#10;        log.warning(&quot;ShowdownData init failed: %s. Falling back to built-in chart only.&quot;, e)&#10;        sd = None&#10;    _instance = TypeCalc(sd)&#10;    log.info(&quot;TypeCalc initialized. Data present: moves=%s pokedex=%s typechart=%s&quot;,&#10;             bool(sd and sd.moves), bool(sd and sd.pokedex), bool(sd and sd.typechart))&#10;    return _instance&#10;&#10;def get() -&gt; TypeCalc:&#10;    global _instance&#10;    if _instance is None:&#10;        _instance = init_typecalc(_auto_data_dir())&#10;    return _instance&#10;&#10;def install_logging_hook():&#10;    # Called from tk_main_menu.py (or anywhere) to ensure file logging exists&#10;    import logging, os&#10;    from pathlib import Path&#10;    logs = Path(os.getenv(&quot;POKECHAD_LOG_DIR&quot;, &quot;logs&quot;))&#10;    logs.mkdir(parents=True, exist_ok=True)&#10;    fh = logging.FileHandler(logs / &quot;typecalc_debug.log&quot;, encoding=&quot;utf-8&quot;)&#10;    fmt = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)&#10;    fh.setFormatter(fmt)&#10;    root = logging.getLogger(&quot;typecalc&quot;)&#10;    if not any(isinstance(h, logging.FileHandler) for h in root.handlers):&#10;        root.addHandler(fh)&#10;    root.setLevel(logging.DEBUG)&#10;    return root&#10;'''&#10;&#10;UI_STITCH = r&quot;&quot;&quot;&#10;# --- injected by fix_type_effectiveness.py (safe no-op if repeated) ---&#10;try:&#10;    from utils.type_effectiveness import install_logging_hook, init_typecalc&#10;    from pathlib import Path&#10;    import os&#10;    install_logging_hook()&#10;    # Dynamic showdown data dir discovery&#10;    _root = Path(__file__).resolve().parent.parent&#10;    _cands = [&#10;        Path(os.getenv('POKECHAD_SHOWDOWN_DIR', '')),&#10;        _root / 'tools' / 'Data' / 'showdown',&#10;        _root / 'showdown',&#10;        _root / 'tools' / 'showdown',&#10;        _root / 'Resources' / 'showdown',&#10;    ]&#10;    _chosen = None&#10;    for _c in _cands:&#10;        if _c and ( (_c / 'moves.json').exists() or (_c / 'pokedex.json').exists() ):&#10;            _chosen = _c; break&#10;    if _chosen is None:&#10;        _chosen = _cands[1]&#10;    init_typecalc(_chosen)&#10;except Exception as _typecalc_e:&#10;    import logging&#10;    logging.getLogger('typecalc').warning('Could not install typecalc logging: %s', _typecalc_e)&#10;# --- end injection ---&#10;&quot;&quot;&quot;&#10;&#10;def write_utils(data_dir: Path) -&gt; None:&#10;    ensure_dir(UTILS_DIR)&#10;    # showdown_loader.py&#10;    (UTILS_DIR / &quot;showdown_loader.py&quot;).write_text(SHOWDOWN_LOADER, encoding=&quot;utf-8&quot;)&#10;    # type_effectiveness.py&#10;    (UTILS_DIR / &quot;type_effectiveness.py&quot;).write_text(TYPE_EFFECT, encoding=&quot;utf-8&quot;)&#10;&#10;def try_patch_ui() -&gt; str:&#10;    if not UI_MAIN.exists():&#10;        return &quot;UI/tk_main_menu.py not found; skipped UI logging hook injection.&quot;&#10;    text = UI_MAIN.read_text(encoding=&quot;utf-8&quot;)&#10;    if &quot;utils.type_effectiveness&quot; in text and &quot;install_logging_hook&quot; in text:&#10;        return &quot;UI hook already present; no changes.&quot;&#10;    # Insert after first import block&#10;    m = re.search(r&quot;(^import .+?$|^from .+? import .+?$)(\r?\n)+&quot;, text, flags=re.M)&#10;    if m:&#10;        idx = m.end()&#10;        new_text = text[:idx] + UI_STITCH + text[idx:]&#10;    else:&#10;        new_text = UI_STITCH + text&#10;    UI_MAIN.write_text(new_text, encoding=&quot;utf-8&quot;)&#10;    return &quot;Injected logging hook into UI/tk_main_menu.py.&quot;&#10;&#10;def main():&#10;    ap = argparse.ArgumentParser()&#10;    ap.add_argument(&quot;--apply&quot;, action=&quot;store_true&quot;, help=&quot;Write utils and inject UI hook&quot;)&#10;    ap.add_argument(&quot;--data-dir&quot;, default=str(DEFAULT_DATA_DIR), help=&quot;Path to showdown data dir (json preferred)&quot;)&#10;    # Parse args normally&#10;    args = ap.parse_args()&#10;&#10;    # If launched with no extra arguments (e.g., from PyCharm Run button), auto-enable --apply&#10;    if len(sys.argv) == 1:&#10;        args.apply = True&#10;        print(&quot;[info] No CLI args provided; defaulting to --apply for convenience (PyCharm auto-run mode).&quot;)&#10;&#10;    ensure_dir(LOGS_DIR)&#10;&#10;    # If user supplied --data-dir but it does not exist, warn and try auto-detect&#10;    supplied = Path(args.data_dir)&#10;    if not ((supplied / 'moves.json').exists() or (supplied / 'pokedex.json').exists()):&#10;        auto = _find_showdown_data_dir(ROOT)&#10;        print(f&quot;[warn] Provided --data-dir {supplied} missing expected JSON; using {auto}&quot;)&#10;        args.data_dir = str(auto)&#10;&#10;    if not args.apply:&#10;        print(&quot;Dry run. Would create:&quot;)&#10;        print(f&quot; - {UTILS_DIR / 'showdown_loader.py'}&quot;)&#10;        print(f&quot; - {UTILS_DIR / 'type_effectiveness.py'}&quot;)&#10;        print(&quot;Then try to inject a tiny logging hook into UI/tk_main_menu.py&quot;)&#10;        print(f&quot;Data dir assumed at: {args.data_dir}&quot;)&#10;        return&#10;&#10;    write_utils(Path(args.data_dir))&#10;    msg = try_patch_ui()&#10;    print(msg)&#10;    print(&quot;Done. Re-run your app and watch logs/typecalc_debug.log to see per-move multipliers.&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/self_test_typechart.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/self_test_typechart.py" />
              <option name="updatedContent" value="from Data.poke_env_moves_info import MovesInfo&#10;&#10;EXPECTED = [&#10;    (&quot;Dark&quot;,&quot;Fairy&quot;,0.5),&#10;    (&quot;Fairy&quot;,&quot;Dark&quot;,2.0),&#10;    (&quot;Fire&quot;,&quot;Grass&quot;,2.0),&#10;    (&quot;Fire&quot;,&quot;Water&quot;,0.5),&#10;    (&quot;Water&quot;,&quot;Fire&quot;,2.0),&#10;    (&quot;Fighting&quot;,&quot;Ghost&quot;,0.0),&#10;    (&quot;Ghost&quot;,&quot;Normal&quot;,0.0),&#10;    (&quot;Fire&quot;,&quot;Ground&quot;,1.0),&#10;    (&quot;Fire&quot;,&quot;Poison&quot;,1.0),&#10;]&#10;&#10;&#10;def run_self_test(gen: int = 9) -&gt; int:&#10;    mi = MovesInfo(gen)&#10;    tc = mi.get_type_chart()&#10;    fails = []&#10;    for atk, dfd, exp in EXPECTED:&#10;        got = tc.get(atk, {}).get(dfd)&#10;        if got is None:&#10;            fails.append(f&quot;MISSING {atk}-&gt;{dfd} (expected {exp})&quot;)&#10;        elif abs(got - exp) &gt; 1e-9:&#10;            fails.append(f&quot;WRONG {atk}-&gt;{dfd}: got {got} expected {exp}&quot;)&#10;    # Clodsire neutrality check (Poison/Ground vs Fire)&#10;    fire_vs_clodsire = tc.get('Fire', {}).get('Poison', 1.0) * tc.get('Fire', {}).get('Ground', 1.0)&#10;    if abs(fire_vs_clodsire - 1.0) &gt; 1e-9:&#10;        fails.append(f&quot;WRONG Fire vs Clodsire (Poison/Ground) composite: {fire_vs_clodsire} expected 1.0&quot;)&#10;&#10;    print(&quot;Type Chart Self-Test&quot;)&#10;    print(&quot;====================&quot;)&#10;    for atk, dfd, exp in EXPECTED:&#10;        print(f&quot;{atk:9s} -&gt; {dfd:7s} = {tc.get(atk, {}).get(dfd)} (expected {exp})&quot;)&#10;    print(f&quot;Fire vs Clodsire (Poison/Ground) composite = {fire_vs_clodsire} (expected 1.0)&quot;)&#10;&#10;    if fails:&#10;        print(&quot;\nFAILURES:&quot;)&#10;        for f in fails:&#10;            print(&quot; -&quot;, f)&#10;        return 1&#10;    print(&quot;\nAll checks passed.&quot;)&#10;    return 0&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    code = run_self_test()&#10;    raise SystemExit(code)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tools/self_play.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tools/self_play.py" />
              <option name="originalContent" value="&quot;&quot;&quot;Self-play API used by weight_tuner.&#10;&#10;Runs offline simulated battles between two StockfishModel configurations.&#10;&#10;We keep this lightweight and headless; no UI, no network ladder. Uses poke-env local battle simulation&#10;if available; if not, raises a clear error.&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;import asyncio&#10;import random&#10;from dataclasses import dataclass&#10;from typing import Dict, Optional, List, Iterable&#10;    from poke_env.ps_client.server_configuration import ShowdownServerConfiguration  # type: ignore&#10;    from poke_env.ps_client.server_configuration import ShowdownServerConfiguration  # type: ignore&#10;    from poke_env.ps_client.server_configuration import ShowdownServerConfiguration  # type: ignore&#10;    from poke_env.ps_client.server_configuration import ShowdownServerConfiguration  # type: ignore&#10;    from poke_env.ps_client.server_configuration import ShowdownServerConfiguration  # type: ignore&#10;    random.seed(seed)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;Self-play API used by weight_tuner.&#10;&#10;Runs offline simulated battles between two StockfishModel configurations.&#10;&#10;We keep this lightweight and headless; no UI, no network ladder. Uses poke-env local battle simulation&#10;if available; if not, raises a clear error.&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;import asyncio&#10;import random&#10;from dataclasses import dataclass&#10;from typing import Dict, Optional, List, Iterable&#10;import math&#10;&#10;from Models.stockfish_model import StockfishModel, StockfishPokeEnvPlayer  # type: ignore&#10;&#10;try:&#10;    from poke_env.ps_client.server_configuration import ShowdownServerConfiguration, LocalhostServerConfiguration  # type: ignore&#10;except Exception:&#10;    ShowdownServerConfiguration = None  # type: ignore&#10;    LocalhostServerConfiguration = None  # type: ignore&#10;&#10;@dataclass&#10;class BattleResult:&#10;    seed: int&#10;    winner: Optional[str]&#10;    p1_won: Optional[bool]&#10;    n_turns: int&#10;    error: Optional[str] = None&#10;&#10;# ---------------- Offline heuristic simulation (no network) -----------------&#10;_DEF_COEFFS = [&#10;    ('expected_mult', 1.0),&#10;    ('go_first_bonus', 0.6),&#10;    ('opp_dmg_penalty', 0.9),&#10;    ('effectiveness_mult', 0.4),&#10;    ('accuracy_mult', 0.3),&#10;    ('ko_bonus', 0.7),&#10;    ('switch_outgoing_mult', 0.5),&#10;    ('switch_incoming_penalty', 0.7),&#10;    ('survival_bonus', 0.4),&#10;]&#10;&#10;def _score_weights(w: Dict[str,float]) -&gt; float:&#10;    return sum(float(w.get(k,0.0))*c for k,c in _DEF_COEFFS)&#10;&#10;def _simulate_offline(seed: int, w1: Dict[str,float], w2: Dict[str,float]) -&gt; BattleResult:&#10;    rng = random.Random(seed)&#10;    base1 = _score_weights(w1)&#10;    base2 = _score_weights(w2)&#10;    # Normalize by number of coeffs&#10;    base1 /= len(_DEF_COEFFS)&#10;    base2 /= len(_DEF_COEFFS)&#10;    turns = 40&#10;    advantage = 0.0&#10;    for t in range(turns):&#10;        # Add small stochastic fluctuation each turn&#10;        fluct = rng.gauss(0, 0.15)&#10;        # Dynamic aggression scaling late game&#10;        phase = t / turns&#10;        adv_turn = (base1 - base2) * (0.6 + 0.8*phase) + fluct&#10;        advantage += adv_turn&#10;        # Early termination if decisive lead (simple heuristic)&#10;        if abs(advantage) &gt; 5.0:&#10;            break&#10;    winner = 'p1' if advantage &gt; 0 else 'p2'&#10;    return BattleResult(seed=seed, winner=winner, p1_won=(advantage&gt;0), n_turns=t+1)&#10;&#10;# ---------------- Network (poke-env) simulation -----------------&#10;async def _play_one(seed: int, format_id: str, w1: Dict[str, float], w2: Dict[str, float], max_turns: int = 300, *, offline: bool=False) -&gt; BattleResult:&#10;    if offline:&#10;        return _simulate_offline(seed, w1, w2)&#10;    random.seed(seed)&#10;    try:&#10;        server_conf = ShowdownServerConfiguration  # type: ignore&#10;        p1 = StockfishPokeEnvPlayer(battle_format=format_id, server_configuration=server_conf)&#10;        p2 = StockfishPokeEnvPlayer(battle_format=format_id, server_configuration=server_conf)&#10;        p1.engine.set_weights(w1)&#10;        p2.engine.set_weights(w2)&#10;        battle = await p1.battle_against(p2, n_battles=1)&#10;        turns = getattr(battle, 'turn', 0) or 0&#10;        winner = None&#10;        p1_won = None&#10;        if getattr(battle, 'won', None) is True:&#10;            winner = 'p1'; p1_won = True&#10;        elif getattr(battle, 'won', None) is False:&#10;            winner = 'p2'; p1_won = False&#10;        else:&#10;            if getattr(battle, 'player_username', None) == getattr(battle, 'winner', None):&#10;                winner = 'p1'; p1_won = True&#10;        return BattleResult(seed=seed, winner=winner, p1_won=p1_won, n_turns=turns)&#10;    except Exception as e:&#10;        return BattleResult(seed=seed, winner=None, p1_won=None, n_turns=0, error=str(e))&#10;&#10;async def self_play_series(format_id: str, seeds: Iterable[int], w1: Dict[str, float], w2: Dict[str, float], *, offline: bool=False) -&gt; List[BattleResult]:&#10;    results: List[BattleResult] = []&#10;    for s in seeds:&#10;        r = await _play_one(s, format_id, w1, w2, offline=offline)&#10;        results.append(r)&#10;    return results&#10;&#10;def run_self_play(format_id: str, seeds: List[int], w1: Dict[str, float], w2: Dict[str, float], *, offline: bool=False) -&gt; List[BattleResult]:&#10;    &quot;&quot;&quot;Synchronous wrapper.&quot;&quot;&quot;&#10;    return asyncio.run(self_play_series(format_id, seeds, w1, w2, offline=offline))&#10;&#10;__all__ = [&#10;    'BattleResult', 'run_self_play'&#10;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tools/weight_spaces.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tools/weight_spaces.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;Definitions of weight search space for evolutionary tuner.&#10;&#10;Bounds kept generous but finite to avoid runaway explosion.&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;from typing import Dict, Tuple&#10;&#10;# Inclusive min, max for each tunable weight&#10;WEIGHT_BOUNDS: Dict[str, Tuple[float, float]] = {&#10;    'expected_mult': (0.0, 3.0),&#10;    'go_first_bonus': (0.0, 2.0),&#10;    'opp_dmg_penalty': (0.0, 3.0),&#10;    'survival_bonus': (0.0, 3.0),&#10;    'accuracy_mult': (0.0, 2.0),&#10;    'effectiveness_mult': (0.0, 2.5),&#10;    'ko_bonus': (0.0, 3.0),&#10;    'switch_outgoing_mult': (0.0, 3.0),&#10;    'switch_incoming_penalty': (0.0, 3.0),&#10;}&#10;&#10;DEFAULT_MUTATION_SCALE: Dict[str, float] = {&#10;    k: (bounds[1]-bounds[0]) * 0.15 for k, bounds in WEIGHT_BOUNDS.items()&#10;}&#10;&#10;SEARCH_KEYS = list(WEIGHT_BOUNDS.keys())&#10;&#10;__all__ = ['WEIGHT_BOUNDS','DEFAULT_MUTATION_SCALE','SEARCH_KEYS']&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tools/weight_tuner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tools/weight_tuner.py" />
              <option name="originalContent" value="&quot;&quot;&quot;Evolutionary weight tuner for StockfishModel evaluation function.&#10;&#10;Usage:&#10;  python tools/weight_tuner.py \&#10;      --format gen9randombattle \&#10;      --population 32 \&#10;      --generations 50 \&#10;      --seeds 32 \&#10;      --out Models/weights.json&#10;&#10;Strategy:&#10;  (1+λ) style ES around current champion (loaded from --out or defaults).&#10;  Each generation: sample λ mutation candidates, evaluate vs champion across paired seeds; keep best.&#10;  If best beats champion by margin &gt; epsilon (binomial lower CI), promote.&#10;  Adaptive sigma: shrink on no-improvement, expand on improvement streak.&#10;&#10;Logs:&#10;  - JSONL per candidate in logs/weight_tuning.jsonl&#10;  - Champion snapshots: Models/weights_champion_&lt;timestamp&gt;.json (when improved)&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;import argparse, json, math, random, time&#10;from pathlib import Path&#10;from typing import Dict, List, Tuple&#10;&#10;from Models.stockfish_model import StockfishModel  # type: ignore&#10;from tools.weight_spaces import WEIGHT_BOUNDS, DEFAULT_MUTATION_SCALE, SEARCH_KEYS&#10;from tools.self_play import run_self_play&#10;&#10;LOG_DIR = Path('logs')&#10;            pass&#10;    return dict(engine._W)  # type: ignore&#10;&#10;&#10;def clip_weights(w: Dict[str, float]) -&gt; Dict[str, float]:&#10;    for k,(lo,hi) in WEIGHT_BOUNDS.items():&#10;        if k in w:&#10;            if w[k] &lt; lo: w[k]=lo&#10;            elif w[k] &gt; hi: w[k]=hi&#10;    return w&#10;&#10;&#10;def mutate(base: Dict[str,float], sigma_scale: float, rng: random.Random) -&gt; Dict[str,float]:&#10;    child = dict(base)&#10;    for k in SEARCH_KEYS:&#10;        lo,hi = WEIGHT_BOUNDS[k]&#10;        scale = DEFAULT_MUTATION_SCALE[k] * sigma_scale&#10;        child[k] = child.get(k,0.0) + rng.gauss(0.0, scale)&#10;        if child[k] &lt; lo: child[k] = lo&#10;        if child[k] &gt; hi: child[k] = hi&#10;    return child&#10;&#10;&#10;def evaluate_candidate(format_id: str, seeds: List[int], champion: Dict[str,float], candidate: Dict[str,float]) -&gt; Tuple[float,int,int]:&#10;    # Candidate as P1 vs champion as P2, then swap (paired seeds)&#10;    results_forward = run_self_play(format_id, seeds, candidate, champion)&#10;    results_reverse = run_self_play(format_id, seeds, champion, candidate)&#10;def evaluate_candidate(format_id: str, seeds: List[int], champion: Dict[str,float], candidate: Dict[str,float]) -&gt; Tuple[float,int,int]:&#10;    for r in results_forward:&#10;    results_forward = run_self_play(format_id, seeds, candidate, champion)&#10;    results_reverse = run_self_play(format_id, seeds, champion, candidate)&#10;def evaluate_candidate(format_id: str, seeds: List[int], champion: Dict[str,float], candidate: Dict[str,float]) -&gt; Tuple[float,int,int]:&#10;    for r in results_reverse:&#10;    results_forward = run_self_play(format_id, seeds, candidate, champion)&#10;    results_reverse = run_self_play(format_id, seeds, champion, candidate)&#10;def evaluate_candidate(format_id: str, seeds: List[int], champion: Dict[str,float], candidate: Dict[str,float]) -&gt; Tuple[float,int,int]:&#10;        games += 1&#10;    results_forward = run_self_play(format_id, seeds, candidate, champion)&#10;    results_reverse = run_self_play(format_id, seeds, champion, candidate)&#10;&#10;&#10;    denom = 1 + z*z/n&#10;    centre = p + z*z/(2*n)&#10;    adj = z*math.sqrt((p*(1-p) + z*z/(4*n))/n)&#10;    lower = (centre - adj)/denom&#10;def main():&#10;    ap = argparse.ArgumentParser(description='Evolutionary tuner for evaluation weights.')&#10;    ap.add_argument('--format', default='gen9randombattle')&#10;    ap.add_argument('--population', type=int, default=32)&#10;    ap.add_argument('--sigma', type=float, default=1.0, help='Initial sigma scale multiplier')&#10;    ap.add_argument('--patience', type=int, default=10, help='Generations without improvement before stop')&#10;    ap.add_argument('--min-promote-diff', type=float, default=0.02, help='Minimum raw win-rate advantage required to consider promotion')&#10;    ap.add_argument('--confidence', type=float, default=0.95, help='Confidence for Wilson lower bound on improvement')&#10;    ap.add_argument('--seed', type=int, default=0)&#10;    args = ap.parse_args()&#10;&#10;    rng = random.Random(args.seed or int(time.time()))&#10;&#10;    out_path = Path(args.out)&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;&#10;    # Pre-generate seed list&#10;    base_seeds = [rng.randint(1, 1_000_000_000) for _ in range(args.seeds)]&#10;&#10;    log_path = LOG_DIR / 'weight_tuning.jsonl'&#10;&#10;            with open(log_path, 'a', encoding='utf-8') as f:&#10;                f.write(json.dumps(obj) + '\n')&#10;    no_improve = 0&#10;    champion_wr = 0.5  # baseline expectation; updated on promotions&#10;&#10;    print(f&quot;[init] Champion weights: {champion}&quot;)&#10;    log_event({'event':'init','champion':champion})&#10;        gen += 1&#10;        candidates: List[Tuple[Dict[str,float], float, int, int]] = []&#10;            log_event({'event':'candidate','generation':gen,'idx':i,'weights':cand,'win_rate':wr,'wins':wins,'games':games,'sigma':sigma})&#10;            print(f&quot;[gen {gen}] cand {i} wr={wr:.3f} wins={wins}/{games} sigma={sigma:.3f}&quot;)&#10;        # Select best&#10;        candidates.sort(key=lambda t: t[1], reverse=True)&#10;    log_event({'event':'init','champion':champion})&#10;            z = 1.96 if args.confidence &gt;= 0.95 else 1.645&#10;        if promote:&#10;            timestamp = time.strftime('%Y%m%d-%H%M%S')&#10;            backup = out_path.with_name(f&quot;weights_champion_{timestamp}.json&quot;)&#10;            wr, wins, games = evaluate_candidate(args.format, base_seeds, champion, cand)&#10;                with open(backup,'w',encoding='utf-8') as f: json.dump(best, f, indent=2)&#10;            log_event({'event':'candidate','generation':gen,'idx':i,'weights':cand,'win_rate':wr,'wins':wins,'games':games,'sigma':sigma})&#10;            try:&#10;                with open(out_path,'w',encoding='utf-8') as f: json.dump(best, f, indent=2)&#10;            except Exception: pass&#10;    log_event({'event':'init','champion':champion})&#10;            no_improve = 0&#10;            sigma = min(sigma * 1.1, 3.0)&#10;            log_event({'event':'promote','generation':gen,'new_champion':champion,'champion_wr':champion_wr,'backup':str(backup)})&#10;            log_event({'event':'no_improve','generation':gen,'best_wr':best_wr,'diff':diff,'no_improve':no_improve,'sigma':sigma})&#10;            print(f&quot;[gen {gen}] no improvement best_wr={best_wr:.3f} diff={diff:.3f} no_improve={no_improve} sigma-&gt;{sigma:.3f}&quot;)&#10;&#10;            wr, wins, games = evaluate_candidate(args.format, base_seeds, champion, cand)&#10;    log_event({'event':'done','generations':gen,'final_champion':champion,'champion_wr':champion_wr})&#10;            log_event({'event':'candidate','generation':gen,'idx':i,'weights':cand,'win_rate':wr,'wins':wins,'games':games,'sigma':sigma})&#10;if __name__ == '__main__':&#10;    main()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;Evolutionary weight tuner for StockfishModel evaluation function.&#10;&#10;Usage:&#10;  python tools/weight_tuner.py \&#10;      --format gen9randombattle \&#10;      --population 32 \&#10;      --generations 50 \&#10;      --seeds 32 \&#10;      --out Models/weights.json&#10;&#10;Strategy:&#10;  (1+λ) style ES around current champion (loaded from --out or defaults).&#10;  Each generation: sample λ mutation candidates, evaluate vs champion across paired seeds; keep best.&#10;  If best beats champion by margin &gt; epsilon (binomial lower CI), promote.&#10;  Adaptive sigma: shrink on no-improvement, expand on improvement streak.&#10;&#10;Logs:&#10;  - JSONL per candidate in logs/weight_tuning.jsonl&#10;  - Champion snapshots: Models/weights_champion_&lt;timestamp&gt;.json (when improved)&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;import argparse, json, math, random, time&#10;from pathlib import Path&#10;from typing import Dict, List, Tuple&#10;&#10;from Models.stockfish_model import StockfishModel  # type: ignore&#10;from tools.weight_spaces import WEIGHT_BOUNDS, DEFAULT_MUTATION_SCALE, SEARCH_KEYS&#10;from tools.self_play import run_self_play&#10;&#10;# Reintroduce log directory constant (was removed during refactor)&#10;from pathlib import Path as _P&#10;# LOG_DIR relative to repo root, not CWD&#10;_BASE_DIR = _P(__file__).resolve().parent.parent&#10;LOG_DIR = _BASE_DIR / 'logs'&#10;LOG_DIR.mkdir(exist_ok=True)&#10;&#10;&#10;def load_champion(path: Path) -&gt; Dict[str, float]:&#10;    engine = StockfishModel()&#10;    if path.exists():&#10;        try:&#10;            with open(path, 'r', encoding='utf-8') as f:&#10;                raw = json.load(f)&#10;            if isinstance(raw, dict):&#10;                engine.set_weights(raw)&#10;        except Exception:&#10;            pass&#10;    return dict(engine._W)  # type: ignore&#10;&#10;&#10;def clip_weights(w: Dict[str, float]) -&gt; Dict[str, float]:&#10;    for k,(lo,hi) in WEIGHT_BOUNDS.items():&#10;        if k in w:&#10;            if w[k] &lt; lo: w[k]=lo&#10;            elif w[k] &gt; hi: w[k]=hi&#10;    return w&#10;&#10;&#10;def mutate(base: Dict[str,float], sigma_scale: float, rng: random.Random) -&gt; Dict[str,float]:&#10;    child = dict(base)&#10;    for k in SEARCH_KEYS:&#10;        lo,hi = WEIGHT_BOUNDS[k]&#10;        scale = DEFAULT_MUTATION_SCALE[k] * sigma_scale&#10;        child[k] = child.get(k,0.0) + rng.gauss(0.0, scale)&#10;        if child[k] &lt; lo: child[k] = lo&#10;        if child[k] &gt; hi: child[k] = hi&#10;    return child&#10;&#10;&#10;def evaluate_candidate(format_id: str, seeds: List[int], champion: Dict[str,float], candidate: Dict[str,float], *, offline: bool) -&gt; Tuple[float,int,int]:&#10;    # Candidate as P1 vs champion as P2, then swap (paired seeds)&#10;    results_forward = run_self_play(format_id, seeds, candidate, champion, offline=offline)&#10;    results_reverse = run_self_play(format_id, seeds, champion, candidate, offline=offline)&#10;    wins = 0; games = 0&#10;    for r in results_forward:&#10;        if r.p1_won is True: wins += 1&#10;        elif r.p1_won is None: pass&#10;        games += 1&#10;    for r in results_reverse:&#10;        if r.p1_won is False:  # champion as p1 lost =&gt; candidate won as p2&#10;            wins += 1&#10;        elif r.p1_won is None: pass&#10;        games += 1&#10;        # If repeated network errors, break early&#10;        if r.error and 'ConnectionRefusedError' in (r.error or ''):&#10;            break&#10;    win_rate = wins / games if games else 0.0&#10;    return win_rate, wins, games&#10;&#10;&#10;def proportion_ci_lower(p: float, n: int, z: float = 1.96) -&gt; float:&#10;    if n == 0: return 0.0&#10;    # Wilson lower bound&#10;    denom = 1 + z*z/n&#10;    centre = p + z*z/(2*n)&#10;    adj = z*math.sqrt((p*(1-p) + z*z/(4*n))/n)&#10;    lower = (centre - adj)/denom&#10;    return lower&#10;&#10;&#10;def main():&#10;    ap = argparse.ArgumentParser(description='Evolutionary tuner for evaluation weights.')&#10;    ap.add_argument('--format', default='gen9randombattle')&#10;    ap.add_argument('--population', type=int, default=32)&#10;    ap.add_argument('--generations', type=int, default=50)&#10;    ap.add_argument('--seeds', type=int, default=32, help='Number of base seeds (each used twice: forward+reverse)')&#10;    ap.add_argument('--out', default='Models/weights.json')&#10;    ap.add_argument('--sigma', type=float, default=1.0, help='Initial sigma scale multiplier')&#10;    ap.add_argument('--patience', type=int, default=10, help='Generations without improvement before stop')&#10;    ap.add_argument('--min-promote-diff', type=float, default=0.02, help='Minimum raw win-rate advantage required to consider promotion')&#10;    ap.add_argument('--confidence', type=float, default=0.95, help='Confidence for Wilson lower bound on improvement')&#10;    ap.add_argument('--seed', type=int, default=0)&#10;    # Default is offline self-play; use --online to force remote Showdown server&#10;    ap.add_argument('--online', action='store_true', help='Use online Showdown server (default offline self-play).')&#10;    # Backwards compatibility flag (ignored; offline is default)&#10;    ap.add_argument('--offline', action='store_true', help=argparse.SUPPRESS)&#10;    args = ap.parse_args()&#10;&#10;    rng = random.Random(args.seed or int(time.time()))&#10;&#10;    out_path = Path(args.out)&#10;    if not out_path.is_absolute():&#10;        out_path = _BASE_DIR / out_path&#10;    out_path.parent.mkdir(parents=True, exist_ok=True)&#10;&#10;    champion = load_champion(out_path)&#10;    base_sigma = args.sigma&#10;    sigma = base_sigma&#10;&#10;    # Pre-generate seed list&#10;    base_seeds = [rng.randint(1, 1_000_000_000) for _ in range(args.seeds)]&#10;&#10;    log_path = LOG_DIR / 'weight_tuning.jsonl'&#10;&#10;    def log_event(obj: Dict):&#10;        try:&#10;            with open(log_path, 'a', encoding='utf-8') as f:&#10;                f.write(json.dumps(obj) + '\n')&#10;        except Exception:&#10;            pass&#10;&#10;    gen = 0&#10;    no_improve = 0&#10;    champion_wr = 0.5  # baseline expectation; updated on promotions&#10;&#10;    print(f&quot;[init] Champion weights: {champion}&quot;)&#10;    offline_flag = not args.online  # offline by default unless --online supplied&#10;    log_event({'event':'init','champion':champion, 'offline': offline_flag, 'format': args.format, 'out': str(out_path), 'seeds': len(base_seeds)*2, 'sigma': sigma})&#10;&#10;    while gen &lt; args.generations and no_improve &lt; args.patience:&#10;        gen += 1&#10;        gen_start_time = time.time()&#10;        # Log generation start snapshot&#10;        log_event({'event':'gen_start','generation':gen,'champion_wr':champion_wr,'champion':champion,'sigma':sigma,'offline':offline_flag})&#10;        candidates: List[Tuple[Dict[str,float], float, int, int]] = []&#10;        for i in range(args.population):&#10;            cand = mutate(champion, sigma, rng)&#10;            wr, wins, games = evaluate_candidate(args.format, base_seeds, champion, cand, offline=offline_flag)&#10;            candidates.append((cand, wr, wins, games))&#10;            log_event({'event':'candidate','generation':gen,'idx':i,'weights':cand,'win_rate':wr,'wins':wins,'games':games,'sigma':sigma,'champion_wr_at_gen_start':champion_wr,'offline':offline_flag})&#10;            print(f&quot;[gen {gen}] cand {i} wr={wr:.3f} wins={wins}/{games} sigma={sigma:.3f}&quot;)&#10;        # Select best&#10;        candidates.sort(key=lambda t: t[1], reverse=True)&#10;        best, best_wr, best_wins, best_games = candidates[0]&#10;        diff = best_wr - champion_wr&#10;        promote = False&#10;        if diff &gt;= args.min_promote_diff:&#10;            z = 1.96 if args.confidence &gt;= 0.95 else 1.645&#10;            lower = proportion_ci_lower(best_wr, best_games, z=z)&#10;            if lower - champion_wr &gt;= 0:&#10;                promote = True&#10;        gen_seconds = time.time() - gen_start_time&#10;        if promote:&#10;            timestamp = time.strftime('%Y%m%d-%H%M%S')&#10;            backup = out_path.with_name(f&quot;weights_champion_{timestamp}.json&quot;)&#10;            try:&#10;                with open(backup,'w',encoding='utf-8') as f: json.dump(best, f, indent=2)&#10;            except Exception: pass&#10;            try:&#10;                with open(out_path,'w',encoding='utf-8') as f: json.dump(best, f, indent=2)&#10;            except Exception: pass&#10;            prev_champ = champion&#10;            champion = best&#10;            champion_wr = best_wr&#10;            no_improve = 0&#10;            sigma = min(sigma * 1.1, 3.0)&#10;            log_event({&#10;                'event':'promote',&#10;                'generation':gen,&#10;                'new_champion':champion,&#10;                'prev_champion': prev_champ,&#10;                'champion_wr':champion_wr,&#10;                'backup':str(backup),&#10;                'gen_seconds':gen_seconds,&#10;                'sigma':sigma,&#10;                'offline':offline_flag,&#10;                'wins': int(best_wins),&#10;                'games': int(best_games),&#10;                'win_rate': float(best_wr),&#10;                'diff': float(diff),&#10;                'format': args.format,&#10;                'seeds': len(base_seeds)*2,&#10;            })&#10;            print(f&quot;[gen {gen}] PROMOTION wr={best_wr:.3f} diff={diff:.3f} sigma-&gt;{sigma:.3f} time={gen_seconds:.1f}s&quot;)&#10;        else:&#10;            no_improve += 1&#10;            sigma = max(sigma * 0.9, 0.05)&#10;            log_event({'event':'no_improve','generation':gen,'best_wr':best_wr,'diff':diff,'no_improve':no_improve,'sigma':sigma,'gen_seconds':gen_seconds,'offline':offline_flag})&#10;            print(f&quot;[gen {gen}] no improvement best_wr={best_wr:.3f} diff={diff:.3f} no_improve={no_improve} sigma-&gt;{sigma:.3f} time={gen_seconds:.1f}s&quot;)&#10;&#10;    print(f&quot;[done] generations={gen} final_champion_wr={champion_wr:.3f} weights={champion}&quot;)&#10;    log_event({'event':'done','generations':gen,'final_champion':champion,'champion_wr':champion_wr,'offline':offline_flag,'sigma':sigma,'format':args.format})&#10;&#10;if __name__ == '__main__':&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>