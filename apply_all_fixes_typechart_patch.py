#!/usr/bin/env python3
"""
Patch the 'think' mapping so runtime values (PP/HP/accuracy/type/category/spread)
are derived correctly from the Showdown request and PS dex.

What this script does (idempotent; .bak backups with timestamp):
  1) Writes Data/think_helpers.py with:
        - parse_condition()
        - normalize_accuracy()
        - is_spread_move()
        - resolve_move_type()
        - resolve_terablast_category()
        - enrich_moves_from_request()
  2) Patches Data/poke_env_moves_info.py to:
        - import normalize_accuracy
        - return numeric accuracy (True -> 100.0)
  3) Opportunistically patches UI/*.py to prefer live PP from request when found.

Run from repo root:
    python patch_think_runtime_mapping.py
"""

from __future__ import annotations
import os
import re
import sys
import time
from pathlib import Path

ROOT = Path(__file__).resolve().parent

HELPERS_PATH = ROOT / "Data" / "think_helpers.py"
MOVES_INFO_PATH = ROOT / "Data" / "poke_env_moves_info.py"
UI_DIR = ROOT / "UI"

TS = time.strftime("%Y%m%d-%H%M%S")


def backup(path: Path) -> None:
    bak = path.with_suffix(path.suffix + f".{TS}.bak")
    bak.write_text(path.read_text(encoding="utf-8"), encoding="utf-8")
    print(f"[backup] {path} -> {bak.name}")


HELPERS_CODE = r'''# Auto-generated by patch_think_runtime_mapping.py
from __future__ import annotations
from typing import Any, Dict, List, Optional, Sequence, Tuple

def parse_condition(cond: str) -> Dict[str, Optional[float]]:
    """
    Parse Showdown 'condition' strings like:
      "263/263" -> {"hp": 263, "max": 263, "percent": 100.0}
      "62/263"  -> {"hp": 62,  "max": 263, "percent": 23.57}
      "0 fnt"   -> {"hp": 0,   "max": None, "percent": 0.0}
    """
    if not cond:
        return {"hp": None, "max": None, "percent": None}
    s = cond.strip().lower()
    if "fnt" in s:
        return {"hp": 0, "max": None, "percent": 0.0}
    try:
        cur, mx = s.split("/", 1)
        curf = float(cur)
        mxf = float(mx)
        pct = (curf / mxf * 100.0) if mxf > 0 else None
        return {"hp": curf, "max": mxf, "percent": pct}
    except Exception:
        return {"hp": None, "max": None, "percent": None}

def normalize_accuracy(acc: Any) -> Optional[float]:
    """
    Showdown data uses:
      - number (e.g., 100, 80)
      - True (means 'always hits' for many self/status moves)
      - None/False for no accuracy (edge cases)
    We convert True -> 100.0 so downstream math behaves.
    """
    if acc is True:
        return 100.0
    if acc in (None, False):
        return None
    try:
        return float(acc)
    except Exception:
        return None

_SPREAD_TARGETS = {"alladjacent", "alladjacentfoes"}

def is_spread_move(target: Optional[str]) -> bool:
    return (target or "").replace(" ", "").lower() in _SPREAD_TARGETS

def resolve_move_type(
    move_id: str,
    static_type: Optional[str],
    attacker_types: Optional[Sequence[str]] = None,
    tera_type: Optional[str] = None,
    terastallized: bool = False,
    weather: Optional[str] = None,
) -> Optional[str]:
    """
    Handle dynamic typing for common cases. Falls back to static_type when unknown.
    """
    mid = (move_id or "").lower()
    if mid == "revelationdance":
        if attacker_types and len(attacker_types) > 0:
            return (attacker_types[0] or "NORMAL").upper()
    if mid == "terablast" and terastallized and tera_type:
        return tera_type.upper()
    if mid == "weatherball":
        if weather:
            w = weather.lower()
            if w in ("rain", "primordialsea"): return "WATER"
            if w in ("sun", "sunnyday", "desolateland"): return "FIRE"
            if w == "sandstorm": return "ROCK"
            if w in ("hail", "snow"): return "ICE"
        return "NORMAL"
    # Others like Judgment/Multi-Attack/Techno Blast need held item/plate/drive context.
    return (static_type or None if static_type else None)

def resolve_terablast_category(
    move_id: str,
    base_category: Optional[str],
    terastallized: bool,
    atk: Optional[float],
    spa: Optional[float],
) -> Optional[str]:
    if (move_id or "").lower() != "terablast":
        return base_category
    if terastallized and atk is not None and spa is not None:
        return "Physical" if atk > spa else "Special"
    return base_category

def enrich_moves_from_request(
    request_moves: List[Dict[str, Any]],
    dex_lookup_fn,
    attacker_ctx: Dict[str, Any],
    weather: Optional[str] = None,
) -> List[Dict[str, Any]]:
    """
    Given request['active'][0]['moves'] and a lookup function like:
        lambda mid: moves_info.get(mid)
    build enriched move dicts with resolved type/category/accuracy, and live PP.
    """
    out = []
    atk_types = attacker_ctx.get("types")  # Optional[List[str]], if you have it
    tera_type = attacker_ctx.get("teraType")
    terastallized = bool(attacker_ctx.get("terastallized"))
    atk_stat = attacker_ctx.get("atk")
    spa_stat = attacker_ctx.get("spa")

    for m in request_moves or []:
        mid = (m.get("id") or m.get("move") or "").replace(" ", "").lower()
        try:
            dex = dex_lookup_fn(mid)  # should return MoveInfo-like or dict with fields
            # Try attributes first (dataclass), else dict
            static_type = getattr(dex, "type", None) if hasattr(dex, "__dict__") else dex.get("type")
            base_cat = getattr(dex, "category", None) if hasattr(dex, "__dict__") else dex.get("category")
            acc_raw = getattr(dex, "accuracy", None) if hasattr(dex, "__dict__") else dex.get("accuracy")
            target = m.get("target") or (getattr(dex, "target", None) if hasattr(dex, "__dict__") else dex.get("target"))

            acc = normalize_accuracy(acc_raw)
            rtype = resolve_move_type(
                move_id=mid, static_type=static_type, attacker_types=atk_types,
                tera_type=tera_type, terastallized=terastallized, weather=weather,
            )
            rcat = resolve_terablast_category(mid, base_cat, terastallized, atk_stat, spa_stat)

            out.append({
                "id": mid,
                "name": m.get("move") or getattr(dex, "name", None) or mid,
                "type": rtype or static_type,
                "category": rcat or base_cat,
                "accuracy": acc,                   # numeric or None
                "target": target,
                "is_spread": is_spread_move(target),
                "pp": m.get("pp"),                 # LIVE PP
                "maxpp": m.get("maxpp"),           # LIVE max PP
                "base_pp": getattr(dex, "pp", None) if hasattr(dex, "__dict__") else dex.get("pp"),
                "base_power": getattr(dex, "base_power", None) if hasattr(dex, "__dict__") else (dex.get("basePower") or dex.get("base_power")),
                "raw_dex": getattr(dex, "raw", None) if hasattr(dex, "__dict__") else dex,
            })
        except Exception:
            out.append({
                "id": mid,
                "name": m.get("move") or mid,
                "type": None,
                "category": None,
                "accuracy": None,
                "target": m.get("target"),
                "is_spread": is_spread_move(m.get("target")),
                "pp": m.get("pp"),
                "maxpp": m.get("maxpp"),
                "base_pp": None,
                "base_power": None,
                "raw_dex": None,
            })
    return out
'''.rstrip() + "\n"


def write_helpers():
    HELPERS_PATH.parent.mkdir(parents=True, exist_ok=True)
    if HELPERS_PATH.exists():
        old = HELPERS_PATH.read_text(encoding="utf-8")
        # Update only if content changed
        if old.strip() == HELPERS_CODE.strip():
            print(f"[skip] {HELPERS_PATH} already up-to-date")
            return
        backup(HELPERS_PATH)
    HELPERS_PATH.write_text(HELPERS_CODE, encoding="utf-8")
    print(f"[done] wrote {HELPERS_PATH}")


def patch_moves_info():
    if not MOVES_INFO_PATH.exists():
        print(f"[skip] {MOVES_INFO_PATH} not found")
        return

    src = MOVES_INFO_PATH.read_text(encoding="utf-8")
    orig = src

    # 1) Ensure import of normalize_accuracy from Data.think_helpers
    if "from Data.think_helpers import normalize_accuracy" not in src:
        # Insert after other imports
        m = list(re.finditer(r'^(?:from\s+\S+\s+import\s+[^\n]+|import\s+\S+)\s*$', src, flags=re.M))
        insert_at = m[-1].end() if m else 0
        src = src[:insert_at] + "\nfrom Data.think_helpers import normalize_accuracy\n" + src[insert_at:]
        print("[patch] added normalize_accuracy import in poke_env_moves_info.py")

    # 2) Replace accuracy=m.get("accuracy") with normalized value
    #    Find the MoveInfo(... accuracy=... , ...) construction and normalize it
    # Weâ€™ll try two common patterns:
    patterns = [
        r"(accuracy\s*=\s*)m\.get\(\s*['\"]accuracy['\"]\s*\)",
        r"(accuracy\s*=\s*)(?P<name>[a-zA-Z_][a-zA-Z0-9_]*)\.get\(\s*['\"]accuracy['\"]\s*\)",
        r"(accuracy\s*=\s*)(?P<expr>[^,\n]+)"  # fallback - only if no normalize exists already
    ]

    if "accuracy=normalize_accuracy(" not in src:
        replaced = False
        # First try the direct 'm.get("accuracy")'
        new_src = re.sub(patterns[0], r"\1normalize_accuracy(m.get('accuracy'))", src)
        if new_src != src:
            src = new_src
            replaced = True
        else:
            # Try a variable other than m
            new_src = re.sub(patterns[1], r"\1normalize_accuracy(\g<name>.get('accuracy'))", src)
            if new_src != src:
                src = new_src
                replaced = True
            else:
                # As a last resort, if accuracy=... exists and not normalized, wrap it
                # but avoid double-wrapping
                acc_assign = re.search(r"accuracy\s*=\s*(?!normalize_accuracy\()([^,\n]+)", src)
                if acc_assign:
                    target = acc_assign.group(0)
                    expr = acc_assign.group(1).strip()
                    src = src.replace(target, f"accuracy=normalize_accuracy({expr})", 1)
                    replaced = True
        if replaced:
            print("[patch] normalized accuracy field in MoveInfo construction")
        else:
            print("[info] accuracy already normalized or pattern not found; skipping accuracy rewrite")
    else:
        print("[info] accuracy already normalized in poke_env_moves_info.py")

    if src != orig:
        backup(MOVES_INFO_PATH)
        MOVES_INFO_PATH.write_text(src, encoding="utf-8")
        print(f"[done] patched {MOVES_INFO_PATH}")
    else:
        print(f"[skip] no changes applied to {MOVES_INFO_PATH}")


def patch_ui_live_pp():
    """
    Opportunistic UI patch:
    Replace patterns that obviously render PP from a dex row with a safe live-first expression.

    Heuristic:
      - Search UI/*.py for lines like:
            something = <dex_move>.get("pp")
        and turn into:
            something = (<req_move>.get("pp") if 'req_move' in scope else <dex_move>.get("pp"))

    Because we don't know your exact variable names, we handle a few common idioms.
    If we can't find any, we simply skipâ€”your UI might already be correct or named differently.
    """
    if not UI_DIR.exists():
        print(f"[skip] UI directory not found: {UI_DIR}")
        return

    # For safety, patch only when we see both a dex move and a request move in the same function scope.
    # We'll look for lines containing 'maxpp' or 'pp' together with 'request' and 'active'.
    py_files = sorted([p for p in UI_DIR.rglob("*.py") if p.is_file()])

    total_files_patched = 0
    for path in py_files:
        src = path.read_text(encoding="utf-8")
        orig = src

        # Scoping heuristic: only attempt if the file references both 'request' and '.moves'
        if "request" not in src or ".moves" not in src:
            continue

        # Add a tiny helper at top once per file (idempotent)
        if "def _prefer_live_pp(" not in src:
            ins_point = 0
            m = list(re.finditer(r'^(?:from\s+\S+\s+import\s+[^\n]+|import\s+\S+)\s*$', src, flags=re.M))
            ins_point = (m[-1].end() if m else 0)
            helper = (
                "\n\ndef _prefer_live_pp(req_move, dex_pp):\n"
                "    try:\n"
                "        if req_move is not None:\n"
                "            live = req_move.get('pp')\n"
                "            if live is not None:\n"
                "                return live\n"
                "    except Exception:\n"
                "        pass\n"
                "    return dex_pp\n"
            )
            src = src[:ins_point] + helper + src[ins_point:]
            print(f"[patch] added _prefer_live_pp helper to {path.name}")

        # Replace obvious 'pp =' or 'pp:' assignments using dex-only with _prefer_live_pp
        # We try to find a nearby 'req_move' variable; if not present, we create a safe call with None.
        # Pattern examples we rewrite:
        #   pp = move_info.get("pp")
        #   "pp": move_info.get('pp'),
        patterns = [
            (r"(\bpp\s*=\s*)([a-zA-Z_][a-zA-Z0-9_\.]*\.get\(['\"]pp['\"]\))",
             r"\1_prefer_live_pp(req_move if 'req_move' in locals() else None, \2)"),
            (r"(['\"]pp['\"]\s*:\s*)([a-zA-Z_][a-zA-Z0-9_\.]*\.get\(['\"]pp['\"]\))",
             r"\1_prefer_live_pp(req_move if 'req_move' in locals() else None, \2)")
        ]
        changed_here = False
        for pat, rep in patterns:
            new_src = re.sub(pat, rep, src)
            if new_src != src:
                src = new_src
                changed_here = True

        if changed_here:
            backup(path)
            path.write_text(src, encoding="utf-8")
            total_files_patched += 1
            print(f"[done] patched {path}")

    if total_files_patched == 0:
        print("[info] UI: no safe live-PP replacements found (names differ or already handled)")


def main():
    print("[start] think runtime mapping patch")
    write_helpers()
    patch_moves_info()
    patch_ui_live_pp()
    print("[done] All patches attempted.\n"
          "Next steps:\n"
          "  - Import and use helpers where convenient:\n"
          "      from Data.think_helpers import parse_condition, enrich_moves_from_request\n"
          "  - For a given |request|, call enrich_moves_from_request(request['active'][0]['moves'],\n"
          "        lambda mid: MovesInfo().get(mid), attacker_ctx={\n"
          "           'types': YOUR_TYPES_OR_NONE,\n"
          "           'teraType': active.get('teraType'),\n"
          "           'terastallized': bool(active.get('terastallized')),\n"
          "           'atk': active['stats'].get('atk'), 'spa': active['stats'].get('spa'),\n"
          "        })\n"
          "  - Use parse_condition(pokemon['condition']) for accurate HP%.\n")


if __name__ == "__main__":
    main()
