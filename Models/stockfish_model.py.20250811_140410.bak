from __future__ import annotations
import json
import os





from dataclasses import dataclass


from typing import Any, Dict, List, Optional, Callable





# Import mechanics from the Data package


from Data.battle_runtime import (


    get_state,


    predict_order_for_ids,


    estimate_damage,


    would_fail,


    apply_switch_in_effects,


)


from Data.poke_env_battle_environment import snapshot as snapshot_battle


from Data.poke_env_moves_info import MovesInfo

# --- learned weights (optional) --------------------------------------------
def _load_weights(path: str = os.path.join("Models", "weights.json")) -> dict:
    try:
        with open(path, "r", encoding="utf-8") as f:
            w = json.load(f)
        # safe defaults
        return {
            "go_first_bonus": float(w.get("go_first_bonus", 0.4)),
            "opp_dmg_penalty": float(w.get("opp_dmg_penalty", 1.0)),
            "survival_bonus": float(w.get("survival_bonus", 0.0)),
        }
    except Exception:
        return {"go_first_bonus": 0.4, "opp_dmg_penalty": 1.0, "survival_bonus": 0.0}






# ---------------- helpers (local only) -----------------


def _acc_to_prob(acc) -> float:


    # poke-env accuracy can be True (100), int 0..100, float 0..1


    if acc is True:


        return 1.0


    if acc is None:


        return 1.0


    try:


        x = float(acc)


        return x / 100.0 if x > 1.0 else max(0.0, min(1.0, x))


    except Exception:


        return 1.0





def _type_mult(att_type: str, defender_types, chart: Dict[str, Dict[str, float]]) -> float:
    print(f"DEBUG: Type calc - Attack: {att_type}, Defense: {defender_types}")

    if not chart:
        print("DEBUG: No type chart available!")
        return 1.0

    # Convert to uppercase for chart lookup
    att_type_upper = att_type.upper()

    if att_type_upper not in chart:
        print(f"DEBUG: Attack type '{att_type}' (as '{att_type_upper}') not in chart. Available: {list(chart.keys())[:5]}...")
        return 1.0

    mult = 1.0
    for def_type in defender_types:
        if def_type:
            def_type_upper = def_type.upper()
            if def_type_upper in chart[att_type_upper]:
                effectiveness = chart[att_type_upper][def_type_upper]
                print(f"DEBUG: {att_type} vs {def_type} = {effectiveness}x")
                mult *= effectiveness
            else:
                print(f"DEBUG: Defense type '{def_type}' (as '{def_type_upper}') not found for {att_type}")

    print(f"DEBUG: Final effectiveness: {mult}x")
    return mult





# ---------------- Public data container -----------------


@dataclass


class ChosenAction:


    kind: str  # 'move' | 'switch'


    move_id: Optional[str] = None


    switch_species: Optional[str] = None


    debug: Dict[str, Any] | None = None





# ----------------- Core engine --------------------------


class StockfishModel:


    def __init__(self, battle_format: str = 'gen9ou'):


        self.battle_format = battle_format


        self._W = _load_weights()
        # configurable 'depth' knob the UI may tweak; we don't tree-search but keep it as a param


        self._depth = 3





    def set_depth(self, d: int):


        self._depth = int(d)





    def choose_action(self, battle: Any) -> ChosenAction:


        """Return ChosenAction and rich debug info for the UI."""


        state = get_state(battle)


        mi = MovesInfo(state.format or 9)
        type_chart = mi.get_type_chart()
        print(f"DEBUG: MovesInfo format: {state.format or 9}")
        print(f"DEBUG: Type chart size: {len(type_chart) if type_chart else 0}")
        if type_chart:
            print(f"DEBUG: Sample types: {list(type_chart.keys())[:5]}")
        print(f"DEBUG: MovesInfo initialized with format: {state.format or 9}")
        print(f"DEBUG: Type chart loaded: {bool(mi.get_type_chart())}")





        # Determine active slots for both sides


        def _active_key(side: Dict[str, Any]) -> Optional[str]:


            for k, p in side.items():


                if getattr(p, 'is_active', False):


                    return k


            for k, p in side.items():


                if (getattr(p, 'status', None) or '').lower() == 'fnt':


                    continue


                chp = getattr(p, 'current_hp', None)


                if chp is None:


                    return k


                if chp > 0:


                    return k


            return None





        my_key = _active_key(state.team.ours) if getattr(state, 'team', None) else None


        opp_key = _active_key(state.team.opponent) if getattr(state, 'team', None) else None





        legal_moves = list(getattr(battle, 'available_moves', []) or [])


        legal_switches = list(getattr(battle, 'available_switches', []) or [])


        force_switch = bool(getattr(battle, 'force_switch', False)) or (not legal_moves and bool(legal_switches))





        # Reveal opponent move ids if we know them; give a safe default


        opp_moves_known = []


        try:


            if opp_key:


                opp_ps = state.team.opponent[opp_key]


                opp_moves_known = [m.id for m in (opp_ps.moves or []) if getattr(m, "id", None)]


        except Exception:


            pass


        default_opp_move = opp_moves_known[0] if opp_moves_known else "tackle"





        # ---- Evaluate MOVES ---------------------------------------------------


        moves_eval: List[Dict[str, Any]] = []


        if not force_switch and my_key and opp_key:


            opp_ps = state.team.opponent[opp_key]


            opp_max = int(getattr(opp_ps, 'max_hp', 0) or opp_ps.stats.raw.get('hp', 1) or 1)


            for mv in legal_moves:


                mid = getattr(mv, 'id', None) or getattr(mv, 'move_id', None)


                name = getattr(mv, 'name', str(mid))


                if not mid:


                    continue





                # Filter out immediate failure (eg. sleep talk while awake)


                fail, why = False, None


                try:


                    fail, why = would_fail(str(mid), my_key, opp_key, state, mi)


                except Exception:


                    pass


                if fail:


                    moves_eval.append({


                        'id': str(mid), 'name': name, 'score': 0.0, 'expected': 0.0,


                        'acc_mult': 0.0, 'effectiveness': 0.0, 'why_blocked': str(why or 'would fail')


                    })


                    continue





                try:


                    dmg = estimate_damage(state, my_key, opp_key, str(mid), mi)


                    rolls = list(dmg.get('rolls', []) or [])


                    avg = sum(rolls) / len(rolls) if rolls else 0.0


                    eff = float(dmg.get('effectiveness', 1.0) or 1.0)

                    # Debug type effectiveness
                    move_raw = mi.raw(str(mid))
                    if move_raw:
                        move_type = move_raw.get("type", "unknown")
                        def_types = getattr(state.team.opponent[opp_key], "types", [])
                        print(f"DEBUG: Move {mid} ({move_type}) vs {def_types} = {eff}x effectiveness")

                        # Recalculate effectiveness if we have type info
                        if move_type != "unknown" and def_types and type_chart:
                            recalc_eff = _type_mult(move_type, def_types, type_chart)
                            if abs(recalc_eff - eff) > 0.01:
                                print(f"DEBUG: MISMATCH! Recalculated: {recalc_eff}x, Used: {eff}x")
                                eff = recalc_eff
                    print(f"DEBUG: Move {mid} effectiveness: {eff}, damage rolls: {rolls}")
                    # Show move type information
                    move_raw = mi.raw(str(mid))
                    move_type = move_raw.get("type", "unknown") if move_raw else "unknown"
                    print(f"DEBUG: Move {mid} type: {move_type}")
                    # Show defender types
                    opp_types = getattr(state.team.opponent[opp_key], "types", [])
                    print(f"DEBUG: Defender {opp_key} types: {opp_types}")

                    acc_p = _acc_to_prob(getattr(mv, 'accuracy', 1.0))


                    # chance to move first (priority/speed); use default opp move if unknown


                    first_prob, _ = predict_order_for_ids(state, my_key, str(mid), opp_key, default_opp_move, mi)


                    expected = (avg / float(opp_max)) * acc_p


                    # mild emphasis on moving first, but don't double-count type (already in rolls)


                    score = expected * (0.6 + 0.4 * float(first_prob))


                    moves_eval.append({


                        'id': str(mid), 'name': name,


                        'score': float(score),


                        'expected': float(expected),


                        'acc_mult': float(acc_p),


                        'effectiveness': float(eff),


                    })


                except Exception as e:


                    moves_eval.append({'id': str(mid), 'name': name, 'score': 0.0, 'expected': 0.0, 'note': f'err: {e}'})


            moves_eval.sort(key=lambda x: x.get('score', 0.0), reverse=True)





        # ---- Evaluate SWITCHES -----------------------------------------------


        switches_eval: List[Dict[str, Any]] = []


        if legal_switches and opp_key:


            chart = mi.get_type_chart()


            # Current active (for risk comparison if we stay)


            stay_incoming = 0.0


            try:


                # worst revealed incoming against current active


                if my_key and opp_moves_known:


                    my_ps = state.team.ours[my_key]


                    my_max = float(my_ps.max_hp or my_ps.stats.raw.get("hp", 1) or 1)


                    worst = 0.0


                    for om in opp_moves_known:


                        d = estimate_damage(state, opp_key, my_key, str(om), mi)


                        rr = d.get('rolls', []) or []


                        if rr:


                            worst = max(worst, sum(rr)/len(rr))


                    stay_incoming = worst / my_max


            except Exception:


                pass





            # Bench options


            my_species_active = None


            try:


                if my_key:


                    my_species_active = str(getattr(state.team.ours[my_key], "species", "") or "").lower()


            except Exception:


                pass





            for p in legal_switches:


                species = str(getattr(p, 'species', '') or '')


                if species.lower() == (my_species_active or ""):


                    # Never try to switch to the active mon


                    continue





                # Find this species' key in our TeamState (best-effort, prefer non-active)


                tmp_state = get_state(battle)


                cand_key = None


                for k, ps in tmp_state.team.ours.items():


                    if str(getattr(ps, 'species', '')).lower() == species.lower() and not getattr(ps, "is_active", False):


                        cand_key = k


                        break


                if cand_key is None:


                    # fallback: first matching by species


                    for k, ps in tmp_state.team.ours.items():


                        if str(getattr(ps, 'species', '')).lower() == species.lower():


                            cand_key = k


                            break


                if cand_key is None:


                    # give up gracefully


                    switches_eval.append({'species': species, 'score': 0.0, 'hp_fraction': float(getattr(p, 'current_hp_fraction', 1.0) or 1.0), 'note': 'no-key'})


                    continue





                # Hazard + Sticky Web effects on switch-in (no mutation)


                haz = apply_switch_in_effects(tmp_state, cand_key, "ally", mi, mutate=False)


                haz_frac = float(haz.get("fraction_lost") or 0.0)





                # Expected incoming this turn if we switch (opponent attacks the switch-in)


                cand_ps = tmp_state.team.ours[cand_key]


                cand_max = float(cand_ps.max_hp or cand_ps.stats.raw.get("hp", 1) or 1)


                incoming = 0.0


                try:


                    worst = 0.0


                    test_moves = opp_moves_known or [default_opp_move]


                    for om in test_moves:


                        d = estimate_damage(tmp_state, opp_key, cand_key, str(om), mi)


                        rr = d.get('rolls', []) or []


                        if rr:


                            worst = max(worst, sum(rr)/len(rr))


                    incoming = worst / cand_max


                except Exception:


                    pass





                # Typing bonus: reward resist/immunity to revealed move types


                immune = 0


                resist = 0


                try:


                    for om in opp_moves_known:


                        # we need the move type; pull from moves DB


                        raw = mi.raw(om)


                        t = raw.get("type")


                        mult = _type_mult(t, cand_ps.types, chart)


                        if mult == 0.0:


                            immune += 1


                        elif mult <= 0.5:


                            resist += 1


                except Exception:


                    pass


                type_bonus = 0.4 * immune + 0.25 * resist
                print(f"DEBUG: Switch type bonus - immune:{immune}, resist:{resist}, bonus:{type_bonus:.2f}")





                # Outgoing potential next turn from the candidate (if we know its moves)


                out_frac = 0.0


                try:


                    best = 0.0


                    opp_ps = tmp_state.team.opponent[opp_key]


                    opp_max = float(opp_ps.max_hp or opp_ps.stats.raw.get("hp", 1) or 1)


                    for mslot in (cand_ps.moves or []):


                        mid = getattr(mslot, "id", None)


                        if not mid:


                            continue


                        d2 = estimate_damage(tmp_state, cand_key, opp_key, str(mid), mi)


                        rr2 = d2.get('rolls', []) or []


                        if rr2:


                            best = max(best, sum(rr2)/len(rr2))


                    if best > 0:


                        out_frac = best / opp_max


                except Exception:


                    pass





                hp_frac = float(getattr(p, 'current_hp_fraction', 1.0) or 1.0)


                # Risk-aware switch score: prefer lower incoming + hazards, higher future output, and better typing


                score = max(0.0, (out_frac * 1.2) - (incoming * 1.1) - (haz_frac * 0.5)) + type_bonus
                # Increase type bonus influence
                type_bonus = 0.4 * immune + 0.25 * resist
                print(f"DEBUG: Switch type bonus - immune:{immune}, resist:{resist}, bonus:{type_bonus:.2f}")
                print(f"DEBUG: Switch {species} score calc: out={out_frac:.2f}, in={incoming:.2f}, haz={haz_frac:.2f}, type_bonus={type_bonus:.2f}")





                switches_eval.append({


                    'species': species,


                    'score': float(score),


                    'hp_fraction': hp_frac,


                    'incoming_on_switch': float(incoming),


                    'hazards_frac': float(haz_frac),


                    'type_bonus': float(type_bonus),


                    'stay_incoming': float(stay_incoming),


                })





            switches_eval.sort(key=lambda x: x.get('score', 0.0), reverse=True)





        # ---- Decide -----------------------------------------------------------


        snap = snapshot_battle(battle)


        best_move = moves_eval[0] if moves_eval else None


        best_switch = switches_eval[0] if switches_eval else None





        # If we are forced to switch, do it


        if force_switch and best_switch:


            return ChosenAction(kind='switch', switch_species=best_switch['species'],


                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,


                                       'picked': {'kind': 'switch', **best_switch}})





        # Otherwise compare EVs


        if best_move and (not best_switch or best_move['score'] >= best_switch['score']):


            return ChosenAction(kind='move', move_id=str(best_move['id']),


                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,


                                       'picked': {'kind': 'move', **best_move}})


        if best_switch:


            return ChosenAction(kind='switch', switch_species=best_switch['species'],


                                debug={'candidates': moves_eval, 'switches': switches_eval, 'snapshot': snap,


                                       'picked': {'kind': 'switch', **best_switch}})





        # Fallbacks


        if legal_moves:


            return ChosenAction(kind='move', move_id=str(getattr(legal_moves[0], 'id', '')),


                                debug={'snapshot': snap, 'fallback': True})


        if legal_switches:


            # never pick active species


            for p in legal_switches:


                sp = str(getattr(p, 'species', '') or '')


                if my_key:


                    cursp = str(getattr(state.team.ours[my_key], 'species', '') or '')


                else:


                    cursp = ''


                if sp.lower() != cursp.lower():


                    return ChosenAction(kind='switch', switch_species=sp, debug={'snapshot': snap, 'fallback': True})


            # if all else fails, pick first bench


            return ChosenAction(kind='switch', switch_species=str(getattr(legal_switches[0], 'species', '')),


                                debug={'snapshot': snap, 'fallback': True})


        return ChosenAction(kind='move', move_id='struggle', debug={'snapshot': snap, 'fallback': True})





# -------------- Poke-env Player wrapper -----------------------------------


try:


    from poke_env.player.player import Player  # type: ignore


except Exception:


    Player = object  # fallback for type checking





class StockfishPokeEnvPlayer(Player):  # type: ignore[misc]


    def __init__(self, *args, **kwargs):


        # Hook for UI


        self.on_think_hook = kwargs.pop('on_think', None)


        engine_depth = kwargs.pop('engine_depth', None)


        self.engine = kwargs.pop('engine', None) or StockfishModel(kwargs.get('battle_format', 'gen9ou'))


        try:


            self.engine.set_depth(int(engine_depth))


        except Exception:


            pass


        super().__init__(*args, **kwargs)


        # Convenience alias for older UI code


        try:


            self._psclient = self.ps_client


        except Exception:


            pass





    # --------------- Buttons ---------------


    async def forfeit_all(self):


        # Forfeit all ongoing battles using the official client API.


        try:


            battles = dict(getattr(self, 'battles', {}) or {})


            client = getattr(self, 'ps_client', None)


            if not client:


                return


            for _id, b in battles.items():


                try:


                    tag = getattr(b, 'battle_tag', getattr(b, 'room_id', None)) or _id


                    await client.send_message('/forfeit', room=str(tag))


                except Exception:


                    continue


        except Exception:


            pass





    async def timer_all(self, on: bool):


        try:


            battles = dict(getattr(self, 'battles', {}) or {})


            client = getattr(self, 'ps_client', None)


            if not client:


                return


            msg = '/timer on' if on else '/timer off'


            for _id, b in battles.items():


                try:


                    tag = getattr(b, 'battle_tag', getattr(b, 'room_id', None)) or _id


                    await client.send_message(msg, room=str(tag))


                except Exception:


                    continue


        except Exception:


            pass





    # --------------- Core decision ---------------


    def choose_move(self, battle):


        decision = self.engine.choose_action(battle)


        try:


            if self.on_think_hook and isinstance(decision.debug, dict):


                # provide the snapshot and current battle object


                dd = dict(decision.debug)


                dd.setdefault('snapshot', snapshot_battle(battle))


                try:


                    import json, logging


                    logging.getLogger('Think').info(


                        'UI_THINK turn=%s payload=%s',


                        getattr(battle, 'turn', None),


                        json.dumps(dd, default=str)


                    )


                except Exception:


                    pass


                self.on_think_hook(battle, dd)


        except Exception:


            pass





        # Convert ChosenAction to poke-env order


        try:


            if decision.kind == 'move' and decision.move_id:


                for m in (getattr(battle, 'available_moves', []) or []):


                    if str(getattr(m, 'id', '')) == str(decision.move_id):


                        return self.create_order(m)


                # fallback: first legal move


                return self.create_order((getattr(battle, 'available_moves', []) or [None])[0]) or self.choose_random_move(battle)


            elif decision.kind == 'switch' and decision.switch_species:


                # never select active mon


                try:


                    cur = getattr(battle, "active_pokemon", None)


                    cursp = (getattr(cur, "species", None) or "").lower()


                except Exception:


                    cursp = ""


                for p in (getattr(battle, 'available_switches', []) or []):


                    sp = (str(getattr(p, 'species', '')).lower())


                    if sp == cursp:


                        continue


                    if sp == str(decision.switch_species).lower():


                        return self.create_order(p)


                # if not found by species, pick first bench (guard)


                for p in (getattr(battle, 'available_switches', []) or []):


                    if (str(getattr(p, 'species', '')).lower()) != cursp:


                        return self.create_order(p)


                return self.choose_random_move(battle)


            return self.choose_random_move(battle)


        except Exception:


            return self.choose_random_move(battle)
